// Generated by Haxe 4.2.0-rc.1
(function ($hx_exports, $global) { "use strict";
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedLeft: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return HxOverrides.substr(this.r.s,0,this.r.m.index);
	}
	,matchedRight: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		var sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
	,__class__: EReg
};
var Console = function() { };
Console.__name__ = true;
Console.format = function(s,formatMode) {
	s += "<//>";
	var activeFormatFlagStack = [];
	var groupedProceedingTags = [];
	var browserFormatArguments = [];
	var result = Console.formatTagPattern.map(s,function(e) {
		var escaped = e.matched(1) != null;
		if(escaped) {
			return e.matched(0);
		}
		var open = e.matched(2) == null;
		var tags = e.matched(3).split(",");
		if(!open && tags.length == 1) {
			if(tags[0] == "") {
				var last = activeFormatFlagStack[activeFormatFlagStack.length - 1];
				var i = activeFormatFlagStack.indexOf(last);
				if(i != -1) {
					var proceedingTags = groupedProceedingTags[i];
					activeFormatFlagStack.splice(i - proceedingTags,proceedingTags + 1);
					groupedProceedingTags.splice(i - proceedingTags,proceedingTags + 1);
				}
			} else if(FormatFlag.fromString(tags[0]) == "reset") {
				activeFormatFlagStack = [];
				groupedProceedingTags = [];
			} else {
				var flag = FormatFlag.fromString(tags[0]);
				if(flag != null) {
					var i = activeFormatFlagStack.indexOf(flag);
					if(i != -1) {
						var proceedingTags = groupedProceedingTags[i];
						activeFormatFlagStack.splice(i - proceedingTags,proceedingTags + 1);
						groupedProceedingTags.splice(i - proceedingTags,proceedingTags + 1);
					}
				}
			}
		} else {
			var proceedingTags = 0;
			var _g = 0;
			while(_g < tags.length) {
				var tag = tags[_g];
				++_g;
				var flag = FormatFlag.fromString(tag);
				if(flag == null) {
					return e.matched(0);
				}
				if(open) {
					activeFormatFlagStack.push(flag);
					groupedProceedingTags.push(proceedingTags);
					++proceedingTags;
				} else {
					var i = activeFormatFlagStack.indexOf(flag);
					if(i != -1) {
						var proceedingTags1 = groupedProceedingTags[i];
						activeFormatFlagStack.splice(i - proceedingTags1,proceedingTags1 + 1);
						groupedProceedingTags.splice(i - proceedingTags1,proceedingTags1 + 1);
					}
				}
			}
		}
		switch(formatMode) {
		case 1:
			var browserFormatArguments1 = browserFormatArguments;
			var result = new Array(activeFormatFlagStack.length);
			var _g = 0;
			var _g1 = activeFormatFlagStack.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = Console.getBrowserFormat(activeFormatFlagStack[i]);
			}
			var _g = [];
			var _g1 = 0;
			var _g2 = result;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(v != null) {
					_g.push(v);
				}
			}
			browserFormatArguments1.push(_g.join(";"));
			return "%c";
		case 2:
			return "";
		}
	});
	return { formatted : result, browserFormatArguments : browserFormatArguments};
};
Console.printFormatted = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	var result = Console.format(s,Console.formatMode);
	if(Console.formatMode == 1) {
		var logArgs = [result.formatted].concat(result.browserFormatArguments);
		switch(outputStream) {
		case 1:
			console.warn.apply(console, logArgs);
			break;
		case 2:
			console.error.apply(console, logArgs);
			break;
		case 0:case 3:
			console.log.apply(console, logArgs);
			break;
		}
		return;
	}
	Console.print(result.formatted,outputStream);
};
Console.print = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	if(Console.printIntercept != null) {
		var allowDefaultPrint = Console.printIntercept(s,outputStream);
		if(!allowDefaultPrint) {
			return;
		}
	}
	switch(outputStream) {
	case 1:
		console.warn(s);
		break;
	case 2:
		console.error(s);
		break;
	case 0:case 3:
		console.log(s);
		break;
	}
};
Console.getBrowserFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		return "color: " + flag;
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		return "background-color: " + HxOverrides.substr(flag,2,null);
	}
	if(flag.charAt(0) == "{") {
		return HxOverrides.substr(flag,1,flag.length - 2);
	}
	switch(flag) {
	case "bg_black":
		return "background-color: black";
	case "bg_blue":
		return "background-color: blue";
	case "bg_cyan":
		return "background-color: cyan";
	case "bg_green":
		return "background-color: green";
	case "bg_light_black":
		return "background-color: gray";
	case "bg_light_blue":
		return "background-color: lightBlue";
	case "bg_light_cyan":
		return "background-color: lightCyan";
	case "bg_light_green":
		return "background-color: lightGreen";
	case "bg_light_magenta":
		return "background-color: lightPink";
	case "bg_light_red":
		return "background-color: salmon";
	case "bg_light_white":
		return "background-color: white";
	case "bg_light_yellow":
		return "background-color: lightYellow";
	case "bg_magenta":
		return "background-color: magenta";
	case "bg_red":
		return "background-color: red";
	case "bg_white":
		return "background-color: whiteSmoke";
	case "bg_yellow":
		return "background-color: gold";
	case "black":
		return "color: black";
	case "blink":
		return "text-decoration: blink";
	case "blue":
		return "color: blue";
	case "bold":
		return "font-weight: bold";
	case "cyan":
		return "color: cyan";
	case "dim":
		return "color: gray";
	case "green":
		return "color: green";
	case "hidden":
		return "visibility: hidden; color: white";
	case "invert":
		return "-webkit-filter: invert(100%); filter: invert(100%)";
	case "italic":
		return "font-style: italic";
	case "light_black":
		return "color: gray";
	case "light_blue":
		return "color: lightBlue";
	case "light_cyan":
		return "color: lightCyan";
	case "light_green":
		return "color: lightGreen";
	case "light_magenta":
		return "color: lightPink";
	case "light_red":
		return "color: salmon";
	case "light_white":
		return "color: white";
	case "light_yellow":
		return "color: #ffed88";
	case "magenta":
		return "color: magenta";
	case "red":
		return "color: red";
	case "reset":
		return "";
	case "underline":
		return "text-decoration: underline";
	case "white":
		return "color: whiteSmoke";
	case "yellow":
		return "color: #f5ba00";
	default:
		return "";
	}
};
Console.determineConsoleFormatMode = function() {
	var hasWindowObject = typeof(window) != "undefined";
	if(hasWindowObject) {
		return 1;
	}
	return 2;
};
var FormatFlag = {};
FormatFlag.fromString = function(str) {
	str = str.toLowerCase();
	if(str.charAt(0) == "#" || HxOverrides.substr(str,0,3) == "bg#") {
		var hIdx = str.indexOf("#");
		var hex = HxOverrides.substr(str,hIdx + 1,null);
		if(hex.length == 3) {
			var a = hex.split("");
			hex = [a[0],a[0],a[1],a[1],a[2],a[2]].join("");
		}
		if(new EReg("[^0-9a-f]","i").match(hex) || hex.length < 6) {
			return "";
		}
		var normalized = str.substring(0,hIdx) + "#" + hex;
		return normalized;
	}
	switch(str) {
	case "!":
		return "invert";
	case "/":
		return "reset";
	case "b":
		return "bold";
	case "bg_gray":
		return "bg_light_black";
	case "gray":
		return "light_black";
	case "i":
		return "italic";
	case "u":
		return "underline";
	default:
		return str;
	}
};
var api_IFluidComponent = function() { };
api_IFluidComponent.__name__ = true;
api_IFluidComponent.__isInterface__ = true;
api_IFluidComponent.prototype = {
	__class__: api_IFluidComponent
};
var FluidComponent = $hx_exports["FluidComponent"] = function(gl,drawingBufferWidth,drawingBufferHeight) {
	this.savedSettings = null;
	this.cameraRequested = false;
	this.settings = new Settings();
	this.particleCount = 65536;
	this.showDebugTextures = false;
	this.postProcessingEnabled = false;
	this.remapFluidColor = true;
	this.renderFluidEnabled = true;
	this.renderParticlesEnabled = false;
	this.pointerDataBuffer = new Float32Array(20);
	this.pointerPositionsBuffer = new Float32Array(40);
	this.activePointersLastFrame = new haxe_ds_IntMap();
	this.activePointers = new haxe_ds_IntMap();
	this.screenBuffer = null;
	this.screenTriangle = null;
	this.gl = gl;
	this.drawingBufferWidth = drawingBufferWidth;
	this.drawingBufferHeight = drawingBufferHeight;
	this.screenBuffer = gl.getParameter(36006);
	if(this.screenBuffer != null) {
		var s = Console.logPrefix + ("<b,yellow>Screenbuffer at initialization is" + Console.argSeparator + Std.string(this.screenBuffer));
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
	}
	var debugRenderExt = gl.getExtension("WEBGL_debug_renderer_info");
	var deviceInfo = debugRenderExt != null ? { renderer : gl.getParameter(37446), vendor : gl.getParameter(37445)} : { renderer : gl.getParameter(7937), vendor : gl.getParameter(7936)};
	var s = Console.logPrefix + ("" + Std.string("<b>" + Std.string(deviceInfo.vendor) + "</b> - <b>" + Std.string(deviceInfo.renderer) + "</b>"));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	GPUCapabilities.get(gl).printReport();
	gl.disable(2929);
	gl.disable(2884);
	gl.disable(3024);
	this.initializeGPUResources();
	this.lastTime = HxOverrides.now() / 1000;
};
FluidComponent.__name__ = true;
FluidComponent.__interfaces__ = [api_IFluidComponent];
FluidComponent.prototype = {
	initializeShaders: function() {
		this.screenTextureShader = new ScreenTexture(this.gl);
		this.renderParticlesShader = new ColorParticleMotion(this.gl);
		this.updateSurfaceShader = new UpdateSurfaceShader(this.gl);
		var _this = this.updateSurfaceShader.userVelocityTexture;
		var data = SharedGPUResources.getNullTexture(this.gl).native;
		_this.dirty = true;
		_this.data = data;
		var _this = this.updateSurfaceShader.decayFactor;
		_this.dirty = true;
		_this.data = this.settings.surfaceDecayFactor;
		var _this = this.updateSurfaceShader.pointerPositions;
		_this.dirty = true;
		_this.data = this.pointerPositionsBuffer;
		this.updateSurfaceShader.pointerPositions.alwaysDirty = true;
		var _this = this.updateSurfaceShader.pointerData;
		_this.dirty = true;
		_this.data = this.pointerDataBuffer;
		this.updateSurfaceShader.pointerData.alwaysDirty = true;
		var _this = this.updateSurfaceShader.gradient;
		var data = new Float32Array(ui_GradientTools.gradientToArray(this.settings.backgroundPalette,2.1));
		_this.dirty = true;
		_this.data = data;
		var _this = this.updateSurfaceShader.backgroundMultiplier;
		_this.dirty = true;
		_this.data = this.settings.backgroundMultiplier;
		this.updateSurfaceShader.set_enableUserVelocity("true");
		this.updateForceShader = new UpdateForceShader(this.gl);
		var _this = this.updateForceShader.userVelocityTexture;
		var data = SharedGPUResources.getNullTexture(this.gl).native;
		_this.dirty = true;
		_this.data = data;
		var _this = this.updateForceShader.dragCoefficient;
		_this.dirty = true;
		_this.data = this.settings.dragCoefficient;
		var _this = this.updateForceShader.dragSpeed;
		_this.dirty = true;
		_this.data = this.settings.dragSpeed;
		var _this = this.updateForceShader.decayFactor;
		_this.dirty = true;
		_this.data = this.settings.motionDecayFactor;
		var _this = this.updateForceShader.pointerPositions;
		_this.dirty = true;
		_this.data = this.pointerPositionsBuffer;
		this.updateForceShader.pointerPositions.alwaysDirty = true;
		var _this = this.updateForceShader.pointerData;
		_this.dirty = true;
		_this.data = this.pointerDataBuffer;
		this.updateForceShader.pointerData.alwaysDirty = true;
		var _this = this.updateForceShader.opticalFlowExponent;
		_this.dirty = true;
		_this.data = this.settings.opticalFlowExponent;
		var this1 = this.updateForceShader.gravity.data;
		this1[0] = 0;
		this1[1] = 0;
		this.updateForceShader.set_enableUserVelocity("true");
		this.renderFluidShader = new RenderFluidShader(this.gl);
		var _this = this.renderFluidShader.alphaGradient;
		var data = new Float32Array(ui_GradientTools.gradientToArray(this.settings.alphaGradient,2.1));
		_this.dirty = true;
		_this.data = data;
		var _this = this.renderFluidShader.velocityGradient;
		var data = new Float32Array(ui_GradientTools.gradientToArray(this.settings.velocityGradient,2.1));
		_this.dirty = true;
		_this.data = data;
		var _this = this.renderFluidShader.invGamma;
		_this.dirty = true;
		_this.data = 1. / this.settings.gamma;
		var this1 = this.renderFluidShader.vignetteParams.data;
		this1[0] = this.settings.vignetteMagnitude;
		this1[1] = this.settings.vignetteExponent;
		this1[2] = this.settings.vignetteOpacity;
	}
	,initializeGPUResources: function() {
		var _gthis = this;
		this.initializeShaders();
		this.screenTriangle = SharedGPUResources.getScreenTriangle(this.gl);
		var fluidWidth = this.settings.fluidScale * this.drawingBufferWidth | 0;
		var fluidHeight = this.settings.fluidScale * this.drawingBufferHeight | 0;
		this.fluid = new GPUFluid(this.gl,fluidWidth,fluidHeight,this.settings.simulationScale,this.settings.fluidPhysicsScale,this.settings.fluidIterations,this.settings.powerOf2Fluid,this.updateForceShader,this.updateSurfaceShader);
		var _this = this.fluid;
		var v = this.settings.periodicBoundary;
		_this.periodicBoundary = v;
		_this.setWrapMode(v ? 10497 : 33071);
		_this.updateBaseUniforms();
		this.fluid.solverIterations = 0;
		var _this = this.updateSurfaceShader.decayFactor;
		_this.dirty = true;
		_this.data = 1;
		var _this = this.updateForceShader.decayFactor;
		_this.dirty = true;
		_this.data = 1;
		this.fluid.step(1);
		this.fluid.solverIterations = this.settings.fluidIterations;
		var _this = this.updateSurfaceShader.decayFactor;
		_this.dirty = true;
		_this.data = this.settings.surfaceDecayFactor;
		var _this = this.updateForceShader.decayFactor;
		_this.dirty = true;
		_this.data = this.settings.motionDecayFactor;
		var rgbHalfFloatLinear = GPUCapabilities.get(this.gl).getWritableFloatColorBufferParameters(6407,5131,9729);
		this.offscreenTarget = new render_RenderTarget(this.gl,this.fluid.width,this.fluid.height,new TextureParams(rgbHalfFloatLinear.format,rgbHalfFloatLinear.internalFormat,rgbHalfFloatLinear.dataType,rgbHalfFloatLinear.filtering,rgbHalfFloatLinear.filtering,33071,33071));
		this.settings.setChangeCallbacks({ onChangeVersion : function(_,_1) {
		}, onChangePaused : function(_,_1) {
		}, onChangeTimestepMultiplier : function(_,_1) {
		}, onChangeFluidPhysicsScale : function(v,_) {
			var _this = _gthis.fluid;
			_this.physicsScale = v;
			_this.updateBaseUniforms();
		}, onChangeSurfaceDecayFactor : function(v,_) {
			var _this = _gthis.updateSurfaceShader.decayFactor;
			_this.dirty = true;
			_this.data = v;
		}, onChangeMotionDecayFactor : function(v,_) {
			var _this = _gthis.updateForceShader.decayFactor;
			_this.dirty = true;
			_this.data = v;
		}, onChangeDragCoefficient : function(v,_) {
			var _this = _gthis.updateForceShader.dragCoefficient;
			_this.dirty = true;
			_this.data = v;
		}, onChangeDragSpeed : function(v,_) {
			var _this = _gthis.updateForceShader.dragSpeed;
			_this.dirty = true;
			_this.data = v;
		}, onChangePeriodicBoundary : function(v,_) {
			var _this = _gthis.fluid;
			_this.periodicBoundary = v;
			_this.setWrapMode(v ? 10497 : 33071);
			_this.updateBaseUniforms();
		}, onChangeBackgroundMultiplier : function(v,_) {
			var _this = _gthis.updateSurfaceShader.backgroundMultiplier;
			_this.dirty = true;
			_this.data = v;
		}, onChangeBackgroundPalette : function(v,_) {
			var _this = _gthis.updateSurfaceShader.gradient;
			var data = new Float32Array(ui_GradientTools.gradientToArray(v,2.1));
			_this.dirty = true;
			_this.data = data;
		}, onChangeFluidIterations : function(v,_) {
			_gthis.fluid.solverIterations = v;
		}, onChangeAlphaGradient : function(v,_) {
			var _this = _gthis.renderFluidShader.alphaGradient;
			var data = new Float32Array(ui_GradientTools.gradientToArray(_gthis.settings.alphaGradient,2.1));
			_this.dirty = true;
			_this.data = data;
		}, onChangeVelocityGradient : function(v,_) {
			var _this = _gthis.renderFluidShader.velocityGradient;
			var data = new Float32Array(ui_GradientTools.gradientToArray(_gthis.settings.velocityGradient,2.1));
			_this.dirty = true;
			_this.data = data;
		}, onChangeDyeGradient : function(v,_) {
		}, onChangeGamma : function(v,_) {
			var _this = _gthis.renderFluidShader.invGamma;
			_this.dirty = true;
			_this.data = 1.0 / v;
		}, onChangeVignetteMagnitude : function(v,_) {
			_gthis.renderFluidShader.vignetteParams.data[0] = v;
			_gthis.renderFluidShader.vignetteParams.dirty = true;
		}, onChangeVignetteExponent : function(v,_) {
			_gthis.renderFluidShader.vignetteParams.data[1] = v;
			_gthis.renderFluidShader.vignetteParams.dirty = true;
		}, onChangeVignetteOpacity : function(v,_) {
			_gthis.renderFluidShader.vignetteParams.data[2] = v;
			_gthis.renderFluidShader.vignetteParams.dirty = true;
		}, onChangeOpticalFlowMirrorX : function(v,_) {
			_gthis.opticalFlow.mirrorX = v;
		}, onChangeOpticalFlowTemporalSmoothing : function(v,_) {
			_gthis.opticalFlow.temporalSmoothing = v;
		}, onChangeOpticalFlowScale : function(v,_) {
			_gthis.opticalFlow.scale = v;
		}, onChangeOpticalFlowExponent : function(v,_) {
			var _this = _gthis.updateForceShader.opticalFlowExponent;
			_this.dirty = true;
			_this.data = v;
		}, onChangeOpticalFlowBlurKernel : function(v,_) {
			_gthis.opticalFlow.blurKernel = v;
		}, onChangeOpticalFlowGamma : function(v,_) {
			_gthis.opticalFlow.gamma = v;
		}, onChangeFluidScale : function(v,_) {
			_gthis.resize(_gthis.drawingBufferWidth,_gthis.drawingBufferHeight);
		}, onChangeSimulationScale : function(v,_) {
			_gthis.resize(_gthis.drawingBufferWidth,_gthis.drawingBufferHeight);
		}, onChangePowerOf2Fluid : function(v,_) {
			_gthis.resize(_gthis.drawingBufferWidth,_gthis.drawingBufferHeight);
		}});
		this.opticalFlow = new GPUOpticalFlow(this.gl);
		this.opticalFlow.mirrorX = this.settings.opticalFlowMirrorX;
		this.opticalFlow.scale = this.settings.opticalFlowScale;
		this.opticalFlow.blurKernel = this.settings.opticalFlowBlurKernel;
		this.opticalFlow.gamma = this.settings.opticalFlowGamma;
		this.bloomFilter = new filter_Bloom(this.gl);
		this.setupCameraFeed();
	}
	,setupCameraFeed: function() {
		var _gthis = this;
		var s = Console.logPrefix + "Requesting camera video";
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
		$global.navigator.mediaDevices.getUserMedia({ video : true, audio : false}).then(function(stream) {
			var tmp = window.document.createElement("video");
			_gthis.videoEl = tmp;
			_gthis.videoEl.srcObject = stream;
			_gthis.videoEl.autoplay = true;
			_gthis.videoEl.setAttribute("playsinline","");
			_gthis.videoEl.style.position = "absolute";
			_gthis.videoEl.style.width = "1px";
			_gthis.videoEl.style.left = "0px";
			_gthis.videoEl.style.top = "0px";
			_gthis.videoEl.style.zIndex = "-1000";
			_gthis.videoEl.onplaying = function() {
				var s = Console.successPrefix + ("" + Std.string("Got camera feed with size " + _gthis.videoEl.videoWidth + "x" + _gthis.videoEl.videoHeight));
				var outputStream = 0;
				if(outputStream == null) {
					outputStream = 0;
				}
				if(s == null) {
					s = "";
				}
				Console.printFormatted(s + "\n",outputStream);
				var tmp = new Texture(_gthis.gl,_gthis.videoEl.videoWidth,_gthis.videoEl.videoHeight,_gthis.gl.createTexture(),6408,6408,5121,9729,9729,33071,33071);
				_gthis.webcamTexture = tmp;
				_gthis.gl.activeTexture(33984);
				_gthis.gl.bindTexture(3553,_gthis.webcamTexture.native);
				_gthis.gl.texImage2D(3553,0,_gthis.webcamTexture.internalFormat,_gthis.webcamTexture.format,_gthis.webcamTexture.dataType,_gthis.videoEl);
				Texture.updateGLTextureParameters(_gthis.gl,_gthis.webcamTexture.native,new VariableTextureParams(_gthis.webcamTexture.magFilter,_gthis.webcamTexture.minFilter,_gthis.webcamTexture.wrapS,_gthis.webcamTexture.wrapT));
				_gthis.gl.bindTexture(3553,null);
			};
			return window.document.body.appendChild(_gthis.videoEl);
		}).catch(function(err) {
			var s = Console.errorPrefix + ("" + Std.string("Failed to access camera: " + err));
			var outputStream = 2;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
		});
		this.cameraRequested = true;
	}
	,initializeParticles: function() {
		this.particles = new GPUParticles(this.gl,this.particleCount);
		var _this = this.fluid;
		this.particles.stepParticlesShader.flowScale.data[0] = 1 / (_this.physicsScale * _this.aspectRatio);
		this.particles.stepParticlesShader.flowScale.data[1] = 1 / this.fluid.physicsScale;
		var _this = this.particles.stepParticlesShader.dragCoefficient;
		_this.dirty = true;
		_this.data = 1;
	}
	,resize: function(width,height) {
		this.drawingBufferWidth = width;
		this.drawingBufferHeight = height;
		var fluidWidth = this.settings.fluidScale * this.drawingBufferWidth | 0;
		var fluidHeight = this.settings.fluidScale * this.drawingBufferHeight | 0;
		var _this = this.fluid;
		var simulationScale = this.settings.simulationScale;
		var powerOf2Surface = this.settings.powerOf2Fluid;
		if(fluidWidth != null) {
			_this.width = fluidWidth;
		}
		if(fluidHeight != null) {
			_this.height = fluidHeight;
		}
		if(simulationScale != null) {
			_this.simulationScale = simulationScale;
		}
		if(powerOf2Surface != null) {
			_this.powerOf2Surface = powerOf2Surface;
		}
		_this.aspectRatio = _this.width / _this.height;
		_this.updateTextureSizes();
		var _this = this.offscreenTarget;
		var width = this.fluid.width;
		var height = this.fluid.height;
		var newTexture = _this.createEmptyTexture(width,height);
		_this.gl.bindFramebuffer(36160,_this.frameBufferObject);
		_this.gl.framebufferTexture2D(36160,36064,3553,newTexture.native,0);
		if(_this.texture != null) {
			var resampler = SharedGPUResources.getResampleShader(_this.gl);
			var _this1 = resampler.texture;
			_this1.dirty = true;
			_this1.data = _this.texture.native;
			_this.gl.bindFramebuffer(36160,_this.frameBufferObject);
			_this.gl.viewport(0,0,width,height);
			_this.gl.bindBuffer(34962,SharedGPUResources.getScreenTriangle(_this.gl));
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(resampler._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = resampler._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = resampler._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = resampler._attributes[i];
						var location = att.location;
						if(location != -1) {
							resampler.gl.enableVertexAttribArray(location);
							resampler.gl.vertexAttribPointer(location,att.itemCount,att.type,false,resampler._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!resampler._ready) {
					resampler.create();
				}
				resampler.gl.useProgram(resampler._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = resampler._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = resampler._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = resampler._attributes[i];
						var location = att.location;
						if(location != -1) {
							resampler.gl.enableVertexAttribArray(location);
							resampler.gl.vertexAttribPointer(location,att.itemCount,att.type,false,resampler._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				resampler._active = true;
			}
			_this.gl.drawArrays(4,0,3);
			resampler.deactivate();
			_this.gl.deleteTexture(_this.texture.native);
		} else {
			_this.gl.bindFramebuffer(36160,_this.frameBufferObject);
			_this.gl.viewport(0,0,_this.width,_this.height);
			_this.gl.clearColor(0,0,0,1);
			_this.gl.clear(16384);
		}
		_this.width = width;
		_this.height = height;
		_this.texture = newTexture;
	}
	,onFrame: function(t_ms) {
		var _gthis = this;
		if(this.settings.paused) {
			return;
		}
		var dt_s = Math.min(t_ms - this.lastTime,33.3333333333333357) / 1000;
		this.lastTime = t_ms;
		if(_gthis.webcamTexture != null) {
			_gthis.gl.activeTexture(33984);
			_gthis.gl.bindTexture(3553,_gthis.webcamTexture.native);
			_gthis.gl.texImage2D(3553,0,_gthis.webcamTexture.internalFormat,_gthis.webcamTexture.format,_gthis.webcamTexture.dataType,_gthis.videoEl);
			_gthis.gl.bindTexture(3553,null);
		}
		if(this.webcamTexture != null) {
			this.opticalFlow.frame(this.webcamTexture);
		}
		var _this = this.updateForceShader.userVelocityTexture;
		_this.dirty = true;
		_this.data = this.opticalFlow.averageVelocity._currentTarget.readFromTexture.native;
		var _this = this.updateSurfaceShader.userVelocityTexture;
		_this.dirty = true;
		_this.data = this.opticalFlow.averageVelocity._currentTarget.readFromTexture.native;
		var pointerIndex = 0;
		var map = this.activePointers;
		var _g_map = map;
		var _g_keys = map.keys();
		while(_g_keys.hasNext()) {
			var key = _g_keys.next();
			var _g1_value = _g_map.get(key);
			var _g1_key = key;
			var pointerId = _g1_key;
			var pointer = _g1_value;
			if(pointerIndex >= 10) {
				break;
			}
			var lastFramePointer = this.activePointersLastFrame.h[pointerId];
			if(lastFramePointer == null) {
				lastFramePointer = pointer;
			}
			var p = pointerIndex * 4;
			this.pointerPositionsBuffer[p] = (pointer.x / _gthis.drawingBufferWidth * 2 - 1) * _gthis.fluid.aspectRatio;
			this.pointerPositionsBuffer[p + 1] = (_gthis.drawingBufferHeight - pointer.y) / _gthis.drawingBufferHeight * 2 - 1;
			this.pointerPositionsBuffer[p + 2] = (lastFramePointer.x / _gthis.drawingBufferWidth * 2 - 1) * _gthis.fluid.aspectRatio;
			this.pointerPositionsBuffer[p + 3] = (_gthis.drawingBufferHeight - lastFramePointer.y) / _gthis.drawingBufferHeight * 2 - 1;
			var q = pointerIndex * 2;
			this.pointerDataBuffer[q] = pointer.radius / this.drawingBufferWidth * this.fluid.aspectRatio;
			this.pointerDataBuffer[q + 1] = pointer.pressure;
			var lastFramePointer1 = this.activePointersLastFrame.h[pointerId];
			if(lastFramePointer1 != null) {
				lastFramePointer1.type = pointer.type;
				lastFramePointer1.x = pointer.x;
				lastFramePointer1.y = pointer.y;
				lastFramePointer1.buttonState = pointer.buttonState;
				lastFramePointer1.pressure = pointer.pressure;
				lastFramePointer1.radius = pointer.radius;
				lastFramePointer1.angle = pointer.angle;
				lastFramePointer1.altitudeAngle = pointer.altitudeAngle;
				lastFramePointer1.azimuthAngle = pointer.azimuthAngle;
			} else {
				var this1 = this.activePointersLastFrame;
				var v = new Pointer(pointer.type,pointer.x,pointer.y,pointer.buttonState,pointer.pressure,pointer.radius,pointer.angle,pointer.altitudeAngle,pointer.azimuthAngle);
				this1.h[pointerId] = v;
			}
			++pointerIndex;
		}
		var _this = this.updateSurfaceShader.activePointerCount;
		_this.dirty = true;
		_this.data = pointerIndex;
		var _this = this.updateForceShader.activePointerCount;
		_this.dirty = true;
		_this.data = pointerIndex;
		this.fluid.step(dt_s * this.settings.timestepMultiplier);
		if(this.renderParticlesEnabled && this.particles == null) {
			this.initializeParticles();
		}
		if(this.renderParticlesEnabled) {
			var _this = this.particles.stepParticlesShader.flowVelocityField;
			_this.dirty = true;
			_this.data = this.fluid.velocityRenderTarget.readFromTexture.native;
			var _this = this.particles;
			var _this1 = _this.stepParticlesShader.dt;
			_this1.dirty = true;
			_this1.data = dt_s * this.settings.timestepMultiplier;
			var _this1 = _this.stepParticlesShader.particleData;
			_this1.dirty = true;
			_this1.data = _this.particleData.readFromTexture.native;
			var shader = _this.stepParticlesShader;
			var target = _this.particleData;
			_this.gl.viewport(0,0,target.width,target.height);
			_this.gl.bindFramebuffer(36160,target.writeFrameBufferObject);
			_this.gl.bindBuffer(34962,_this.screenTriangle);
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(shader._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = shader._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = shader._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = shader._attributes[i];
						var location = att.location;
						if(location != -1) {
							shader.gl.enableVertexAttribArray(location);
							shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!shader._ready) {
					shader.create();
				}
				shader.gl.useProgram(shader._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = shader._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = shader._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = shader._attributes[i];
						var location = att.location;
						if(location != -1) {
							shader.gl.enableVertexAttribArray(location);
							shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				shader._active = true;
			}
			_this.gl.drawArrays(4,0,3);
			shader.deactivate();
			target.tmpFBO = target.writeFrameBufferObject;
			target.writeFrameBufferObject = target.readFrameBufferObject;
			target.readFrameBufferObject = target.tmpFBO;
			target.tmpTex = target.writeToTexture;
			target.writeToTexture = target.readFromTexture;
			target.readFromTexture = target.tmpTex;
		}
		if(this.postProcessingEnabled) {
			var target = this.offscreenTarget;
			if(target == null) {
				this.gl.viewport(0,0,this.drawingBufferWidth,this.drawingBufferHeight);
				this.gl.bindFramebuffer(36160,this.screenBuffer);
			} else {
				this.gl.viewport(0,0,target.width,target.height);
				this.gl.bindFramebuffer(36160,target.frameBufferObject);
			}
			this.gl.clearColor(0,0,0,1);
			this.gl.clear(16384);
			if(this.remapFluidColor) {
				this.gl.bindBuffer(34962,this.screenTriangle);
				var _this = this.renderFluidShader.texture;
				_this.dirty = true;
				_this.data = this.fluid.surfaceRenderTarget.readFromTexture.native;
				var _this = this.renderFluidShader.velocityTexture;
				_this.dirty = true;
				_this.data = this.fluid.velocityRenderTarget.readFromTexture.native;
				var _this = this.renderFluidShader;
				var initUniforms = true;
				var initAttribs = true;
				if(initAttribs == null) {
					initAttribs = false;
				}
				if(initUniforms == null) {
					initUniforms = true;
				}
				if(_this._active) {
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
				} else {
					if(!_this._ready) {
						_this.create();
					}
					_this.gl.useProgram(_this._prog);
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
					_this._active = true;
				}
				this.gl.drawArrays(4,0,3);
				this.renderFluidShader.deactivate();
			} else {
				var texture = this.fluid.surfaceRenderTarget.readFromTexture.native;
				this.gl.bindBuffer(34962,this.screenTriangle);
				var _this = this.screenTextureShader.texture;
				_this.dirty = true;
				_this.data = texture;
				var _this = this.screenTextureShader;
				var initUniforms = true;
				var initAttribs = true;
				if(initAttribs == null) {
					initAttribs = false;
				}
				if(initUniforms == null) {
					initUniforms = true;
				}
				if(_this._active) {
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
				} else {
					if(!_this._ready) {
						_this.create();
					}
					_this.gl.useProgram(_this._prog);
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
					_this._active = true;
				}
				this.gl.drawArrays(4,0,3);
				this.screenTextureShader.deactivate();
			}
			var _this = this.bloomFilter;
			var input = this.offscreenTarget.texture;
			var textureParams = null;
			if(textureParams == null) {
				textureParams = input;
			}
			var downsampleCount = Math.floor(math_POT.log2(Math.max(input.width,input.height) / _this.downsampleSize));
			if(_this.downsampleChain != null && _this.downsampleChain.count != downsampleCount) {
				_this.downsampleChain.releaseGPUMemory();
				_this.downsampleChain = null;
			}
			if(_this.downsampleChain == null && downsampleCount > 0) {
				haxe_Log.trace("creating downsample chain",{ fileName : "src/filter/Bloom.hx", lineNumber : 36, className : "filter.Bloom", methodName : "apply", customParams : [downsampleCount]});
				_this.downsampleChain = new filter_DownsampleHalfChain(_this.gl,downsampleCount);
			}
			var downsampled = _this.downsampleChain != null ? _this.downsampleChain.apply(input) : input;
			var blurKernelX = _this.blurKernelNormalized * input.width;
			var blurKernelY = _this.blurKernelNormalized * input.height;
			var downsampleEffectiveKernel = 1 << downsampleCount;
			var gaussKernelX = blurKernelX / downsampleEffectiveKernel;
			var gaussKernelY = blurKernelY / downsampleEffectiveKernel;
			if(_this.blur != null && (_this.blur.kernelX != gaussKernelX || _this.blur.kernelY != gaussKernelY)) {
				_this.blur.releaseGPUMemory();
				_this.blur = null;
			}
			if(_this.blur == null && (gaussKernelX > 1 || gaussKernelY > 1)) {
				_this.blur = new filter_Blur(_this.gl,gaussKernelX,gaussKernelY);
			}
			var blurred = _this.blur != null ? _this.blur.apply(downsampled) : downsampled;
			var postProcessed = blurred;
			this.gl.viewport(0,0,this.drawingBufferWidth,this.drawingBufferHeight);
			this.gl.bindFramebuffer(36160,this.screenBuffer);
			this.gl.clearColor(0,0,0,1);
			this.gl.clear(16384);
			var texture = postProcessed.native;
			this.gl.bindBuffer(34962,this.screenTriangle);
			var _this = this.screenTextureShader.texture;
			_this.dirty = true;
			_this.data = texture;
			var _this = this.screenTextureShader;
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(_this._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!_this._ready) {
					_this.create();
				}
				_this.gl.useProgram(_this._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				_this._active = true;
			}
			this.gl.drawArrays(4,0,3);
			this.screenTextureShader.deactivate();
		} else {
			var target = null;
			if(target == null) {
				this.gl.viewport(0,0,this.drawingBufferWidth,this.drawingBufferHeight);
				this.gl.bindFramebuffer(36160,this.screenBuffer);
			} else {
				this.gl.viewport(0,0,target.width,target.height);
				this.gl.bindFramebuffer(36160,target.frameBufferObject);
			}
			this.gl.clearColor(0,0,0,1);
			this.gl.clear(16384);
			if(this.remapFluidColor) {
				this.gl.bindBuffer(34962,this.screenTriangle);
				var _this = this.renderFluidShader.texture;
				_this.dirty = true;
				_this.data = this.fluid.surfaceRenderTarget.readFromTexture.native;
				var _this = this.renderFluidShader.velocityTexture;
				_this.dirty = true;
				_this.data = this.fluid.velocityRenderTarget.readFromTexture.native;
				var _this = this.renderFluidShader;
				var initUniforms = true;
				var initAttribs = true;
				if(initAttribs == null) {
					initAttribs = false;
				}
				if(initUniforms == null) {
					initUniforms = true;
				}
				if(_this._active) {
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
				} else {
					if(!_this._ready) {
						_this.create();
					}
					_this.gl.useProgram(_this._prog);
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
					_this._active = true;
				}
				this.gl.drawArrays(4,0,3);
				this.renderFluidShader.deactivate();
			} else {
				var texture = this.fluid.surfaceRenderTarget.readFromTexture.native;
				this.gl.bindBuffer(34962,this.screenTriangle);
				var _this = this.screenTextureShader.texture;
				_this.dirty = true;
				_this.data = texture;
				var _this = this.screenTextureShader;
				var initUniforms = true;
				var initAttribs = true;
				if(initAttribs == null) {
					initAttribs = false;
				}
				if(initUniforms == null) {
					initUniforms = true;
				}
				if(_this._active) {
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
				} else {
					if(!_this._ready) {
						_this.create();
					}
					_this.gl.useProgram(_this._prog);
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
					_this._active = true;
				}
				this.gl.drawArrays(4,0,3);
				this.screenTextureShader.deactivate();
			}
		}
		if(this.renderParticlesEnabled) {
			this.gl.enable(3042);
			this.gl.blendFunc(774,768);
			this.gl.blendEquation(32774);
			this.gl.bindBuffer(34962,this.particles.particleUVs);
			var _this = this.renderParticlesShader.particleData;
			_this.dirty = true;
			_this.data = this.particles.particleData.readFromTexture.native;
			var _this = this.renderParticlesShader;
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(_this._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!_this._ready) {
					_this.create();
				}
				_this.gl.useProgram(_this._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				_this._active = true;
			}
			this.gl.drawArrays(0,0,this.particles.count);
			this.renderParticlesShader.deactivate();
			this.gl.disable(3042);
		}
		this.debugTextureBL = this.opticalFlow.currentFrame.processedImage;
		this.debugTextureTL = this.opticalFlow.averageVelocity._currentTarget.readFromTexture;
		if(this.showDebugTextures) {
			var size = 0.25;
			if(this.debugTextureBL != null) {
				this.gl.viewport(0,0,this.drawingBufferWidth * size | 0,this.drawingBufferHeight * size | 0);
				this.gl.bindFramebuffer(36160,this.screenBuffer);
				var texture = this.debugTextureBL.native;
				this.gl.bindBuffer(34962,this.screenTriangle);
				var _this = this.screenTextureShader.texture;
				_this.dirty = true;
				_this.data = texture;
				var _this = this.screenTextureShader;
				var initUniforms = true;
				var initAttribs = true;
				if(initAttribs == null) {
					initAttribs = false;
				}
				if(initUniforms == null) {
					initUniforms = true;
				}
				if(_this._active) {
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
				} else {
					if(!_this._ready) {
						_this.create();
					}
					_this.gl.useProgram(_this._prog);
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
					_this._active = true;
				}
				this.gl.drawArrays(4,0,3);
				this.screenTextureShader.deactivate();
			}
			if(this.debugTextureBR != null) {
				this.gl.viewport(this.drawingBufferWidth - this.drawingBufferWidth * size | 0,0,this.drawingBufferWidth * size | 0,this.drawingBufferHeight * size | 0);
				this.gl.bindFramebuffer(36160,this.screenBuffer);
				var texture = this.debugTextureBR.native;
				this.gl.bindBuffer(34962,this.screenTriangle);
				var _this = this.screenTextureShader.texture;
				_this.dirty = true;
				_this.data = texture;
				var _this = this.screenTextureShader;
				var initUniforms = true;
				var initAttribs = true;
				if(initAttribs == null) {
					initAttribs = false;
				}
				if(initUniforms == null) {
					initUniforms = true;
				}
				if(_this._active) {
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
				} else {
					if(!_this._ready) {
						_this.create();
					}
					_this.gl.useProgram(_this._prog);
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
					_this._active = true;
				}
				this.gl.drawArrays(4,0,3);
				this.screenTextureShader.deactivate();
			}
			if(this.debugTextureTL != null) {
				this.gl.viewport(0,this.drawingBufferHeight - this.drawingBufferHeight * size | 0,this.drawingBufferWidth * size | 0,this.drawingBufferHeight * size | 0);
				this.gl.bindFramebuffer(36160,this.screenBuffer);
				var texture = this.debugTextureTL.native;
				this.gl.bindBuffer(34962,this.screenTriangle);
				var _this = this.screenTextureShader.texture;
				_this.dirty = true;
				_this.data = texture;
				var _this = this.screenTextureShader;
				var initUniforms = true;
				var initAttribs = true;
				if(initAttribs == null) {
					initAttribs = false;
				}
				if(initUniforms == null) {
					initUniforms = true;
				}
				if(_this._active) {
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
				} else {
					if(!_this._ready) {
						_this.create();
					}
					_this.gl.useProgram(_this._prog);
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
					_this._active = true;
				}
				this.gl.drawArrays(4,0,3);
				this.screenTextureShader.deactivate();
			}
			if(this.debugTextureTR != null) {
				this.gl.viewport(this.drawingBufferWidth - this.drawingBufferWidth * size | 0,this.drawingBufferHeight - this.drawingBufferHeight * size | 0,this.drawingBufferWidth * size | 0,this.drawingBufferHeight * size | 0);
				this.gl.bindFramebuffer(36160,this.screenBuffer);
				var texture = this.debugTextureTR.native;
				this.gl.bindBuffer(34962,this.screenTriangle);
				var _this = this.screenTextureShader.texture;
				_this.dirty = true;
				_this.data = texture;
				var _this = this.screenTextureShader;
				var initUniforms = true;
				var initAttribs = true;
				if(initAttribs == null) {
					initAttribs = false;
				}
				if(initUniforms == null) {
					initUniforms = true;
				}
				if(_this._active) {
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
				} else {
					if(!_this._ready) {
						_this.create();
					}
					_this.gl.useProgram(_this._prog);
					if(initUniforms) {
						var _g = 0;
						var _g1 = _this._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = _this._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = _this._attributes[i];
							var location = att.location;
							if(location != -1) {
								_this.gl.enableVertexAttribArray(location);
								_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
					_this._active = true;
				}
				this.gl.drawArrays(4,0,3);
				this.screenTextureShader.deactivate();
			}
		}
	}
	,renderFluid: function(target) {
		if(target == null) {
			this.gl.viewport(0,0,this.drawingBufferWidth,this.drawingBufferHeight);
			this.gl.bindFramebuffer(36160,this.screenBuffer);
		} else {
			this.gl.viewport(0,0,target.width,target.height);
			this.gl.bindFramebuffer(36160,target.frameBufferObject);
		}
		this.gl.clearColor(0,0,0,1);
		this.gl.clear(16384);
		if(this.remapFluidColor) {
			this.gl.bindBuffer(34962,this.screenTriangle);
			var _this = this.renderFluidShader.texture;
			_this.dirty = true;
			_this.data = this.fluid.surfaceRenderTarget.readFromTexture.native;
			var _this = this.renderFluidShader.velocityTexture;
			_this.dirty = true;
			_this.data = this.fluid.velocityRenderTarget.readFromTexture.native;
			var _this = this.renderFluidShader;
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(_this._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!_this._ready) {
					_this.create();
				}
				_this.gl.useProgram(_this._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				_this._active = true;
			}
			this.gl.drawArrays(4,0,3);
			this.renderFluidShader.deactivate();
		} else {
			var texture = this.fluid.surfaceRenderTarget.readFromTexture.native;
			this.gl.bindBuffer(34962,this.screenTriangle);
			var _this = this.screenTextureShader.texture;
			_this.dirty = true;
			_this.data = texture;
			var _this = this.screenTextureShader;
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(_this._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!_this._ready) {
					_this.create();
				}
				_this.gl.useProgram(_this._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				_this._active = true;
			}
			this.gl.drawArrays(4,0,3);
			this.screenTextureShader.deactivate();
		}
	}
	,renderTexture: function(texture) {
		this.gl.bindBuffer(34962,this.screenTriangle);
		var _this = this.screenTextureShader.texture;
		_this.dirty = true;
		_this.data = texture;
		var _this = this.screenTextureShader;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(_this._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this.gl.enableVertexAttribArray(location);
						_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!_this._ready) {
				_this.create();
			}
			_this.gl.useProgram(_this._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this.gl.enableVertexAttribArray(location);
						_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			_this._active = true;
		}
		this.gl.drawArrays(4,0,3);
		this.screenTextureShader.deactivate();
	}
	,renderParticles: function() {
		this.gl.bindBuffer(34962,this.particles.particleUVs);
		var _this = this.renderParticlesShader.particleData;
		_this.dirty = true;
		_this.data = this.particles.particleData.readFromTexture.native;
		var _this = this.renderParticlesShader;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(_this._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this.gl.enableVertexAttribArray(location);
						_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!_this._ready) {
				_this.create();
			}
			_this.gl.useProgram(_this._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this.gl.enableVertexAttribArray(location);
						_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			_this._active = true;
		}
		this.gl.drawArrays(0,0,this.particles.count);
		this.renderParticlesShader.deactivate();
	}
	,renderDebugTextures: function() {
		var size = 0.25;
		if(this.debugTextureBL != null) {
			this.gl.viewport(0,0,this.drawingBufferWidth * size | 0,this.drawingBufferHeight * size | 0);
			this.gl.bindFramebuffer(36160,this.screenBuffer);
			var texture = this.debugTextureBL.native;
			this.gl.bindBuffer(34962,this.screenTriangle);
			var _this = this.screenTextureShader.texture;
			_this.dirty = true;
			_this.data = texture;
			var _this = this.screenTextureShader;
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(_this._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!_this._ready) {
					_this.create();
				}
				_this.gl.useProgram(_this._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				_this._active = true;
			}
			this.gl.drawArrays(4,0,3);
			this.screenTextureShader.deactivate();
		}
		if(this.debugTextureBR != null) {
			this.gl.viewport(this.drawingBufferWidth - this.drawingBufferWidth * size | 0,0,this.drawingBufferWidth * size | 0,this.drawingBufferHeight * size | 0);
			this.gl.bindFramebuffer(36160,this.screenBuffer);
			var texture = this.debugTextureBR.native;
			this.gl.bindBuffer(34962,this.screenTriangle);
			var _this = this.screenTextureShader.texture;
			_this.dirty = true;
			_this.data = texture;
			var _this = this.screenTextureShader;
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(_this._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!_this._ready) {
					_this.create();
				}
				_this.gl.useProgram(_this._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				_this._active = true;
			}
			this.gl.drawArrays(4,0,3);
			this.screenTextureShader.deactivate();
		}
		if(this.debugTextureTL != null) {
			this.gl.viewport(0,this.drawingBufferHeight - this.drawingBufferHeight * size | 0,this.drawingBufferWidth * size | 0,this.drawingBufferHeight * size | 0);
			this.gl.bindFramebuffer(36160,this.screenBuffer);
			var texture = this.debugTextureTL.native;
			this.gl.bindBuffer(34962,this.screenTriangle);
			var _this = this.screenTextureShader.texture;
			_this.dirty = true;
			_this.data = texture;
			var _this = this.screenTextureShader;
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(_this._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!_this._ready) {
					_this.create();
				}
				_this.gl.useProgram(_this._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				_this._active = true;
			}
			this.gl.drawArrays(4,0,3);
			this.screenTextureShader.deactivate();
		}
		if(this.debugTextureTR != null) {
			this.gl.viewport(this.drawingBufferWidth - this.drawingBufferWidth * size | 0,this.drawingBufferHeight - this.drawingBufferHeight * size | 0,this.drawingBufferWidth * size | 0,this.drawingBufferHeight * size | 0);
			this.gl.bindFramebuffer(36160,this.screenBuffer);
			var texture = this.debugTextureTR.native;
			this.gl.bindBuffer(34962,this.screenTriangle);
			var _this = this.screenTextureShader.texture;
			_this.dirty = true;
			_this.data = texture;
			var _this = this.screenTextureShader;
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(_this._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!_this._ready) {
					_this.create();
				}
				_this.gl.useProgram(_this._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				_this._active = true;
			}
			this.gl.drawArrays(4,0,3);
			this.screenTextureShader.deactivate();
		}
	}
	,reset: function() {
		var _this = this.fluid;
		var _this1 = _this.velocityRenderTarget;
		var mask = 16384;
		if(mask == null) {
			mask = 16384;
		}
		var mask1 = mask;
		if(mask1 == null) {
			mask1 = 16384;
		}
		_this1.gl.bindFramebuffer(36160,_this1.readFrameBufferObject);
		_this1.gl.viewport(0,0,_this1.width,_this1.height);
		_this1.gl.clearColor(0,0,0,1);
		_this1.gl.clear(mask1);
		var mask1 = mask;
		if(mask1 == null) {
			mask1 = 16384;
		}
		_this1.gl.bindFramebuffer(36160,_this1.writeFrameBufferObject);
		_this1.gl.viewport(0,0,_this1.width,_this1.height);
		_this1.gl.clearColor(0,0,0,1);
		_this1.gl.clear(mask1);
		var _this1 = _this.pressureRenderTarget;
		var mask = 16384;
		if(mask == null) {
			mask = 16384;
		}
		var mask1 = mask;
		if(mask1 == null) {
			mask1 = 16384;
		}
		_this1.gl.bindFramebuffer(36160,_this1.readFrameBufferObject);
		_this1.gl.viewport(0,0,_this1.width,_this1.height);
		_this1.gl.clearColor(0,0,0,1);
		_this1.gl.clear(mask1);
		var mask1 = mask;
		if(mask1 == null) {
			mask1 = 16384;
		}
		_this1.gl.bindFramebuffer(36160,_this1.writeFrameBufferObject);
		_this1.gl.viewport(0,0,_this1.width,_this1.height);
		_this1.gl.clearColor(0,0,0,1);
		_this1.gl.clear(mask1);
		var _this1 = _this.surfaceRenderTarget;
		var mask = 16384;
		if(mask == null) {
			mask = 16384;
		}
		var mask1 = mask;
		if(mask1 == null) {
			mask1 = 16384;
		}
		_this1.gl.bindFramebuffer(36160,_this1.readFrameBufferObject);
		_this1.gl.viewport(0,0,_this1.width,_this1.height);
		_this1.gl.clearColor(0,0,0,1);
		_this1.gl.clear(mask1);
		var mask1 = mask;
		if(mask1 == null) {
			mask1 = 16384;
		}
		_this1.gl.bindFramebuffer(36160,_this1.writeFrameBufferObject);
		_this1.gl.viewport(0,0,_this1.width,_this1.height);
		_this1.gl.clearColor(0,0,0,1);
		_this1.gl.clear(mask1);
		if(this.particles != null) {
			var _this = this.particles;
			var shader = _this.inititalConditionsShader;
			var target = _this.particleData;
			_this.gl.viewport(0,0,target.width,target.height);
			_this.gl.bindFramebuffer(36160,target.writeFrameBufferObject);
			_this.gl.bindBuffer(34962,_this.screenTriangle);
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(shader._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = shader._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = shader._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = shader._attributes[i];
						var location = att.location;
						if(location != -1) {
							shader.gl.enableVertexAttribArray(location);
							shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!shader._ready) {
					shader.create();
				}
				shader.gl.useProgram(shader._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = shader._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = shader._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = shader._attributes[i];
						var location = att.location;
						if(location != -1) {
							shader.gl.enableVertexAttribArray(location);
							shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				shader._active = true;
			}
			_this.gl.drawArrays(4,0,3);
			shader.deactivate();
			target.tmpFBO = target.writeFrameBufferObject;
			target.writeFrameBufferObject = target.readFrameBufferObject;
			target.readFrameBufferObject = target.tmpFBO;
			target.tmpTex = target.writeToTexture;
			target.writeToTexture = target.readFromTexture;
			target.readFromTexture = target.tmpTex;
		}
	}
	,pixelToClipSpaceX: function(x) {
		return x / this.drawingBufferWidth * 2 - 1;
	}
	,pixelToClipSpaceY: function(y) {
		return (this.drawingBufferHeight - y) / this.drawingBufferHeight * 2 - 1;
	}
	,updateSettings: function(settingsJson) {
		try {
			var obj = JSON.parse(settingsJson);
			var tmp = Object.prototype.hasOwnProperty.call(obj,"version");
			this.settings.setFromDynamic(obj);
			WebUI.reset();
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			var s = Console.errorPrefix + ("" + Std.string("Failed to update settings: " + (e == null ? "null" : Std.string(e))));
			var outputStream = 2;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
		}
	}
	,getSettingsJson: function(pretty) {
		if(pretty == null) {
			pretty = false;
		}
		var _this = this.settings;
		return JSON.stringify({ version : _this.version, paused : _this.paused, fluidPhysicsScale : _this.fluidPhysicsScale, timestepMultiplier : _this.timestepMultiplier, surfaceDecayFactor : _this.surfaceDecayFactor, motionDecayFactor : _this.motionDecayFactor, dragCoefficient : _this.dragCoefficient, dragSpeed : _this.dragSpeed, periodicBoundary : _this.periodicBoundary, backgroundMultiplier : _this.backgroundMultiplier, backgroundPalette : _this.backgroundPalette, alphaGradient : _this.alphaGradient, velocityGradient : _this.velocityGradient, dyeGradient : _this.dyeGradient, gamma : _this.gamma, vignetteOpacity : _this.vignetteOpacity, vignetteMagnitude : _this.vignetteMagnitude, vignetteExponent : _this.vignetteExponent, opticalFlowMirrorX : _this.opticalFlowMirrorX, opticalFlowTemporalSmoothing : _this.opticalFlowTemporalSmoothing, opticalFlowScale : _this.opticalFlowScale, opticalFlowExponent : _this.opticalFlowExponent, opticalFlowBlurKernel : _this.opticalFlowBlurKernel, opticalFlowGamma : _this.opticalFlowGamma, fluidIterations : _this.fluidIterations, fluidScale : _this.fluidScale, simulationScale : _this.simulationScale, powerOf2Fluid : _this.powerOf2Fluid},null,pretty ? "\t" : null);
	}
	,saveSettings: function() {
		this.savedSettings = this.getSettingsJson();
	}
	,restoreSettings: function() {
		if(this.savedSettings != null) {
			this.updateSettings(this.savedSettings);
			this.savedSettings = null;
		}
	}
	,onPointerDown: function(pointerId,type,x,y,buttonState,buttonChange,pressure,radius,angle,altitudeAngle,azimuthAngle) {
		var this1 = this.activePointers;
		var v = new Pointer(type,x,y,buttonState,pressure,radius,angle,altitudeAngle,azimuthAngle);
		this1.h[pointerId] = v;
	}
	,onPointerChange: function(pointerId,type,x,y,buttonState,buttonChange,pressure,radius,angle,altitudeAngle,azimuthAngle) {
		var pointer = this.activePointers.h[pointerId];
		if(pointer != null) {
			pointer.type = type;
			pointer.x = x;
			pointer.y = y;
			pointer.buttonState = buttonState;
			pointer.pressure = pressure;
			pointer.radius = radius;
			pointer.angle = angle;
			pointer.altitudeAngle = altitudeAngle;
			pointer.azimuthAngle = azimuthAngle;
		}
	}
	,onPointerUp: function(pointerId,type,x,y,buttonState,buttonChange,pressure,radius,angle,altitudeAngle,azimuthAngle) {
		this.activePointers.remove(pointerId);
		this.activePointersLastFrame.remove(pointerId);
	}
	,onKeyUp: function(keyCode) {
		var handled;
		switch(keyCode) {
		case 69:
			var _this = this.settings;
			var newValue = this.settings.opticalFlowScale + 0.2;
			var oldValue = _this.opticalFlowScale;
			_this.opticalFlowScale = newValue;
			if(_this.onChangeOpticalFlowScale != null && oldValue != newValue) {
				_this.onChangeOpticalFlowScale(newValue,oldValue);
				if(_this.onAnyFieldChange != null) {
					_this.onAnyFieldChange("opticalFlowScale",newValue,oldValue);
				}
			}
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "settings.opticalFlowScale" + ":</> <i,magenta>" + Std.string(this.settings.opticalFlowScale) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		case 70:
			var _this = this.settings;
			var newValue = this.settings.opticalFlowTemporalSmoothing - 1;
			var oldValue = _this.opticalFlowTemporalSmoothing;
			_this.opticalFlowTemporalSmoothing = newValue;
			if(_this.onChangeOpticalFlowTemporalSmoothing != null && oldValue != newValue) {
				_this.onChangeOpticalFlowTemporalSmoothing(newValue,oldValue);
				if(_this.onAnyFieldChange != null) {
					_this.onAnyFieldChange("opticalFlowTemporalSmoothing",newValue,oldValue);
				}
			}
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "settings.opticalFlowTemporalSmoothing" + ":</> <i,magenta>" + Std.string(this.settings.opticalFlowTemporalSmoothing) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		case 71:
			var _this = this.settings;
			var newValue = this.settings.opticalFlowGamma - 0.1;
			var oldValue = _this.opticalFlowGamma;
			_this.opticalFlowGamma = newValue;
			if(_this.onChangeOpticalFlowGamma != null && oldValue != newValue) {
				_this.onChangeOpticalFlowGamma(newValue,oldValue);
				if(_this.onAnyFieldChange != null) {
					_this.onAnyFieldChange("opticalFlowGamma",newValue,oldValue);
				}
			}
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "settings.opticalFlowGamma" + ":</> <i,magenta>" + Std.string(this.settings.opticalFlowGamma) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		case 73:
			var _this = this.settings;
			var newValue = this.settings.opticalFlowExponent + 0.2;
			var oldValue = _this.opticalFlowExponent;
			_this.opticalFlowExponent = newValue;
			if(_this.onChangeOpticalFlowExponent != null && oldValue != newValue) {
				_this.onChangeOpticalFlowExponent(newValue,oldValue);
				if(_this.onAnyFieldChange != null) {
					_this.onAnyFieldChange("opticalFlowExponent",newValue,oldValue);
				}
			}
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "settings.opticalFlowExponent" + ":</> <i,magenta>" + Std.string(this.settings.opticalFlowExponent) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		case 74:
			var _this = this.settings;
			var newValue = this.settings.opticalFlowExponent - 0.2;
			var oldValue = _this.opticalFlowExponent;
			_this.opticalFlowExponent = newValue;
			if(_this.onChangeOpticalFlowExponent != null && oldValue != newValue) {
				_this.onChangeOpticalFlowExponent(newValue,oldValue);
				if(_this.onAnyFieldChange != null) {
					_this.onAnyFieldChange("opticalFlowExponent",newValue,oldValue);
				}
			}
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "settings.opticalFlowExponent" + ":</> <i,magenta>" + Std.string(this.settings.opticalFlowExponent) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		case 75:
			var _this = this.settings;
			var newValue = this.settings.opticalFlowBlurKernel - 2;
			var oldValue = _this.opticalFlowBlurKernel;
			_this.opticalFlowBlurKernel = newValue;
			if(_this.onChangeOpticalFlowBlurKernel != null && oldValue != newValue) {
				_this.onChangeOpticalFlowBlurKernel(newValue,oldValue);
				if(_this.onAnyFieldChange != null) {
					_this.onAnyFieldChange("opticalFlowBlurKernel",newValue,oldValue);
				}
			}
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "settings.opticalFlowBlurKernel" + ":</> <i,magenta>" + Std.string(this.settings.opticalFlowBlurKernel) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		case 76:
			var _this = this.settings;
			var newValue = this.settings.gamma - 0.1;
			var oldValue = _this.gamma;
			_this.gamma = newValue;
			if(_this.onChangeGamma != null && oldValue != newValue) {
				_this.onChangeGamma(newValue,oldValue);
				if(_this.onAnyFieldChange != null) {
					_this.onAnyFieldChange("gamma",newValue,oldValue);
				}
			}
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "settings.gamma" + ":</> <i,magenta>" + Std.string(this.settings.gamma) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		case 79:
			var _this = this.settings;
			var newValue = this.settings.opticalFlowBlurKernel + 2;
			var oldValue = _this.opticalFlowBlurKernel;
			_this.opticalFlowBlurKernel = newValue;
			if(_this.onChangeOpticalFlowBlurKernel != null && oldValue != newValue) {
				_this.onChangeOpticalFlowBlurKernel(newValue,oldValue);
				if(_this.onAnyFieldChange != null) {
					_this.onAnyFieldChange("opticalFlowBlurKernel",newValue,oldValue);
				}
			}
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "settings.opticalFlowBlurKernel" + ":</> <i,magenta>" + Std.string(this.settings.opticalFlowBlurKernel) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		case 80:
			var _this = this.settings;
			var newValue = this.settings.gamma + 0.1;
			var oldValue = _this.gamma;
			_this.gamma = newValue;
			if(_this.onChangeGamma != null && oldValue != newValue) {
				_this.onChangeGamma(newValue,oldValue);
				if(_this.onAnyFieldChange != null) {
					_this.onAnyFieldChange("gamma",newValue,oldValue);
				}
			}
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "settings.gamma" + ":</> <i,magenta>" + Std.string(this.settings.gamma) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		case 82:
			this.reset();
			handled = true;
			break;
		case 83:
			var _this = this.settings;
			var newValue = this.settings.opticalFlowScale - 0.2;
			var oldValue = _this.opticalFlowScale;
			_this.opticalFlowScale = newValue;
			if(_this.onChangeOpticalFlowScale != null && oldValue != newValue) {
				_this.onChangeOpticalFlowScale(newValue,oldValue);
				if(_this.onAnyFieldChange != null) {
					_this.onAnyFieldChange("opticalFlowScale",newValue,oldValue);
				}
			}
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "settings.opticalFlowScale" + ":</> <i,magenta>" + Std.string(this.settings.opticalFlowScale) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		case 84:
			var _this = this.settings;
			var newValue = this.settings.opticalFlowTemporalSmoothing + 1;
			var oldValue = _this.opticalFlowTemporalSmoothing;
			_this.opticalFlowTemporalSmoothing = newValue;
			if(_this.onChangeOpticalFlowTemporalSmoothing != null && oldValue != newValue) {
				_this.onChangeOpticalFlowTemporalSmoothing(newValue,oldValue);
				if(_this.onAnyFieldChange != null) {
					_this.onAnyFieldChange("opticalFlowTemporalSmoothing",newValue,oldValue);
				}
			}
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "settings.opticalFlowTemporalSmoothing" + ":</> <i,magenta>" + Std.string(this.settings.opticalFlowTemporalSmoothing) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		case 86:
			this.showDebugTextures = !this.showDebugTextures;
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "showDebugTextures" + ":</> <i,magenta>" + Std.string(this.showDebugTextures) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		case 89:
			var _this = this.settings;
			var newValue = this.settings.opticalFlowGamma + 0.1;
			var oldValue = _this.opticalFlowGamma;
			_this.opticalFlowGamma = newValue;
			if(_this.onChangeOpticalFlowGamma != null && oldValue != newValue) {
				_this.onChangeOpticalFlowGamma(newValue,oldValue);
				if(_this.onAnyFieldChange != null) {
					_this.onAnyFieldChange("opticalFlowGamma",newValue,oldValue);
				}
			}
			var s = Console.logPrefix + ("" + Std.string("" + Std.string("<b>" + "settings.opticalFlowGamma" + ":</> <i,magenta>" + Std.string(this.settings.opticalFlowGamma) + "</>")));
			var outputStream = 0;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			handled = true;
			break;
		default:
			handled = false;
		}
		return handled;
	}
	,setGravity: function(x,y) {
		this.updateForceShader.gravity.data[0] = x;
		this.updateForceShader.gravity.data[1] = y;
		this.updateForceShader.gravity.dirty = true;
	}
	,releaseGPUMemory: function() {
		if(this.fluid != null) {
			this.fluid.releaseGPUMemory();
		}
		if(this.particles != null) {
			this.particles.releaseGPUMemory();
		}
		if(this.opticalFlow != null) {
			this.opticalFlow.releaseGPUMemory();
		}
		if(this.bloomFilter != null) {
			this.bloomFilter.releaseGPUMemory();
		}
		if(this.screenTextureShader != null) {
			this.screenTextureShader.destroy();
		}
		if(this.renderParticlesShader != null) {
			this.renderParticlesShader.destroy();
		}
		if(this.updateSurfaceShader != null) {
			this.updateSurfaceShader.destroy();
		}
		if(this.updateForceShader != null) {
			this.updateForceShader.destroy();
		}
		if(this.renderFluidShader != null) {
			this.renderFluidShader.destroy();
		}
		if(this.offscreenTarget != null) {
			var _this = this.offscreenTarget;
			_this.gl.deleteFramebuffer(_this.frameBufferObject);
			_this.gl.deleteTexture(_this.texture.native);
		}
		SharedGPUResources.releaseGPUMemory(this.gl);
	}
	,__class__: FluidComponent
};
var Pointer = function(type,x,y,buttonState,pressure,radius,angle,altitudeAngle,azimuthAngle) {
	this.type = type;
	this.x = x;
	this.y = y;
	this.buttonState = buttonState;
	this.pressure = pressure;
	this.radius = radius;
	this.angle = angle;
	this.altitudeAngle = altitudeAngle;
	this.azimuthAngle = azimuthAngle;
};
Pointer.__name__ = true;
Pointer.prototype = {
	__class__: Pointer
};
var shaderblox_ShaderBase = function(gl) {
	this._aStride = 0;
	this._textures = [];
	this._attributes = [];
	this._uniforms = [];
	this.gl = gl;
	this._name = ("" + Std.string(js_Boot.getClass(this))).split(".").pop();
	this.initSources();
	this.createProperties();
};
shaderblox_ShaderBase.__name__ = true;
shaderblox_ShaderBase.prototype = {
	initSources: function() {
	}
	,createProperties: function() {
	}
	,create: function() {
		this.compile(this._vertSource,this._fragSource);
		this._ready = true;
	}
	,destroy: function() {
		this.gl.deleteShader(this._vert);
		this.gl.deleteShader(this._frag);
		this.gl.deleteProgram(this._prog);
		this._prog = null;
		this._vert = null;
		this._frag = null;
		this._ready = false;
	}
	,compile: function(vertSource,fragSource) {
		var vertexShader = this.gl.createShader(35633);
		this.gl.shaderSource(vertexShader,vertSource);
		this.gl.compileShader(vertexShader);
		if(!this.gl.getShaderParameter(vertexShader,35713)) {
			haxe_Log.trace("Error compiling vertex shader: " + this.gl.getShaderInfoLog(vertexShader),{ fileName : "lib/shaderblox/shaderblox/ShaderBase.hx", lineNumber : 73, className : "shaderblox.ShaderBase", methodName : "compile"});
			haxe_Log.trace("\n" + vertSource,{ fileName : "lib/shaderblox/shaderblox/ShaderBase.hx", lineNumber : 74, className : "shaderblox.ShaderBase", methodName : "compile"});
			throw haxe_Exception.thrown("Error compiling vertex shader");
		}
		var fragmentShader = this.gl.createShader(35632);
		this.gl.shaderSource(fragmentShader,fragSource);
		this.gl.compileShader(fragmentShader);
		if(!this.gl.getShaderParameter(fragmentShader,35713)) {
			haxe_Log.trace("Error compiling fragment shader: " + this.gl.getShaderInfoLog(fragmentShader) + "\n",{ fileName : "lib/shaderblox/shaderblox/ShaderBase.hx", lineNumber : 83, className : "shaderblox.ShaderBase", methodName : "compile"});
			var lines = fragSource.split("\n");
			var i = 0;
			var _g = 0;
			while(_g < lines.length) {
				var l = lines[_g];
				++_g;
				haxe_Log.trace(i++ + " - " + l,{ fileName : "lib/shaderblox/shaderblox/ShaderBase.hx", lineNumber : 87, className : "shaderblox.ShaderBase", methodName : "compile"});
			}
			throw haxe_Exception.thrown("Error compiling fragment shader");
		}
		var shaderProgram = this.gl.createProgram();
		this.gl.attachShader(shaderProgram,vertexShader);
		this.gl.attachShader(shaderProgram,fragmentShader);
		this.gl.linkProgram(shaderProgram);
		if(!this.gl.getProgramParameter(shaderProgram,35714)) {
			throw haxe_Exception.thrown("Unable to initialize the shader program.\n" + this.gl.getProgramInfoLog(shaderProgram));
		}
		var numUniforms = this.gl.getProgramParameter(shaderProgram,35718);
		var uniformLocations_h = Object.create(null);
		while(numUniforms-- > 0) {
			var uInfo = this.gl.getActiveUniform(shaderProgram,numUniforms);
			var name = uInfo.name;
			var loc = this.gl.getUniformLocation(shaderProgram,name);
			uniformLocations_h[uInfo.name] = loc;
		}
		var numAttributes = this.gl.getProgramParameter(shaderProgram,35721);
		var attributeLocations_h = Object.create(null);
		while(numAttributes-- > 0) {
			var aInfo = this.gl.getActiveAttrib(shaderProgram,numAttributes);
			var name = aInfo.name;
			var loc = this.gl.getAttribLocation(shaderProgram,name);
			attributeLocations_h[aInfo.name] = loc;
		}
		this._vert = vertexShader;
		this._frag = fragmentShader;
		this._prog = shaderProgram;
		var count = this._uniforms.length;
		var removeList = [];
		this._numTextures = 0;
		this._textures = [];
		var _g = 0;
		var _g1 = this._uniforms;
		while(_g < _g1.length) {
			var u = _g1[_g];
			++_g;
			var loc = uniformLocations_h[u.name];
			if(loc == null) {
				loc = uniformLocations_h[u.name + "[0]"];
			}
			if(((u) instanceof shaderblox_uniforms_UTexture)) {
				var t = u;
				t.samplerIndex = this._numTextures++;
				this._textures[t.samplerIndex] = t;
			}
			if(loc != null) {
				u.location = loc;
			} else {
				removeList.push(u);
			}
		}
		while(removeList.length > 0) {
			var remove = removeList.pop();
			HxOverrides.remove(this._uniforms,remove);
		}
		var _g = 0;
		var _g1 = this._attributes;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			var loc = attributeLocations_h[a.name];
			a.location = loc == null ? -1 : loc;
		}
	}
	,deactivate: function() {
		if(!this._active) {
			return;
		}
		this._active = false;
		this.disableAttributes();
	}
	,disableAttributes: function() {
		var _g = 0;
		var _g1 = this._attributes.length;
		while(_g < _g1) {
			var i = _g++;
			var idx = this._attributes[i].location;
			if(idx == -1) {
				continue;
			}
			this.gl.disableVertexAttribArray(idx);
		}
	}
	,toString: function() {
		return "[Shader(" + this._name + ", attributes:" + this._attributes.length + ", uniforms:" + this._uniforms.length + ")]";
	}
	,__class__: shaderblox_ShaderBase
};
var ScreenTexture = function(gl) {
	shaderblox_ShaderBase.call(this,gl);
};
ScreenTexture.__name__ = true;
ScreenTexture.__super__ = shaderblox_ShaderBase;
ScreenTexture.prototype = $extend(shaderblox_ShaderBase.prototype,{
	createProperties: function() {
		shaderblox_ShaderBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"texture",null,false);
		this.texture = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_attributes_FloatAttribute("vertexPosition",0,2);
		this.vertexPosition = instance;
		this._attributes.push(instance);
		this._aStride += 8;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nattribute vec2 vertexPosition;\nvarying vec2 texelCoord;\n\nvoid main() {\n\ttexelCoord = vertexPosition;\n\tgl_Position = vec4(vertexPosition*2.0 - vec2(1.0, 1.0), 0.0, 1.0 );\n}\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform sampler2D texture;\nvarying vec2 texelCoord;\n\nvoid main(void){\n\tgl_FragColor = abs(texture2D(texture, texelCoord));\n}\n";
	}
	,__class__: ScreenTexture
});
var RenderParticles = function(gl) {
	shaderblox_ShaderBase.call(this,gl);
};
RenderParticles.__name__ = true;
RenderParticles.__super__ = shaderblox_ShaderBase;
RenderParticles.prototype = $extend(shaderblox_ShaderBase.prototype,{
	createProperties: function() {
		shaderblox_ShaderBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"particleData",null,false);
		this.particleData = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_attributes_FloatAttribute("particleUV",0,2);
		this.particleUV = instance;
		this._attributes.push(instance);
		this._aStride += 8;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform sampler2D particleData;\n\tattribute vec2 particleUV;\n\tvarying vec4 color;\n\t\n\tvoid main() {\n\t\tvec2 p = texture2D(particleData, particleUV).xy;\n\t\tvec2 v = texture2D(particleData, particleUV).zw;\n\t\tgl_PointSize = 1.0;\n\t\tgl_Position = vec4(p, 0.0, 1.0);\n\t\tcolor = vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nvarying vec4 color;\n\tvoid main() {\n\t\tgl_FragColor = vec4(color);\n\t}\n";
	}
	,__class__: RenderParticles
});
var ColorParticleMotion = function(gl) {
	RenderParticles.call(this,gl);
};
ColorParticleMotion.__name__ = true;
ColorParticleMotion.__super__ = RenderParticles;
ColorParticleMotion.prototype = $extend(RenderParticles.prototype,{
	createProperties: function() {
		RenderParticles.prototype.createProperties.call(this);
		this._aStride += 0;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform sampler2D particleData;\n\tattribute vec2 particleUV;\n\tvarying vec4 color;\n\t\n\n\nvoid main(){\n\t\tvec2 p = texture2D(particleData, particleUV).xy;\n\t\tvec2 v = texture2D(particleData, particleUV).zw;\n\t\tgl_PointSize = 3.0;\n\t\tgl_Position = vec4(p, 0.0, 1.0);\n\t\tfloat speed = length(v);\n\t\tfloat x = clamp(speed * 4.0, 0., 1.);\n\t\tcolor.rgb = (\n\t\t\t\tmix(vec3(40.4, 0.0, 35.0) / 300.0, vec3(0.2, 47.8, 100) / 100.0, x)\n\t\t\t\t+ (vec3(63.1, 92.5, 100) / 100.) * x*x*x * .1\n\t\t) + vec3(0.5);\n\t\tcolor.a = 1.0;\n\t}\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nvarying vec4 color;\n\tvoid main() {\n\t\tgl_FragColor = vec4(color);\n\t}\n\n\n";
	}
	,__class__: ColorParticleMotion
});
var FluidBase = function(gl) {
	shaderblox_ShaderBase.call(this,gl);
};
FluidBase.__name__ = true;
FluidBase.__super__ = shaderblox_ShaderBase;
FluidBase.prototype = $extend(shaderblox_ShaderBase.prototype,{
	createProperties: function() {
		shaderblox_ShaderBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UVec2(this.gl,"invResolution",null);
		this.invResolution = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"invAspectRatio",null);
		this.invAspectRatio = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UBool(this.gl,"velocityBoundaryEnabled",null);
		this.velocityBoundaryEnabled = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_attributes_FloatAttribute("vertexPosition",0,2);
		this.vertexPosition = instance;
		this._attributes.push(instance);
		this._aStride += 8;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\n \r\nattribute vec2 vertexPosition;\r\n\r\nuniform vec2 invResolution;\r\nuniform float invAspectRatio;\r\n\r\nvarying vec2 texelCoord;\r\n\r\n\n\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vB;\r\nvarying vec2 vT;\r\n\r\n\r\nvarying vec2 p;\r\n\r\nvoid main() {\r\n\ttexelCoord = vertexPosition;\r\n\t\r\n\tvL = texelCoord - vec2(invResolution.x,0);\r\n\tvR = texelCoord + vec2(invResolution.x,0);\r\n\tvB = texelCoord - vec2(0,invResolution.y);\r\n\tvT = texelCoord + vec2(0,invResolution.y);\r\n\t\r\n\tvec2 clipSpace = 2.0*texelCoord - 1.0;\t\n\t\r\n\tp = vec2(clipSpace.x / invAspectRatio, clipSpace.y);\r\n\r\n\tgl_Position = vec4(clipSpace, 0.0, 1.0 );\t\r\n}\r\n\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform float invAspectRatio;\nuniform bool velocityBoundaryEnabled;\n\nvec2 clipToSimSpace(vec2 clipSpace){\n    return vec2(clipSpace.x / invAspectRatio, clipSpace.y);\n}\n\nvec2 simToTexelSpace(vec2 simSpace){\n    return vec2(simSpace.x * invAspectRatio + 1.0 , simSpace.y + 1.0)*.5;\n}\n\n\n\n\n\n\n\n\n\n\n\n#define samplePressure(texture, coord) ( texture2D(pressure, coord).x )\n#define outOfBoundsVelocityMultiplier(coord) (velocityBoundaryEnabled ? (step(vec2(0.), coord) * step(coord, vec2(1.)) * 2. - 1. ) : vec2(1.0))\n\n#define sampleVelocity(texture, coord) ( outOfBoundsVelocityMultiplier(coord) * texture2D(velocity, coord).xy )\n";
	}
	,__class__: FluidBase
});
var UpdateSurface = function(gl) {
	FluidBase.call(this,gl);
};
UpdateSurface.__name__ = true;
UpdateSurface.__super__ = FluidBase;
UpdateSurface.prototype = $extend(FluidBase.prototype,{
	createProperties: function() {
		FluidBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"surface",null,false);
		this.surface = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"dt",null);
		this.dt = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"dx",null);
		this.dx = instance;
		this._uniforms.push(instance);
		this._aStride += 0;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\n \r\nattribute vec2 vertexPosition;\r\n\r\nuniform vec2 invResolution;\r\nuniform float invAspectRatio;\r\n\r\nvarying vec2 texelCoord;\r\n\r\n\n\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vB;\r\nvarying vec2 vT;\r\n\r\n\r\nvarying vec2 p;\r\n\r\nvoid main() {\r\n\ttexelCoord = vertexPosition;\r\n\t\r\n\tvL = texelCoord - vec2(invResolution.x,0);\r\n\tvR = texelCoord + vec2(invResolution.x,0);\r\n\tvB = texelCoord - vec2(0,invResolution.y);\r\n\tvT = texelCoord + vec2(0,invResolution.y);\r\n\t\r\n\tvec2 clipSpace = 2.0*texelCoord - 1.0;\t\n\t\r\n\tp = vec2(clipSpace.x / invAspectRatio, clipSpace.y);\r\n\r\n\tgl_Position = vec4(clipSpace, 0.0, 1.0 );\t\r\n}\r\n\n\n\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform float invAspectRatio;\nuniform bool velocityBoundaryEnabled;\n\nvec2 clipToSimSpace(vec2 clipSpace){\n    return vec2(clipSpace.x / invAspectRatio, clipSpace.y);\n}\n\nvec2 simToTexelSpace(vec2 simSpace){\n    return vec2(simSpace.x * invAspectRatio + 1.0 , simSpace.y + 1.0)*.5;\n}\n\n\n\n\n\n\n\n\n\n\n\n#define samplePressure(texture, coord) ( texture2D(pressure, coord).x )\n#define outOfBoundsVelocityMultiplier(coord) (velocityBoundaryEnabled ? (step(vec2(0.), coord) * step(coord, vec2(1.)) * 2. - 1. ) : vec2(1.0))\n\n#define sampleVelocity(texture, coord) ( outOfBoundsVelocityMultiplier(coord) * texture2D(velocity, coord).xy )\n\nuniform sampler2D surface;\n\tuniform float dt;\n\tuniform float dx;\n\tvarying vec2 texelCoord;\n\tvarying vec2 p;\n";
	}
	,__class__: UpdateSurface
});
var UpdateSurfaceShader = function(gl) {
	UpdateSurface.call(this,gl);
};
UpdateSurfaceShader.__name__ = true;
UpdateSurfaceShader.__super__ = UpdateSurface;
UpdateSurfaceShader.prototype = $extend(UpdateSurface.prototype,{
	set_enableUserVelocity: function(value) {
		this.enableUserVelocity = value;
		this._fragSource = shaderblox_glsl_GLSLTools.injectConstValue(this._fragSource,"enableUserVelocity",value);
		if(this._ready) {
			this.destroy();
		}
		return value;
	}
	,createProperties: function() {
		UpdateSurface.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"decayFactor",null);
		this.decayFactor = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"userVelocityTexture",null,false);
		this.userVelocityTexture = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UVec4Array(this.gl,"pointerPositions",null,10);
		this.pointerPositions = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UVec2Array(this.gl,"pointerData",null,10);
		this.pointerData = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UInt(this.gl,"activePointerCount",null);
		this.activePointerCount = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UVec4Array(this.gl,"gradient",null,5);
		this.gradient = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"backgroundMultiplier",null);
		this.backgroundMultiplier = instance;
		this._uniforms.push(instance);
		this._aStride += 0;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\n \r\nattribute vec2 vertexPosition;\r\n\r\nuniform vec2 invResolution;\r\nuniform float invAspectRatio;\r\n\r\nvarying vec2 texelCoord;\r\n\r\n\n\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vB;\r\nvarying vec2 vT;\r\n\r\n\r\nvarying vec2 p;\r\n\r\nvoid main() {\r\n\ttexelCoord = vertexPosition;\r\n\t\r\n\tvL = texelCoord - vec2(invResolution.x,0);\r\n\tvR = texelCoord + vec2(invResolution.x,0);\r\n\tvB = texelCoord - vec2(0,invResolution.y);\r\n\tvT = texelCoord + vec2(0,invResolution.y);\r\n\t\r\n\tvec2 clipSpace = 2.0*texelCoord - 1.0;\t\n\t\r\n\tp = vec2(clipSpace.x / invAspectRatio, clipSpace.y);\r\n\r\n\tgl_Position = vec4(clipSpace, 0.0, 1.0 );\t\r\n}\r\n\n\n\n\n\n";
		var tmp = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform float invAspectRatio;\nuniform bool velocityBoundaryEnabled;\n\nvec2 clipToSimSpace(vec2 clipSpace){\n    return vec2(clipSpace.x / invAspectRatio, clipSpace.y);\n}\n\nvec2 simToTexelSpace(vec2 simSpace){\n    return vec2(simSpace.x * invAspectRatio + 1.0 , simSpace.y + 1.0)*.5;\n}\n\n\n\n\n\n\n\n\n\n\n\n#define samplePressure(texture, coord) ( texture2D(pressure, coord).x )\n#define outOfBoundsVelocityMultiplier(coord) (velocityBoundaryEnabled ? (step(vec2(0.), coord) * step(coord, vec2(1.)) * 2. - 1. ) : vec2(1.0))\n\n#define sampleVelocity(texture, coord) ( outOfBoundsVelocityMultiplier(coord) * texture2D(velocity, coord).xy )\n\nuniform sampler2D surface;\n\tuniform float dt;\n\tuniform float dx;\n\tvarying vec2 texelCoord;\n\tvarying vec2 p;\n\n\nfloat distanceToSegment(vec2 a, vec2 b, vec2 p, out float fp){\n\tvec2 d = p - a;\n\tvec2 x = b - a;\n\n\tfp = 0.0; \n\tfloat lx = length(x);\n\t\n\tif(lx <= 0.0001) return length(d);\n\n\tfloat projection = dot(d, x / lx); \n\n\tfp = projection / lx;\n\n\tif(projection < 0.0)            return length(d);\n\telse if(projection > length(x)) return length(p - b);\n\treturn sqrt(abs(dot(d,d) - projection*projection));\n}\n\nfloat distanceToSegment(vec2 a, vec2 b, vec2 p){\n\tfloat fp;\n\treturn distanceToSegment(a, b, p, fp);\n}\n\tuniform float decayFactor;\n\tuniform sampler2D userVelocityTexture;\n\t\n\tuniform vec4 pointerPositions[10];\n\t\n\tuniform vec2 pointerData[10];\n\tuniform int activePointerCount;\n\t\n\tuniform vec4 gradient[5];\n\tuniform float backgroundMultiplier;\n\t\n\tconst bool enableUserVelocity = false;\n\t" + shaders_Gradient.vec3LinearGradient(5) + "\n\tvoid main(){\n\t\t\n\t\tvec4 color = texture2D(surface, texelCoord);\n\t\t\n\t\tvec4 backgroundColor = backgroundMultiplier > 0.0 ? vec4(linearGradient5(gradient, texelCoord.x), 0.0) : vec4(0.);\n\t\tvec4 dColor = backgroundColor * backgroundMultiplier - color;\n\t\tcolor += dColor * clamp(decayFactor * dt, 0., 1.0);\n\t\tif (enableUserVelocity) {\n\t\t\tvec2 userVelocity = texture2D(userVelocityTexture, texelCoord).xy;\n\t\t\tfloat v = length(userVelocity);\n\t\t\t\n\t\t\tcolor.a += v * dt;\n\t\t}\n\t\t\n\t\t";
		var _g = [];
		_g.push("\n\t\tif (activePointerCount > " + 0 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 0 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 0 + "].zw;\n\t\t\tfloat pressure = pointerData[" + 0 + "].y;\n\t\t\tfloat radius = pointerData[" + 0 + "].x;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat R = radius + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat x = clamp(1.0 - dist / R, 0., 1.);\n\n\t\t\t// x = smoothstep(0., 1.0, x);\n\n\t\t\tfloat normSpeed = pow(speed, 0.25) * 0.5;\n\n\t\t\t// gl_FragColor = vec4(vec3(normSpeed), 1.);\n\t\t\t// return;\n\n\t\t\t#if 0\n\n\t\t\tcolor += vec3(\n\t\t\t\tx,\n\t\t\t\tx * pressure,\n\t\t\t\tx * x * speed * speed * speed * 0.01\n\t\t\t) * dt * 60.;\n\n\t\t\t#else\n\n\t\t\tcolor.a += x * pressure * dt * 15.;\n\n\t\t\t#endif\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 1 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 1 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 1 + "].zw;\n\t\t\tfloat pressure = pointerData[" + 1 + "].y;\n\t\t\tfloat radius = pointerData[" + 1 + "].x;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat R = radius + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat x = clamp(1.0 - dist / R, 0., 1.);\n\n\t\t\t// x = smoothstep(0., 1.0, x);\n\n\t\t\tfloat normSpeed = pow(speed, 0.25) * 0.5;\n\n\t\t\t// gl_FragColor = vec4(vec3(normSpeed), 1.);\n\t\t\t// return;\n\n\t\t\t#if 0\n\n\t\t\tcolor += vec3(\n\t\t\t\tx,\n\t\t\t\tx * pressure,\n\t\t\t\tx * x * speed * speed * speed * 0.01\n\t\t\t) * dt * 60.;\n\n\t\t\t#else\n\n\t\t\tcolor.a += x * pressure * dt * 15.;\n\n\t\t\t#endif\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 2 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 2 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 2 + "].zw;\n\t\t\tfloat pressure = pointerData[" + 2 + "].y;\n\t\t\tfloat radius = pointerData[" + 2 + "].x;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat R = radius + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat x = clamp(1.0 - dist / R, 0., 1.);\n\n\t\t\t// x = smoothstep(0., 1.0, x);\n\n\t\t\tfloat normSpeed = pow(speed, 0.25) * 0.5;\n\n\t\t\t// gl_FragColor = vec4(vec3(normSpeed), 1.);\n\t\t\t// return;\n\n\t\t\t#if 0\n\n\t\t\tcolor += vec3(\n\t\t\t\tx,\n\t\t\t\tx * pressure,\n\t\t\t\tx * x * speed * speed * speed * 0.01\n\t\t\t) * dt * 60.;\n\n\t\t\t#else\n\n\t\t\tcolor.a += x * pressure * dt * 15.;\n\n\t\t\t#endif\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 3 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 3 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 3 + "].zw;\n\t\t\tfloat pressure = pointerData[" + 3 + "].y;\n\t\t\tfloat radius = pointerData[" + 3 + "].x;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat R = radius + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat x = clamp(1.0 - dist / R, 0., 1.);\n\n\t\t\t// x = smoothstep(0., 1.0, x);\n\n\t\t\tfloat normSpeed = pow(speed, 0.25) * 0.5;\n\n\t\t\t// gl_FragColor = vec4(vec3(normSpeed), 1.);\n\t\t\t// return;\n\n\t\t\t#if 0\n\n\t\t\tcolor += vec3(\n\t\t\t\tx,\n\t\t\t\tx * pressure,\n\t\t\t\tx * x * speed * speed * speed * 0.01\n\t\t\t) * dt * 60.;\n\n\t\t\t#else\n\n\t\t\tcolor.a += x * pressure * dt * 15.;\n\n\t\t\t#endif\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 4 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 4 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 4 + "].zw;\n\t\t\tfloat pressure = pointerData[" + 4 + "].y;\n\t\t\tfloat radius = pointerData[" + 4 + "].x;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat R = radius + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat x = clamp(1.0 - dist / R, 0., 1.);\n\n\t\t\t// x = smoothstep(0., 1.0, x);\n\n\t\t\tfloat normSpeed = pow(speed, 0.25) * 0.5;\n\n\t\t\t// gl_FragColor = vec4(vec3(normSpeed), 1.);\n\t\t\t// return;\n\n\t\t\t#if 0\n\n\t\t\tcolor += vec3(\n\t\t\t\tx,\n\t\t\t\tx * pressure,\n\t\t\t\tx * x * speed * speed * speed * 0.01\n\t\t\t) * dt * 60.;\n\n\t\t\t#else\n\n\t\t\tcolor.a += x * pressure * dt * 15.;\n\n\t\t\t#endif\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 5 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 5 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 5 + "].zw;\n\t\t\tfloat pressure = pointerData[" + 5 + "].y;\n\t\t\tfloat radius = pointerData[" + 5 + "].x;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat R = radius + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat x = clamp(1.0 - dist / R, 0., 1.);\n\n\t\t\t// x = smoothstep(0., 1.0, x);\n\n\t\t\tfloat normSpeed = pow(speed, 0.25) * 0.5;\n\n\t\t\t// gl_FragColor = vec4(vec3(normSpeed), 1.);\n\t\t\t// return;\n\n\t\t\t#if 0\n\n\t\t\tcolor += vec3(\n\t\t\t\tx,\n\t\t\t\tx * pressure,\n\t\t\t\tx * x * speed * speed * speed * 0.01\n\t\t\t) * dt * 60.;\n\n\t\t\t#else\n\n\t\t\tcolor.a += x * pressure * dt * 15.;\n\n\t\t\t#endif\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 6 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 6 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 6 + "].zw;\n\t\t\tfloat pressure = pointerData[" + 6 + "].y;\n\t\t\tfloat radius = pointerData[" + 6 + "].x;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat R = radius + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat x = clamp(1.0 - dist / R, 0., 1.);\n\n\t\t\t// x = smoothstep(0., 1.0, x);\n\n\t\t\tfloat normSpeed = pow(speed, 0.25) * 0.5;\n\n\t\t\t// gl_FragColor = vec4(vec3(normSpeed), 1.);\n\t\t\t// return;\n\n\t\t\t#if 0\n\n\t\t\tcolor += vec3(\n\t\t\t\tx,\n\t\t\t\tx * pressure,\n\t\t\t\tx * x * speed * speed * speed * 0.01\n\t\t\t) * dt * 60.;\n\n\t\t\t#else\n\n\t\t\tcolor.a += x * pressure * dt * 15.;\n\n\t\t\t#endif\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 7 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 7 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 7 + "].zw;\n\t\t\tfloat pressure = pointerData[" + 7 + "].y;\n\t\t\tfloat radius = pointerData[" + 7 + "].x;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat R = radius + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat x = clamp(1.0 - dist / R, 0., 1.);\n\n\t\t\t// x = smoothstep(0., 1.0, x);\n\n\t\t\tfloat normSpeed = pow(speed, 0.25) * 0.5;\n\n\t\t\t// gl_FragColor = vec4(vec3(normSpeed), 1.);\n\t\t\t// return;\n\n\t\t\t#if 0\n\n\t\t\tcolor += vec3(\n\t\t\t\tx,\n\t\t\t\tx * pressure,\n\t\t\t\tx * x * speed * speed * speed * 0.01\n\t\t\t) * dt * 60.;\n\n\t\t\t#else\n\n\t\t\tcolor.a += x * pressure * dt * 15.;\n\n\t\t\t#endif\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 8 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 8 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 8 + "].zw;\n\t\t\tfloat pressure = pointerData[" + 8 + "].y;\n\t\t\tfloat radius = pointerData[" + 8 + "].x;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat R = radius + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat x = clamp(1.0 - dist / R, 0., 1.);\n\n\t\t\t// x = smoothstep(0., 1.0, x);\n\n\t\t\tfloat normSpeed = pow(speed, 0.25) * 0.5;\n\n\t\t\t// gl_FragColor = vec4(vec3(normSpeed), 1.);\n\t\t\t// return;\n\n\t\t\t#if 0\n\n\t\t\tcolor += vec3(\n\t\t\t\tx,\n\t\t\t\tx * pressure,\n\t\t\t\tx * x * speed * speed * speed * 0.01\n\t\t\t) * dt * 60.;\n\n\t\t\t#else\n\n\t\t\tcolor.a += x * pressure * dt * 15.;\n\n\t\t\t#endif\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 9 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 9 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 9 + "].zw;\n\t\t\tfloat pressure = pointerData[" + 9 + "].y;\n\t\t\tfloat radius = pointerData[" + 9 + "].x;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat R = radius + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat x = clamp(1.0 - dist / R, 0., 1.);\n\n\t\t\t// x = smoothstep(0., 1.0, x);\n\n\t\t\tfloat normSpeed = pow(speed, 0.25) * 0.5;\n\n\t\t\t// gl_FragColor = vec4(vec3(normSpeed), 1.);\n\t\t\t// return;\n\n\t\t\t#if 0\n\n\t\t\tcolor += vec3(\n\t\t\t\tx,\n\t\t\t\tx * pressure,\n\t\t\t\tx * x * speed * speed * speed * 0.01\n\t\t\t) * dt * 60.;\n\n\t\t\t#else\n\n\t\t\tcolor.a += x * pressure * dt * 15.;\n\n\t\t\t#endif\n\t\t}");
		this._fragSource = tmp + _g.join("\n") + "\n\t\tgl_FragColor = color;\n\t}\n";
	}
	,__class__: UpdateSurfaceShader
});
var ApplyForces = function(gl) {
	FluidBase.call(this,gl);
};
ApplyForces.__name__ = true;
ApplyForces.__super__ = FluidBase;
ApplyForces.prototype = $extend(FluidBase.prototype,{
	createProperties: function() {
		FluidBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"velocity",null,false);
		this.velocity = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"dt",null);
		this.dt = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"dx",null);
		this.dx = instance;
		this._uniforms.push(instance);
		this._aStride += 0;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\n \r\nattribute vec2 vertexPosition;\r\n\r\nuniform vec2 invResolution;\r\nuniform float invAspectRatio;\r\n\r\nvarying vec2 texelCoord;\r\n\r\n\n\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vB;\r\nvarying vec2 vT;\r\n\r\n\r\nvarying vec2 p;\r\n\r\nvoid main() {\r\n\ttexelCoord = vertexPosition;\r\n\t\r\n\tvL = texelCoord - vec2(invResolution.x,0);\r\n\tvR = texelCoord + vec2(invResolution.x,0);\r\n\tvB = texelCoord - vec2(0,invResolution.y);\r\n\tvT = texelCoord + vec2(0,invResolution.y);\r\n\t\r\n\tvec2 clipSpace = 2.0*texelCoord - 1.0;\t\n\t\r\n\tp = vec2(clipSpace.x / invAspectRatio, clipSpace.y);\r\n\r\n\tgl_Position = vec4(clipSpace, 0.0, 1.0 );\t\r\n}\r\n\n\n\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform float invAspectRatio;\nuniform bool velocityBoundaryEnabled;\n\nvec2 clipToSimSpace(vec2 clipSpace){\n    return vec2(clipSpace.x / invAspectRatio, clipSpace.y);\n}\n\nvec2 simToTexelSpace(vec2 simSpace){\n    return vec2(simSpace.x * invAspectRatio + 1.0 , simSpace.y + 1.0)*.5;\n}\n\n\n\n\n\n\n\n\n\n\n\n#define samplePressure(texture, coord) ( texture2D(pressure, coord).x )\n#define outOfBoundsVelocityMultiplier(coord) (velocityBoundaryEnabled ? (step(vec2(0.), coord) * step(coord, vec2(1.)) * 2. - 1. ) : vec2(1.0))\n\n#define sampleVelocity(texture, coord) ( outOfBoundsVelocityMultiplier(coord) * texture2D(velocity, coord).xy )\n\nuniform sampler2D velocity;\n\tuniform float dt;\n\tuniform float dx;\n\tvarying vec2 texelCoord;\n\tvarying vec2 p;\n";
	}
	,__class__: ApplyForces
});
var UpdateForceShader = function(gl) {
	ApplyForces.call(this,gl);
};
UpdateForceShader.__name__ = true;
UpdateForceShader.__super__ = ApplyForces;
UpdateForceShader.prototype = $extend(ApplyForces.prototype,{
	set_enableUserVelocity: function(value) {
		this.enableUserVelocity = value;
		this._fragSource = shaderblox_glsl_GLSLTools.injectConstValue(this._fragSource,"enableUserVelocity",value);
		if(this._ready) {
			this.destroy();
		}
		return value;
	}
	,createProperties: function() {
		ApplyForces.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"userVelocityTexture",null,false);
		this.userVelocityTexture = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"decayFactor",null);
		this.decayFactor = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"dragCoefficient",null);
		this.dragCoefficient = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"dragSpeed",null);
		this.dragSpeed = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UVec4Array(this.gl,"pointerPositions",null,10);
		this.pointerPositions = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UVec2Array(this.gl,"pointerData",null,10);
		this.pointerData = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UInt(this.gl,"activePointerCount",null);
		this.activePointerCount = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"opticalFlowExponent",null);
		this.opticalFlowExponent = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UVec2(this.gl,"gravity",null);
		this.gravity = instance;
		this._uniforms.push(instance);
		this._aStride += 0;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\n \r\nattribute vec2 vertexPosition;\r\n\r\nuniform vec2 invResolution;\r\nuniform float invAspectRatio;\r\n\r\nvarying vec2 texelCoord;\r\n\r\n\n\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vB;\r\nvarying vec2 vT;\r\n\r\n\r\nvarying vec2 p;\r\n\r\nvoid main() {\r\n\ttexelCoord = vertexPosition;\r\n\t\r\n\tvL = texelCoord - vec2(invResolution.x,0);\r\n\tvR = texelCoord + vec2(invResolution.x,0);\r\n\tvB = texelCoord - vec2(0,invResolution.y);\r\n\tvT = texelCoord + vec2(0,invResolution.y);\r\n\t\r\n\tvec2 clipSpace = 2.0*texelCoord - 1.0;\t\n\t\r\n\tp = vec2(clipSpace.x / invAspectRatio, clipSpace.y);\r\n\r\n\tgl_Position = vec4(clipSpace, 0.0, 1.0 );\t\r\n}\r\n\n\n\n\n\n";
		var _g = [];
		_g.push("\n\t\tif (activePointerCount > " + 0 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 0 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 0 + "].zw;\n\t\t\tfloat radius = pointerData[" + 0 + "].x;\n\t\t\tfloat pressure = pointerData[" + 0 + "].y;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat taperFactor = 0.6;// 1 => 0 at lastMouse, 0 => no tapering\n\t\t\tfloat projectedFraction = 1.0 - clamp(fp, 0.0, 1.0)*taperFactor;\n\n\t\t\tfloat R = radius * 0.5 + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat m = exp(-dist/R) * dragCoefficient; // drag coefficient\n\t\t\tm *= projectedFraction * projectedFraction;\n\n\t\t\tvec2 targetVelocity = velocity * dx * dragSpeed * dt * 60.;\n\t\t\tv += (targetVelocity - v) * m;\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 1 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 1 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 1 + "].zw;\n\t\t\tfloat radius = pointerData[" + 1 + "].x;\n\t\t\tfloat pressure = pointerData[" + 1 + "].y;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat taperFactor = 0.6;// 1 => 0 at lastMouse, 0 => no tapering\n\t\t\tfloat projectedFraction = 1.0 - clamp(fp, 0.0, 1.0)*taperFactor;\n\n\t\t\tfloat R = radius * 0.5 + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat m = exp(-dist/R) * dragCoefficient; // drag coefficient\n\t\t\tm *= projectedFraction * projectedFraction;\n\n\t\t\tvec2 targetVelocity = velocity * dx * dragSpeed * dt * 60.;\n\t\t\tv += (targetVelocity - v) * m;\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 2 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 2 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 2 + "].zw;\n\t\t\tfloat radius = pointerData[" + 2 + "].x;\n\t\t\tfloat pressure = pointerData[" + 2 + "].y;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat taperFactor = 0.6;// 1 => 0 at lastMouse, 0 => no tapering\n\t\t\tfloat projectedFraction = 1.0 - clamp(fp, 0.0, 1.0)*taperFactor;\n\n\t\t\tfloat R = radius * 0.5 + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat m = exp(-dist/R) * dragCoefficient; // drag coefficient\n\t\t\tm *= projectedFraction * projectedFraction;\n\n\t\t\tvec2 targetVelocity = velocity * dx * dragSpeed * dt * 60.;\n\t\t\tv += (targetVelocity - v) * m;\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 3 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 3 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 3 + "].zw;\n\t\t\tfloat radius = pointerData[" + 3 + "].x;\n\t\t\tfloat pressure = pointerData[" + 3 + "].y;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat taperFactor = 0.6;// 1 => 0 at lastMouse, 0 => no tapering\n\t\t\tfloat projectedFraction = 1.0 - clamp(fp, 0.0, 1.0)*taperFactor;\n\n\t\t\tfloat R = radius * 0.5 + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat m = exp(-dist/R) * dragCoefficient; // drag coefficient\n\t\t\tm *= projectedFraction * projectedFraction;\n\n\t\t\tvec2 targetVelocity = velocity * dx * dragSpeed * dt * 60.;\n\t\t\tv += (targetVelocity - v) * m;\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 4 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 4 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 4 + "].zw;\n\t\t\tfloat radius = pointerData[" + 4 + "].x;\n\t\t\tfloat pressure = pointerData[" + 4 + "].y;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat taperFactor = 0.6;// 1 => 0 at lastMouse, 0 => no tapering\n\t\t\tfloat projectedFraction = 1.0 - clamp(fp, 0.0, 1.0)*taperFactor;\n\n\t\t\tfloat R = radius * 0.5 + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat m = exp(-dist/R) * dragCoefficient; // drag coefficient\n\t\t\tm *= projectedFraction * projectedFraction;\n\n\t\t\tvec2 targetVelocity = velocity * dx * dragSpeed * dt * 60.;\n\t\t\tv += (targetVelocity - v) * m;\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 5 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 5 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 5 + "].zw;\n\t\t\tfloat radius = pointerData[" + 5 + "].x;\n\t\t\tfloat pressure = pointerData[" + 5 + "].y;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat taperFactor = 0.6;// 1 => 0 at lastMouse, 0 => no tapering\n\t\t\tfloat projectedFraction = 1.0 - clamp(fp, 0.0, 1.0)*taperFactor;\n\n\t\t\tfloat R = radius * 0.5 + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat m = exp(-dist/R) * dragCoefficient; // drag coefficient\n\t\t\tm *= projectedFraction * projectedFraction;\n\n\t\t\tvec2 targetVelocity = velocity * dx * dragSpeed * dt * 60.;\n\t\t\tv += (targetVelocity - v) * m;\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 6 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 6 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 6 + "].zw;\n\t\t\tfloat radius = pointerData[" + 6 + "].x;\n\t\t\tfloat pressure = pointerData[" + 6 + "].y;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat taperFactor = 0.6;// 1 => 0 at lastMouse, 0 => no tapering\n\t\t\tfloat projectedFraction = 1.0 - clamp(fp, 0.0, 1.0)*taperFactor;\n\n\t\t\tfloat R = radius * 0.5 + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat m = exp(-dist/R) * dragCoefficient; // drag coefficient\n\t\t\tm *= projectedFraction * projectedFraction;\n\n\t\t\tvec2 targetVelocity = velocity * dx * dragSpeed * dt * 60.;\n\t\t\tv += (targetVelocity - v) * m;\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 7 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 7 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 7 + "].zw;\n\t\t\tfloat radius = pointerData[" + 7 + "].x;\n\t\t\tfloat pressure = pointerData[" + 7 + "].y;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat taperFactor = 0.6;// 1 => 0 at lastMouse, 0 => no tapering\n\t\t\tfloat projectedFraction = 1.0 - clamp(fp, 0.0, 1.0)*taperFactor;\n\n\t\t\tfloat R = radius * 0.5 + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat m = exp(-dist/R) * dragCoefficient; // drag coefficient\n\t\t\tm *= projectedFraction * projectedFraction;\n\n\t\t\tvec2 targetVelocity = velocity * dx * dragSpeed * dt * 60.;\n\t\t\tv += (targetVelocity - v) * m;\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 8 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 8 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 8 + "].zw;\n\t\t\tfloat radius = pointerData[" + 8 + "].x;\n\t\t\tfloat pressure = pointerData[" + 8 + "].y;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat taperFactor = 0.6;// 1 => 0 at lastMouse, 0 => no tapering\n\t\t\tfloat projectedFraction = 1.0 - clamp(fp, 0.0, 1.0)*taperFactor;\n\n\t\t\tfloat R = radius * 0.5 + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat m = exp(-dist/R) * dragCoefficient; // drag coefficient\n\t\t\tm *= projectedFraction * projectedFraction;\n\n\t\t\tvec2 targetVelocity = velocity * dx * dragSpeed * dt * 60.;\n\t\t\tv += (targetVelocity - v) * m;\n\t\t}");
		_g.push("\n\t\tif (activePointerCount > " + 9 + ") {\n\t\t\tvec2 pointer = pointerPositions[" + 9 + "].xy;\n\t\t\tvec2 lastFramePointer = pointerPositions[" + 9 + "].zw;\n\t\t\tfloat radius = pointerData[" + 9 + "].x;\n\t\t\tfloat pressure = pointerData[" + 9 + "].y;\n\n\t\t\tvec2 velocity = (pointer - lastFramePointer) / dt;\n\t\t\tfloat speed = length(velocity);\n\n\t\t\tfloat fp; // fractional projection\n\t\t\tfloat dist = distanceToSegment(pointer, lastFramePointer, p, fp);\n\n\t\t\tfloat taperFactor = 0.6;// 1 => 0 at lastMouse, 0 => no tapering\n\t\t\tfloat projectedFraction = 1.0 - clamp(fp, 0.0, 1.0)*taperFactor;\n\n\t\t\tfloat R = radius * 0.5 + pressure * pressure * pressure * 0.05;\n\n\t\t\tfloat m = exp(-dist/R) * dragCoefficient; // drag coefficient\n\t\t\tm *= projectedFraction * projectedFraction;\n\n\t\t\tvec2 targetVelocity = velocity * dx * dragSpeed * dt * 60.;\n\t\t\tv += (targetVelocity - v) * m;\n\t\t}");
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform float invAspectRatio;\nuniform bool velocityBoundaryEnabled;\n\nvec2 clipToSimSpace(vec2 clipSpace){\n    return vec2(clipSpace.x / invAspectRatio, clipSpace.y);\n}\n\nvec2 simToTexelSpace(vec2 simSpace){\n    return vec2(simSpace.x * invAspectRatio + 1.0 , simSpace.y + 1.0)*.5;\n}\n\n\n\n\n\n\n\n\n\n\n\n#define samplePressure(texture, coord) ( texture2D(pressure, coord).x )\n#define outOfBoundsVelocityMultiplier(coord) (velocityBoundaryEnabled ? (step(vec2(0.), coord) * step(coord, vec2(1.)) * 2. - 1. ) : vec2(1.0))\n\n#define sampleVelocity(texture, coord) ( outOfBoundsVelocityMultiplier(coord) * texture2D(velocity, coord).xy )\n\nuniform sampler2D velocity;\n\tuniform float dt;\n\tuniform float dx;\n\tvarying vec2 texelCoord;\n\tvarying vec2 p;\n\n\nfloat distanceToSegment(vec2 a, vec2 b, vec2 p, out float fp){\n\tvec2 d = p - a;\n\tvec2 x = b - a;\n\n\tfp = 0.0; \n\tfloat lx = length(x);\n\t\n\tif(lx <= 0.0001) return length(d);\n\n\tfloat projection = dot(d, x / lx); \n\n\tfp = projection / lx;\n\n\tif(projection < 0.0)            return length(d);\n\telse if(projection > length(x)) return length(p - b);\n\treturn sqrt(abs(dot(d,d) - projection*projection));\n}\n\nfloat distanceToSegment(vec2 a, vec2 b, vec2 p){\n\tfloat fp;\n\treturn distanceToSegment(a, b, p, fp);\n}\n\tuniform sampler2D userVelocityTexture;\n\tuniform float decayFactor;\n\tuniform float dragCoefficient;\n\tuniform float dragSpeed;\n\t\n\tuniform vec4 pointerPositions[10];\n\t\n\tuniform vec2 pointerData[10];\n\tuniform int activePointerCount;\n\tuniform float opticalFlowExponent;\n\tuniform vec2 gravity;\n\tconst bool enableUserVelocity = false;\n\tvoid main(){\n\t\tvec2 v = texture2D(velocity, texelCoord).xy;\n\t\t\n\t\t\n\t\t\n\t\tvec2 targetVelocity = gravity;\n\t\tvec2 dv = targetVelocity - v;\n\t\tv += dv * clamp(decayFactor * dt, 0., 1.0);\n\t\t\n\t\tif (enableUserVelocity) {\n\t\t\tvec2 userVelocity = texture2D(userVelocityTexture, texelCoord).xy;\n\t\t\tfloat l = length(userVelocity + 0.000001);\n\t\t\tfloat lE = pow(abs(l), opticalFlowExponent);\n\t\t\tv += userVelocity * (lE/l);\n\t\t}\n\t\t" + _g.join("\n") + "\n\t\tgl_FragColor = vec4(v, 0, 1.);\n\t}\n";
	}
	,__class__: UpdateForceShader
});
var RenderFluidShader = function(gl) {
	shaderblox_ShaderBase.call(this,gl);
};
RenderFluidShader.__name__ = true;
RenderFluidShader.__super__ = shaderblox_ShaderBase;
RenderFluidShader.prototype = $extend(shaderblox_ShaderBase.prototype,{
	createProperties: function() {
		shaderblox_ShaderBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"texture",null,false);
		this.texture = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"velocityTexture",null,false);
		this.velocityTexture = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UVec4Array(this.gl,"alphaGradient",null,5);
		this.alphaGradient = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UVec4Array(this.gl,"velocityGradient",null,5);
		this.velocityGradient = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"invGamma",null);
		this.invGamma = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UVec3(this.gl,"vignetteParams",null);
		this.vignetteParams = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_attributes_FloatAttribute("vertexPosition",0,2);
		this.vertexPosition = instance;
		this._attributes.push(instance);
		this._aStride += 8;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nattribute vec2 vertexPosition;\nvarying vec2 texelCoord;\n\nvoid main() {\n\ttexelCoord = vertexPosition;\n\tgl_Position = vec4(vertexPosition*2.0 - vec2(1.0, 1.0), 0.0, 1.0 );\n}\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nconst float gamma = 2.1;\n\nvec3 toLinear(vec3 v){\n    return pow(v,vec3(gamma));\n}\n\nvec4 toLinear(vec4 v){\n    return vec4(toLinear(v.rgb),v.a);\n}\n\nvec3 toGamma(vec3 v){\n    return pow(v,vec3(1./gamma));\n}\n\nvec4 toGamma(vec4 v){\n    return vec4(toGamma(v.rgb),v.a);\n}\n\nvec3 brightnessContrast(vec3 value, float brightness, float contrast) {\n    return (value - 0.5) * contrast + 0.5 + brightness;\n}\nuniform sampler2D texture;\nuniform sampler2D velocityTexture;\nuniform vec4 alphaGradient[5];\nuniform vec4 velocityGradient[5];\nuniform float invGamma;\nuniform vec3 vignetteParams;\nvarying vec2 texelCoord;\n" + shaders_Gradient.vec3LinearGradient(5) + "\nvoid main(void){\n\tvec4 sample = texture2D(texture, texelCoord);\n\tvec2 velocity = texture2D(velocityTexture, texelCoord).xy;\n\tfloat v = length(velocity);\n\t\n\tvec3 remapped =\n\t\tsample.rgb\n\t  + linearGradient5(alphaGradient, clamp(sample.a, 0.0, 1.)) * max(sample.a - 1.0, 1.0)\n\t  + linearGradient5(velocityGradient, clamp(v, 0., 1.)) * max(v - 1.0, 1.0)\n\t;\n\t\n\t\n\tremapped = pow(remapped, vec3(invGamma));\n\t\n\tvec2 vv = (1.0 - texelCoord.yx) * texelCoord;\n\tfloat vignette = mix(1.0, clamp(pow(vv.x * vv.y * vignetteParams.x, vignetteParams.y), 0., 1.), vignetteParams.z);\n\tgl_FragColor = vec4(remapped * vignette, 1.);\n}\n";
	}
	,__class__: RenderFluidShader
});
var GPUCapabilities = function(gl) {
	this._contextVersion = null;
	this.gl = gl;
};
GPUCapabilities.__name__ = true;
GPUCapabilities.get = function(gl) {
	var _g = 0;
	var _g1 = GPUCapabilities.capsCache;
	while(_g < _g1.length) {
		var cap = _g1[_g];
		++_g;
		if(gl == cap.gl) {
			return cap;
		}
	}
	return new GPUCapabilities(gl);
};
GPUCapabilities.prototype = {
	printReport: function() {
		var contextVersion = this.getContextVersion();
		var s = Console.logPrefix + ("" + Std.string("<b>GPU Capabilities</b>\n\t" + ["contextVersion: <b>" + (contextVersion.es ? "ES " : "") + contextVersion.major + "." + contextVersion.minor + "</b>"].join("\n\t")));
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
	}
	,testWritableColorBuffer: function(params) {
		while(this.gl.getError() != 0) {
		}
		var errors = 0;
		var colorBuffer = Texture.createTexture(this.gl,2,2,params);
		while(this.gl.getError() != 0) ++errors;
		if(errors > 0) {
			return false;
		}
		var framebuffer = this.gl.createFramebuffer();
		this.gl.bindFramebuffer(36160,framebuffer);
		this.gl.framebufferTexture2D(36160,36064,3553,colorBuffer.native,0);
		while(this.gl.getError() != 0) ++errors;
		if(errors > 0) {
			return false;
		}
		var isValid = this.gl.checkFramebufferStatus(36160) == 36053;
		this.gl.deleteTexture(colorBuffer.native);
		this.gl.deleteFramebuffer(framebuffer);
		this.gl.bindTexture(3553,null);
		this.gl.bindFramebuffer(36160,null);
		return isValid;
	}
	,getWritableFloatColorBufferParameters: function(format,dataType,filtering) {
		var contextVersion = this.getContextVersion();
		var channelSteps = [6403,33319,6407,6408];
		var dataTypeSteps = [5131,5126];
		var channelIndex = channelSteps.indexOf(format);
		var floatIndex = dataTypeSteps.indexOf(dataType);
		if(filtering == 9729) {
			this.gl.getExtension("OES_texture_float_linear");
			this.gl.getExtension("OES_texture_half_float_linear");
		}
		if(contextVersion.es && contextVersion.major <= 2) {
			this.gl.getExtension("OES_texture_float");
			this.gl.getExtension("OES_texture_half_float");
			this.gl.getExtension("EXT_color_buffer_half_float");
			format = channelSteps[Math.max(channelIndex,2) | 0];
			while(floatIndex < dataTypeSteps.length) {
				dataType = dataTypeSteps[floatIndex++];
				if(dataType == 5131) {
					dataType = 36193;
				}
				if(this.testWritableColorBuffer(new TextureParams(format,format,dataType,filtering,filtering,33071,33071))) {
					return { format : format, internalFormat : format, dataType : dataType, filtering : filtering};
				}
			}
		} else {
			this.gl.getExtension("EXT_color_buffer_float");
			var internalFormatMap16F_h = { };
			internalFormatMap16F_h[6403] = 33325;
			internalFormatMap16F_h[33319] = 33327;
			internalFormatMap16F_h[6407] = 34843;
			internalFormatMap16F_h[6408] = 34842;
			var internalFormatMap32F_h = { };
			internalFormatMap32F_h[6403] = 33326;
			internalFormatMap32F_h[33319] = 33328;
			internalFormatMap32F_h[6407] = 34837;
			internalFormatMap32F_h[6408] = 34836;
			while(floatIndex < dataTypeSteps.length) {
				dataType = dataTypeSteps[floatIndex++];
				while(channelIndex < channelSteps.length) {
					format = channelSteps[channelIndex++];
					var internalFormat;
					switch(dataType) {
					case 5126:
						internalFormat = internalFormatMap32F_h[format];
						break;
					case 5131:
						internalFormat = internalFormatMap16F_h[format];
						break;
					default:
						internalFormat = internalFormatMap32F_h[format];
					}
					if(this.testWritableColorBuffer(new TextureParams(format,internalFormat,dataType,filtering,filtering,33071,33071))) {
						return { format : format, internalFormat : internalFormat, dataType : dataType, filtering : filtering};
					}
				}
			}
		}
		return null;
	}
	,getContextVersion: function() {
		if(this._contextVersion == null) {
			var versionString = this.gl.getParameter(7938);
			var pattern = new EReg("((OpenGL ES|WebGL)\\s*)?(\\d+)\\.(\\d+)","ig");
			if(pattern.match(versionString)) {
				var prefix = pattern.matched(2);
				var isWebGL = prefix.toLowerCase() == "webgl";
				var isES = prefix != null;
				var major = Std.parseInt(pattern.matched(3)) + (isWebGL ? 1 : 0);
				var minor = Std.parseInt(pattern.matched(4));
				this._contextVersion = { es : isES, major : major, minor : minor};
			} else {
				this._contextVersion = { es : false, major : -1, minor : -1};
			}
		}
		return this._contextVersion;
	}
	,__class__: GPUCapabilities
};
var GPUFluid = function(gl,width,height,simulationScale,physicsScale,solverIterations,powerOf2Surface,applyForcesShader,updateSurfaceShader) {
	this.periodicBoundary = false;
	this.advectShader = new Advect(gl);
	this.divergenceShader = new Divergence(gl);
	this.pressureSolveShader = new PressureSolve(gl);
	this.pressureGradientSubstractShader = new PressureGradientSubstract(gl);
	this.applyForcesShader = applyForcesShader;
	this.updateSurfaceShader = updateSurfaceShader;
	this.gl = gl;
	this.width = width;
	this.height = height;
	this.powerOf2Surface = powerOf2Surface;
	this.simulationScale = simulationScale;
	this.solverIterations = solverIterations;
	this.aspectRatio = this.width / this.height;
	this.physicsScale = physicsScale;
	this.updateBaseUniforms();
	this.updateTextureSizes();
	var gpuCapabilities = GPUCapabilities.get(gl);
	var rgbaHalfFloatLinear = gpuCapabilities.getWritableFloatColorBufferParameters(6408,5131,9729);
	var rgHalfFloatLinear = gpuCapabilities.getWritableFloatColorBufferParameters(33319,5131,9729);
	var rHalfFloatLinearNearest = gpuCapabilities.getWritableFloatColorBufferParameters(6403,5131,9728);
	if(rgbaHalfFloatLinear == null) {
		var failure = "The fluid simulation requires renderable floating point textures but these are not available on this device";
		throw haxe_Exception.thrown(failure);
	}
	var wrapping = this.periodicBoundary ? 10497 : 33071;
	this.screenTriangle = SharedGPUResources.getScreenTriangle(gl);
	this.surfaceRenderTarget = new render_RenderTargetSwappable(gl,this.surfaceWidth,this.surfaceHeight,new TextureParams(rgbaHalfFloatLinear.format,rgbaHalfFloatLinear.internalFormat,rgbaHalfFloatLinear.dataType,9729,9729,wrapping,wrapping));
	this.velocityRenderTarget = new render_RenderTargetSwappable(gl,this.simulationWidth,this.simulationHeight,new TextureParams(rgHalfFloatLinear.format,rgHalfFloatLinear.internalFormat,rgHalfFloatLinear.dataType,9729,9729,wrapping,wrapping));
	this.pressureRenderTarget = new render_RenderTargetSwappable(gl,this.simulationWidth,this.simulationHeight,new TextureParams(rHalfFloatLinearNearest.format,rHalfFloatLinearNearest.internalFormat,rHalfFloatLinearNearest.dataType,9728,9728,wrapping,wrapping));
	this.divergenceRenderTarget = new render_RenderTarget(gl,this.simulationWidth,this.simulationHeight,new TextureParams(rHalfFloatLinearNearest.format,rHalfFloatLinearNearest.internalFormat,rHalfFloatLinearNearest.dataType,9728,9728,wrapping,wrapping));
	this.updateBaseUniforms();
	this.printParameters();
};
GPUFluid.__name__ = true;
GPUFluid.prototype = {
	releaseGPUMemory: function() {
		if(this.velocityRenderTarget != null) {
			var _this = this.velocityRenderTarget;
			_this.gl.deleteFramebuffer(_this.writeFrameBufferObject);
			_this.gl.deleteFramebuffer(_this.readFrameBufferObject);
			_this.gl.deleteTexture(_this.writeToTexture.native);
			_this.gl.deleteTexture(_this.readFromTexture.native);
		}
		if(this.pressureRenderTarget != null) {
			var _this = this.pressureRenderTarget;
			_this.gl.deleteFramebuffer(_this.writeFrameBufferObject);
			_this.gl.deleteFramebuffer(_this.readFrameBufferObject);
			_this.gl.deleteTexture(_this.writeToTexture.native);
			_this.gl.deleteTexture(_this.readFromTexture.native);
		}
		if(this.divergenceRenderTarget != null) {
			var _this = this.divergenceRenderTarget;
			_this.gl.deleteFramebuffer(_this.frameBufferObject);
			_this.gl.deleteTexture(_this.texture.native);
		}
		if(this.surfaceRenderTarget != null) {
			var _this = this.surfaceRenderTarget;
			_this.gl.deleteFramebuffer(_this.writeFrameBufferObject);
			_this.gl.deleteFramebuffer(_this.readFrameBufferObject);
			_this.gl.deleteTexture(_this.writeToTexture.native);
			_this.gl.deleteTexture(_this.readFromTexture.native);
		}
		if(this.advectShader != null) {
			this.advectShader.destroy();
		}
		if(this.divergenceShader != null) {
			this.divergenceShader.destroy();
		}
		if(this.pressureSolveShader != null) {
			this.pressureSolveShader.destroy();
		}
		if(this.pressureGradientSubstractShader != null) {
			this.pressureGradientSubstractShader.destroy();
		}
	}
	,step: function(dt) {
		this.gl.viewport(0,0,this.simulationWidth,this.simulationHeight);
		this.gl.bindBuffer(34962,this.screenTriangle);
		var target = this.velocityRenderTarget;
		var _this = this.advectShader.dt;
		_this.dirty = true;
		_this.data = dt;
		var _this = this.advectShader.target;
		_this.dirty = true;
		_this.data = target.readFromTexture.native;
		var _this = this.advectShader.velocity;
		_this.dirty = true;
		_this.data = this.velocityRenderTarget.readFromTexture.native;
		var shader = this.advectShader;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(shader._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = shader._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = shader._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = shader._attributes[i];
					var location = att.location;
					if(location != -1) {
						shader.gl.enableVertexAttribArray(location);
						shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!shader._ready) {
				shader.create();
			}
			shader.gl.useProgram(shader._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = shader._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = shader._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = shader._attributes[i];
					var location = att.location;
					if(location != -1) {
						shader.gl.enableVertexAttribArray(location);
						shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			shader._active = true;
		}
		target.gl.bindFramebuffer(36160,target.writeFrameBufferObject);
		this.gl.drawArrays(4,0,3);
		shader.deactivate();
		target.tmpFBO = target.writeFrameBufferObject;
		target.writeFrameBufferObject = target.readFrameBufferObject;
		target.readFrameBufferObject = target.tmpFBO;
		target.tmpTex = target.writeToTexture;
		target.writeToTexture = target.readFromTexture;
		target.readFromTexture = target.tmpTex;
		if(this.applyForcesShader != null) {
			var _this = this.applyForcesShader.dt;
			_this.dirty = true;
			_this.data = dt;
			var _this = this.applyForcesShader.velocity;
			_this.dirty = true;
			_this.data = this.velocityRenderTarget.readFromTexture.native;
			var shader = this.applyForcesShader;
			var target = this.velocityRenderTarget;
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(shader._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = shader._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = shader._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = shader._attributes[i];
						var location = att.location;
						if(location != -1) {
							shader.gl.enableVertexAttribArray(location);
							shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!shader._ready) {
					shader.create();
				}
				shader.gl.useProgram(shader._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = shader._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = shader._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = shader._attributes[i];
						var location = att.location;
						if(location != -1) {
							shader.gl.enableVertexAttribArray(location);
							shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				shader._active = true;
			}
			target.activate();
			this.gl.drawArrays(4,0,3);
			shader.deactivate();
			var _this = this.velocityRenderTarget;
			_this.tmpFBO = _this.writeFrameBufferObject;
			_this.writeFrameBufferObject = _this.readFrameBufferObject;
			_this.readFrameBufferObject = _this.tmpFBO;
			_this.tmpTex = _this.writeToTexture;
			_this.writeToTexture = _this.readFromTexture;
			_this.readFromTexture = _this.tmpTex;
		}
		var _this = this.divergenceShader.velocity;
		_this.dirty = true;
		_this.data = this.velocityRenderTarget.readFromTexture.native;
		var shader = this.divergenceShader;
		var target = this.divergenceRenderTarget;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(shader._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = shader._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = shader._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = shader._attributes[i];
					var location = att.location;
					if(location != -1) {
						shader.gl.enableVertexAttribArray(location);
						shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!shader._ready) {
				shader.create();
			}
			shader.gl.useProgram(shader._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = shader._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = shader._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = shader._attributes[i];
					var location = att.location;
					if(location != -1) {
						shader.gl.enableVertexAttribArray(location);
						shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			shader._active = true;
		}
		target.activate();
		this.gl.drawArrays(4,0,3);
		shader.deactivate();
		var _this = this.pressureSolveShader.divergence;
		_this.dirty = true;
		_this.data = this.divergenceRenderTarget.texture.native;
		var _this = this.pressureSolveShader.pressure;
		_this.dirty = true;
		_this.data = this.pressureRenderTarget.readFromTexture.native;
		var _this = this.pressureSolveShader;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(_this._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this.gl.enableVertexAttribArray(location);
						_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!_this._ready) {
				_this.create();
			}
			_this.gl.useProgram(_this._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this.gl.enableVertexAttribArray(location);
						_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			_this._active = true;
		}
		var _g = 0;
		var _g1 = this.solverIterations;
		while(_g < _g1) {
			var i = _g++;
			var _this = this.pressureSolveShader.pressure;
			_this.dirty = true;
			_this.data = this.pressureRenderTarget.readFromTexture.native;
			var _g2 = 0;
			var _g3 = this.pressureSolveShader._uniforms;
			while(_g2 < _g3.length) {
				var u = _g3[_g2];
				++_g2;
				if(u.dirty || u.alwaysDirty) {
					u.apply();
				}
			}
			var _this1 = this.pressureRenderTarget;
			_this1.gl.bindFramebuffer(36160,_this1.writeFrameBufferObject);
			this.gl.drawArrays(4,0,3);
			var _this2 = this.pressureRenderTarget;
			_this2.tmpFBO = _this2.writeFrameBufferObject;
			_this2.writeFrameBufferObject = _this2.readFrameBufferObject;
			_this2.readFrameBufferObject = _this2.tmpFBO;
			_this2.tmpTex = _this2.writeToTexture;
			_this2.writeToTexture = _this2.readFromTexture;
			_this2.readFromTexture = _this2.tmpTex;
		}
		this.pressureSolveShader.deactivate();
		var _this = this.pressureGradientSubstractShader.pressure;
		_this.dirty = true;
		_this.data = this.pressureRenderTarget.readFromTexture.native;
		var _this = this.pressureGradientSubstractShader.velocity;
		_this.dirty = true;
		_this.data = this.velocityRenderTarget.readFromTexture.native;
		var shader = this.pressureGradientSubstractShader;
		var target = this.velocityRenderTarget;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(shader._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = shader._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = shader._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = shader._attributes[i];
					var location = att.location;
					if(location != -1) {
						shader.gl.enableVertexAttribArray(location);
						shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!shader._ready) {
				shader.create();
			}
			shader.gl.useProgram(shader._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = shader._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = shader._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = shader._attributes[i];
					var location = att.location;
					if(location != -1) {
						shader.gl.enableVertexAttribArray(location);
						shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			shader._active = true;
		}
		target.activate();
		this.gl.drawArrays(4,0,3);
		shader.deactivate();
		var _this = this.velocityRenderTarget;
		_this.tmpFBO = _this.writeFrameBufferObject;
		_this.writeFrameBufferObject = _this.readFrameBufferObject;
		_this.readFrameBufferObject = _this.tmpFBO;
		_this.tmpTex = _this.writeToTexture;
		_this.writeToTexture = _this.readFromTexture;
		_this.readFromTexture = _this.tmpTex;
		this.gl.viewport(0,0,this.surfaceWidth,this.surfaceHeight);
		if(this.updateSurfaceShader != null) {
			var _this = this.updateSurfaceShader.dt;
			_this.dirty = true;
			_this.data = dt;
			var _this = this.updateSurfaceShader.surface;
			_this.dirty = true;
			_this.data = this.surfaceRenderTarget.readFromTexture.native;
			var shader = this.updateSurfaceShader;
			var target = this.surfaceRenderTarget;
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(shader._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = shader._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = shader._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = shader._attributes[i];
						var location = att.location;
						if(location != -1) {
							shader.gl.enableVertexAttribArray(location);
							shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!shader._ready) {
					shader.create();
				}
				shader.gl.useProgram(shader._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = shader._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = shader._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = shader._attributes[i];
						var location = att.location;
						if(location != -1) {
							shader.gl.enableVertexAttribArray(location);
							shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				shader._active = true;
			}
			target.activate();
			this.gl.drawArrays(4,0,3);
			shader.deactivate();
			var _this = this.surfaceRenderTarget;
			_this.tmpFBO = _this.writeFrameBufferObject;
			_this.writeFrameBufferObject = _this.readFrameBufferObject;
			_this.readFrameBufferObject = _this.tmpFBO;
			_this.tmpTex = _this.writeToTexture;
			_this.writeToTexture = _this.readFromTexture;
			_this.readFromTexture = _this.tmpTex;
		}
		var target = this.surfaceRenderTarget;
		var _this = this.advectShader.dt;
		_this.dirty = true;
		_this.data = dt;
		var _this = this.advectShader.target;
		_this.dirty = true;
		_this.data = target.readFromTexture.native;
		var _this = this.advectShader.velocity;
		_this.dirty = true;
		_this.data = this.velocityRenderTarget.readFromTexture.native;
		var shader = this.advectShader;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(shader._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = shader._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = shader._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = shader._attributes[i];
					var location = att.location;
					if(location != -1) {
						shader.gl.enableVertexAttribArray(location);
						shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!shader._ready) {
				shader.create();
			}
			shader.gl.useProgram(shader._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = shader._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = shader._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = shader._attributes[i];
					var location = att.location;
					if(location != -1) {
						shader.gl.enableVertexAttribArray(location);
						shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			shader._active = true;
		}
		target.gl.bindFramebuffer(36160,target.writeFrameBufferObject);
		this.gl.drawArrays(4,0,3);
		shader.deactivate();
		target.tmpFBO = target.writeFrameBufferObject;
		target.writeFrameBufferObject = target.readFrameBufferObject;
		target.readFrameBufferObject = target.tmpFBO;
		target.tmpTex = target.writeToTexture;
		target.writeToTexture = target.readFromTexture;
		target.readFromTexture = target.tmpTex;
	}
	,updateTextureSizes: function() {
		var newSurfaceWidth = this.powerOf2Surface ? math_POT.floorPowerOf2(this.width) : this.width;
		var newSurfaceHeight = this.powerOf2Surface ? math_POT.floorPowerOf2(this.height) : this.height;
		var newSimulationWidth = math_POT.floorPowerOf2(newSurfaceWidth * this.simulationScale);
		var newSimulationHeight = math_POT.floorPowerOf2(newSurfaceHeight * this.simulationScale);
		var surfaceSizeChanged = newSurfaceWidth != this.surfaceWidth || newSurfaceHeight != this.surfaceHeight;
		var simulationSizeChanged = newSimulationWidth != this.simulationWidth || newSimulationHeight != this.simulationHeight;
		this.surfaceWidth = newSurfaceWidth;
		this.surfaceHeight = newSurfaceHeight;
		this.simulationWidth = newSimulationWidth;
		this.simulationHeight = newSimulationHeight;
		if(surfaceSizeChanged && this.surfaceRenderTarget != null) {
			this.surfaceRenderTarget.resize(this.surfaceWidth,this.surfaceHeight);
		}
		if(simulationSizeChanged && this.velocityRenderTarget != null) {
			this.velocityRenderTarget.resize(this.simulationWidth,this.simulationHeight);
		}
		if(simulationSizeChanged && this.pressureRenderTarget != null) {
			this.pressureRenderTarget.resize(this.simulationWidth,this.simulationHeight);
		}
		if(simulationSizeChanged && this.divergenceRenderTarget != null) {
			var _this = this.divergenceRenderTarget;
			var width = this.simulationWidth;
			var height = this.simulationHeight;
			var newTexture = _this.createEmptyTexture(width,height);
			_this.gl.bindFramebuffer(36160,_this.frameBufferObject);
			_this.gl.framebufferTexture2D(36160,36064,3553,newTexture.native,0);
			if(_this.texture != null) {
				var resampler = SharedGPUResources.getResampleShader(_this.gl);
				var _this1 = resampler.texture;
				_this1.dirty = true;
				_this1.data = _this.texture.native;
				_this.gl.bindFramebuffer(36160,_this.frameBufferObject);
				_this.gl.viewport(0,0,width,height);
				_this.gl.bindBuffer(34962,SharedGPUResources.getScreenTriangle(_this.gl));
				var initUniforms = true;
				var initAttribs = true;
				if(initAttribs == null) {
					initAttribs = false;
				}
				if(initUniforms == null) {
					initUniforms = true;
				}
				if(resampler._active) {
					if(initUniforms) {
						var _g = 0;
						var _g1 = resampler._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = resampler._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = resampler._attributes[i];
							var location = att.location;
							if(location != -1) {
								resampler.gl.enableVertexAttribArray(location);
								resampler.gl.vertexAttribPointer(location,att.itemCount,att.type,false,resampler._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
				} else {
					if(!resampler._ready) {
						resampler.create();
					}
					resampler.gl.useProgram(resampler._prog);
					if(initUniforms) {
						var _g = 0;
						var _g1 = resampler._uniforms;
						while(_g < _g1.length) {
							var u = _g1[_g];
							++_g;
							if(u.dirty || u.alwaysDirty) {
								u.apply();
							}
						}
					}
					if(initAttribs) {
						var offset = 0;
						var _g = 0;
						var _g1 = resampler._attributes.length;
						while(_g < _g1) {
							var i = _g++;
							var att = resampler._attributes[i];
							var location = att.location;
							if(location != -1) {
								resampler.gl.enableVertexAttribArray(location);
								resampler.gl.vertexAttribPointer(location,att.itemCount,att.type,false,resampler._aStride,offset);
							}
							offset += att.byteSize;
						}
					}
					resampler._active = true;
				}
				_this.gl.drawArrays(4,0,3);
				resampler.deactivate();
				_this.gl.deleteTexture(_this.texture.native);
			} else {
				_this.gl.bindFramebuffer(36160,_this.frameBufferObject);
				_this.gl.viewport(0,0,_this.width,_this.height);
				_this.gl.clearColor(0,0,0,1);
				_this.gl.clear(16384);
			}
			_this.width = width;
			_this.height = height;
			_this.texture = newTexture;
		}
		this.updateBaseUniforms();
	}
	,forEachShader: function(callback) {
		callback(this.applyForcesShader);
		callback(this.updateSurfaceShader);
		callback(this.advectShader);
		callback(this.divergenceShader);
		callback(this.pressureSolveShader);
		callback(this.pressureGradientSubstractShader);
	}
	,setWrapMode: function(mode) {
		this.velocityRenderTarget.updateTextureParameters(new VariableTextureParams(null,null,mode,mode));
		this.pressureRenderTarget.updateTextureParameters(new VariableTextureParams(null,null,mode,mode));
		this.divergenceRenderTarget.updateTextureParameters(new VariableTextureParams(null,null,mode,mode));
		this.surfaceRenderTarget.updateTextureParameters(new VariableTextureParams(null,null,mode,mode));
	}
	,updateBaseUniforms: function() {
		var _gthis = this;
		this.forEachShader(function(shader) {
			var _this = shader.invAspectRatio;
			var data = 1 / _gthis.aspectRatio;
			_this.dirty = true;
			_this.data = data;
			shader.invResolution.data[0] = 1 / _gthis.simulationWidth;
			shader.invResolution.data[1] = 1 / _gthis.simulationHeight;
			shader.invResolution.dirty = true;
			var _this = shader.velocityBoundaryEnabled;
			var data = !_gthis.periodicBoundary;
			_this.dirty = true;
			_this.data = data;
		});
		var _this = this.advectShader.rdx;
		_this.dirty = true;
		_this.data = 1 / this.physicsScale;
		var _this = this.divergenceShader.halfrdx;
		_this.dirty = true;
		_this.data = 0.5 * (1 / this.physicsScale);
		var _this = this.pressureGradientSubstractShader.halfrdx;
		_this.dirty = true;
		_this.data = 0.5 * (1 / this.physicsScale);
		var _this = this.pressureSolveShader.alpha;
		_this.dirty = true;
		_this.data = -this.physicsScale * this.physicsScale;
		var _this = this.applyForcesShader.dx;
		_this.dirty = true;
		_this.data = this.physicsScale;
		var _this = this.updateSurfaceShader.dx;
		_this.dirty = true;
		_this.data = this.physicsScale;
	}
	,printParameters: function() {
		var s = Console.logPrefix + ("" + Std.string("<b>GPUFluid Parameters</>\n\t" + ["physicsScale: <b>" + this.physicsScale + "</b>","solverIterations: <b>" + this.solverIterations + "</b>","aspectRatio: <b>" + this.aspectRatio + "</b>","surface size: <b>" + this.surfaceWidth + "</b>x<b>" + this.surfaceHeight + "</b>","simulation size: <b>" + this.simulationWidth + "</b>x<b>" + this.simulationHeight + "</b>","<b>velocity</b>:\n\t\t" + this.formatTextureParameters(this.velocityRenderTarget.textureParameters).join("\n\t\t"),"<b>pressure</b>:\n\t\t" + this.formatTextureParameters(this.pressureRenderTarget.textureParameters).join("\n\t\t"),"<b>divergence</b>:\n\t\t" + this.formatTextureParameters(this.divergenceRenderTarget.textureParameters).join("\n\t\t"),"<b>surface</b>:\n\t\t" + this.formatTextureParameters(this.surfaceRenderTarget.textureParameters).join("\n\t\t")].join("\n\t")));
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
	}
	,formatTextureParameters: function(p) {
		if(p != null) {
			return ["dataType: <b>" + gluon_webgl_GLContextDebug.getConstantName(p.dataType) + "</b>","format: <b>" + gluon_webgl_GLContextDebug.getConstantName(p.format) + "</b>","internalFormat: <b>" + gluon_webgl_GLContextDebug.getConstantName(p.internalFormat) + "</b>","magFilter: <b>" + gluon_webgl_GLContextDebug.getConstantName(p.magFilter) + "</b>"];
		} else {
			return ["<red,i>renderTarget.textureParameters was null</>"];
		}
	}
	,__class__: GPUFluid
};
var Advect = function(gl) {
	FluidBase.call(this,gl);
};
Advect.__name__ = true;
Advect.__super__ = FluidBase;
Advect.prototype = $extend(FluidBase.prototype,{
	createProperties: function() {
		FluidBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"velocity",null,false);
		this.velocity = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"target",null,false);
		this.target = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"dt",null);
		this.dt = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"rdx",null);
		this.rdx = instance;
		this._uniforms.push(instance);
		this._aStride += 0;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\n \r\nattribute vec2 vertexPosition;\r\n\r\nuniform vec2 invResolution;\r\nuniform float invAspectRatio;\r\n\r\nvarying vec2 texelCoord;\r\n\r\n\n\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vB;\r\nvarying vec2 vT;\r\n\r\n\r\nvarying vec2 p;\r\n\r\nvoid main() {\r\n\ttexelCoord = vertexPosition;\r\n\t\r\n\tvL = texelCoord - vec2(invResolution.x,0);\r\n\tvR = texelCoord + vec2(invResolution.x,0);\r\n\tvB = texelCoord - vec2(0,invResolution.y);\r\n\tvT = texelCoord + vec2(0,invResolution.y);\r\n\t\r\n\tvec2 clipSpace = 2.0*texelCoord - 1.0;\t\n\t\r\n\tp = vec2(clipSpace.x / invAspectRatio, clipSpace.y);\r\n\r\n\tgl_Position = vec4(clipSpace, 0.0, 1.0 );\t\r\n}\r\n\n\n\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform float invAspectRatio;\nuniform bool velocityBoundaryEnabled;\n\nvec2 clipToSimSpace(vec2 clipSpace){\n    return vec2(clipSpace.x / invAspectRatio, clipSpace.y);\n}\n\nvec2 simToTexelSpace(vec2 simSpace){\n    return vec2(simSpace.x * invAspectRatio + 1.0 , simSpace.y + 1.0)*.5;\n}\n\n\n\n\n\n\n\n\n\n\n\n#define samplePressure(texture, coord) ( texture2D(pressure, coord).x )\n#define outOfBoundsVelocityMultiplier(coord) (velocityBoundaryEnabled ? (step(vec2(0.), coord) * step(coord, vec2(1.)) * 2. - 1. ) : vec2(1.0))\n\n#define sampleVelocity(texture, coord) ( outOfBoundsVelocityMultiplier(coord) * texture2D(velocity, coord).xy )\n\nuniform sampler2D velocity;\nuniform sampler2D target;\nuniform float dt;\nuniform float rdx; \n\nvarying vec2 texelCoord;\nvarying vec2 p;\n\nvoid main(void){\n  \n  vec2 tracedPos = p - dt * rdx * texture2D(velocity, texelCoord).xy;\n\n  gl_FragColor = texture2D(target, simToTexelSpace(tracedPos));\n}\n";
	}
	,__class__: Advect
});
var Divergence = function(gl) {
	FluidBase.call(this,gl);
};
Divergence.__name__ = true;
Divergence.__super__ = FluidBase;
Divergence.prototype = $extend(FluidBase.prototype,{
	createProperties: function() {
		FluidBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"velocity",null,false);
		this.velocity = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"halfrdx",null);
		this.halfrdx = instance;
		this._uniforms.push(instance);
		this._aStride += 0;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\n \r\nattribute vec2 vertexPosition;\r\n\r\nuniform vec2 invResolution;\r\nuniform float invAspectRatio;\r\n\r\nvarying vec2 texelCoord;\r\n\r\n\n\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vB;\r\nvarying vec2 vT;\r\n\r\n\r\nvarying vec2 p;\r\n\r\nvoid main() {\r\n\ttexelCoord = vertexPosition;\r\n\t\r\n\tvL = texelCoord - vec2(invResolution.x,0);\r\n\tvR = texelCoord + vec2(invResolution.x,0);\r\n\tvB = texelCoord - vec2(0,invResolution.y);\r\n\tvT = texelCoord + vec2(0,invResolution.y);\r\n\t\r\n\tvec2 clipSpace = 2.0*texelCoord - 1.0;\t\n\t\r\n\tp = vec2(clipSpace.x / invAspectRatio, clipSpace.y);\r\n\r\n\tgl_Position = vec4(clipSpace, 0.0, 1.0 );\t\r\n}\r\n\n\n\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform float invAspectRatio;\nuniform bool velocityBoundaryEnabled;\n\nvec2 clipToSimSpace(vec2 clipSpace){\n    return vec2(clipSpace.x / invAspectRatio, clipSpace.y);\n}\n\nvec2 simToTexelSpace(vec2 simSpace){\n    return vec2(simSpace.x * invAspectRatio + 1.0 , simSpace.y + 1.0)*.5;\n}\n\n\n\n\n\n\n\n\n\n\n\n#define samplePressure(texture, coord) ( texture2D(pressure, coord).x )\n#define outOfBoundsVelocityMultiplier(coord) (velocityBoundaryEnabled ? (step(vec2(0.), coord) * step(coord, vec2(1.)) * 2. - 1. ) : vec2(1.0))\n\n#define sampleVelocity(texture, coord) ( outOfBoundsVelocityMultiplier(coord) * texture2D(velocity, coord).xy )\n\nuniform sampler2D velocity;\t\nuniform float halfrdx;\t\n\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vB;\r\nvarying vec2 vT;\r\n\r\nvoid main(void){\r\n\t\n \t\n\tvec2 L = sampleVelocity(velocity, vL);\r\n\tvec2 R = sampleVelocity(velocity, vR);\r\n\tvec2 B = sampleVelocity(velocity, vB);\r\n\tvec2 T = sampleVelocity(velocity, vT);\r\n\r\n\tgl_FragColor = vec4( halfrdx * ((R.x - L.x) + (T.y - B.y)), 0, 0, 1);\r\n}\r\n\n";
	}
	,__class__: Divergence
});
var PressureSolve = function(gl) {
	FluidBase.call(this,gl);
};
PressureSolve.__name__ = true;
PressureSolve.__super__ = FluidBase;
PressureSolve.prototype = $extend(FluidBase.prototype,{
	createProperties: function() {
		FluidBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"pressure",null,false);
		this.pressure = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"divergence",null,false);
		this.divergence = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"alpha",null);
		this.alpha = instance;
		this._uniforms.push(instance);
		this._aStride += 0;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\n \r\nattribute vec2 vertexPosition;\r\n\r\nuniform vec2 invResolution;\r\nuniform float invAspectRatio;\r\n\r\nvarying vec2 texelCoord;\r\n\r\n\n\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vB;\r\nvarying vec2 vT;\r\n\r\n\r\nvarying vec2 p;\r\n\r\nvoid main() {\r\n\ttexelCoord = vertexPosition;\r\n\t\r\n\tvL = texelCoord - vec2(invResolution.x,0);\r\n\tvR = texelCoord + vec2(invResolution.x,0);\r\n\tvB = texelCoord - vec2(0,invResolution.y);\r\n\tvT = texelCoord + vec2(0,invResolution.y);\r\n\t\r\n\tvec2 clipSpace = 2.0*texelCoord - 1.0;\t\n\t\r\n\tp = vec2(clipSpace.x / invAspectRatio, clipSpace.y);\r\n\r\n\tgl_Position = vec4(clipSpace, 0.0, 1.0 );\t\r\n}\r\n\n\n\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform float invAspectRatio;\nuniform bool velocityBoundaryEnabled;\n\nvec2 clipToSimSpace(vec2 clipSpace){\n    return vec2(clipSpace.x / invAspectRatio, clipSpace.y);\n}\n\nvec2 simToTexelSpace(vec2 simSpace){\n    return vec2(simSpace.x * invAspectRatio + 1.0 , simSpace.y + 1.0)*.5;\n}\n\n\n\n\n\n\n\n\n\n\n\n#define samplePressure(texture, coord) ( texture2D(pressure, coord).x )\n#define outOfBoundsVelocityMultiplier(coord) (velocityBoundaryEnabled ? (step(vec2(0.), coord) * step(coord, vec2(1.)) * 2. - 1. ) : vec2(1.0))\n\n#define sampleVelocity(texture, coord) ( outOfBoundsVelocityMultiplier(coord) * texture2D(velocity, coord).xy )\n\nuniform sampler2D pressure;\nuniform sampler2D divergence;\nuniform float alpha;\n\nvarying vec2 texelCoord;\n\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vB;\nvarying vec2 vT;\n\nvoid main(void){\n  \n  \n  float L = samplePressure(pressure, vL);\n  float R = samplePressure(pressure, vR);\n  float B = samplePressure(pressure, vB);\n  float T = samplePressure(pressure, vT);\n\n  float bC = texture2D(divergence, texelCoord).x;\n\n  gl_FragColor = vec4( (L + R + B + T + alpha * bC) * .25, 0, 0, 1 ); \n}\n";
	}
	,__class__: PressureSolve
});
var PressureGradientSubstract = function(gl) {
	FluidBase.call(this,gl);
};
PressureGradientSubstract.__name__ = true;
PressureGradientSubstract.__super__ = FluidBase;
PressureGradientSubstract.prototype = $extend(FluidBase.prototype,{
	createProperties: function() {
		FluidBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"pressure",null,false);
		this.pressure = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"velocity",null,false);
		this.velocity = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"halfrdx",null);
		this.halfrdx = instance;
		this._uniforms.push(instance);
		this._aStride += 0;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\n \r\nattribute vec2 vertexPosition;\r\n\r\nuniform vec2 invResolution;\r\nuniform float invAspectRatio;\r\n\r\nvarying vec2 texelCoord;\r\n\r\n\n\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vB;\r\nvarying vec2 vT;\r\n\r\n\r\nvarying vec2 p;\r\n\r\nvoid main() {\r\n\ttexelCoord = vertexPosition;\r\n\t\r\n\tvL = texelCoord - vec2(invResolution.x,0);\r\n\tvR = texelCoord + vec2(invResolution.x,0);\r\n\tvB = texelCoord - vec2(0,invResolution.y);\r\n\tvT = texelCoord + vec2(0,invResolution.y);\r\n\t\r\n\tvec2 clipSpace = 2.0*texelCoord - 1.0;\t\n\t\r\n\tp = vec2(clipSpace.x / invAspectRatio, clipSpace.y);\r\n\r\n\tgl_Position = vec4(clipSpace, 0.0, 1.0 );\t\r\n}\r\n\n\n\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform float invAspectRatio;\nuniform bool velocityBoundaryEnabled;\n\nvec2 clipToSimSpace(vec2 clipSpace){\n    return vec2(clipSpace.x / invAspectRatio, clipSpace.y);\n}\n\nvec2 simToTexelSpace(vec2 simSpace){\n    return vec2(simSpace.x * invAspectRatio + 1.0 , simSpace.y + 1.0)*.5;\n}\n\n\n\n\n\n\n\n\n\n\n\n#define samplePressure(texture, coord) ( texture2D(pressure, coord).x )\n#define outOfBoundsVelocityMultiplier(coord) (velocityBoundaryEnabled ? (step(vec2(0.), coord) * step(coord, vec2(1.)) * 2. - 1. ) : vec2(1.0))\n\n#define sampleVelocity(texture, coord) ( outOfBoundsVelocityMultiplier(coord) * texture2D(velocity, coord).xy )\n\nuniform sampler2D pressure;\r\nuniform sampler2D velocity;\r\nuniform float halfrdx;\r\n\r\nvarying vec2 texelCoord;\r\n\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vB;\r\nvarying vec2 vT;\r\n\r\nvoid main(void){\r\n  float L = samplePressure(pressure, vL);\r\n  float R = samplePressure(pressure, vR);\r\n  float B = samplePressure(pressure, vB);\r\n  float T = samplePressure(pressure, vT);\r\n\r\n  vec2 v = texture2D(velocity, texelCoord).xy;\r\n\r\n  gl_FragColor = vec4(v - halfrdx*vec2(R-L, T-B), 0, 1);\r\n}\r\n\r\n\n";
	}
	,__class__: PressureGradientSubstract
});
var GPUOpticalFlow = function(gl) {
	this.averageVelocity = new filter_Swappable();
	this.gamma = 2.1;
	this.blurKernel = 64;
	this.mirrorY = false;
	this.mirrorX = true;
	this.temporalSmoothing = 4;
	this.scale = 1;
	this.gl = gl;
	this.screenTriangle = SharedGPUResources.getScreenTriangle(gl);
	this.prepareFrame = new PrepareFrame(gl);
	this.currentFrame = new Frame(gl);
	this.lastFrame = new Frame(gl);
	this.opticalFlowShader = SharedGPUResources.getShaderWithKey(gl,"opticalFlow",function(_,_1) {
		return new OpticalFlowGrayShader(gl);
	});
	var rHalfFloat = GPUCapabilities.get(gl).getWritableFloatColorBufferParameters(6403,5131,9729);
	this.frameParams = new TextureParams(rHalfFloat.format,rHalfFloat.internalFormat,rHalfFloat.dataType,rHalfFloat.filtering,rHalfFloat.filtering,33071,33071);
	var rgHalfFloat = GPUCapabilities.get(gl).getWritableFloatColorBufferParameters(33319,5131,9729);
	this.velocityParams = new TextureParams(rgHalfFloat.format,rgHalfFloat.internalFormat,rgHalfFloat.dataType,rgHalfFloat.filtering,rgHalfFloat.filtering,33071,33071);
	var t = this.averageVelocity.get(gl,1,1,this.velocityParams);
	var mask = 16384;
	if(mask == null) {
		mask = 16384;
	}
	t.gl.bindFramebuffer(36160,t.readFrameBufferObject);
	t.gl.viewport(0,0,t.width,t.height);
	t.gl.clearColor(0,0,0,1);
	t.gl.clear(mask);
	var mask = 16384;
	if(mask == null) {
		mask = 16384;
	}
	t.gl.bindFramebuffer(36160,t.writeFrameBufferObject);
	t.gl.viewport(0,0,t.width,t.height);
	t.gl.clearColor(0,0,0,1);
	t.gl.clear(mask);
};
GPUOpticalFlow.__name__ = true;
GPUOpticalFlow.prototype = {
	frame: function(input) {
		var tmp = this.currentFrame;
		var _this = this.prepareFrame;
		var mirrorX = this.mirrorX;
		var mirrorY = this.mirrorY;
		var gamma = this.gamma;
		var textureParams = this.frameParams;
		if(textureParams == null) {
			textureParams = input;
		}
		var outputTarget = _this.outputIntermediate.get(_this.gl,input.width,input.height,textureParams);
		outputTarget.gl.bindFramebuffer(36160,outputTarget.frameBufferObject);
		_this.gl.viewport(0,0,outputTarget.width,outputTarget.height);
		_this.gl.bindBuffer(34962,_this.screenTriangle);
		var _this1 = _this.shader.texture;
		_this1.dirty = true;
		_this1.data = input.native;
		var _this1 = _this.shader.gamma;
		_this1.dirty = true;
		_this1.data = gamma;
		var mx = mirrorX ? 1.0 : 0.0;
		var my = mirrorY ? 1.0 : 0.0;
		if(_this.shader.mirror.data[0] != mx || _this.shader.mirror.data[1] != my) {
			var this1 = _this.shader.mirror.data;
			this1[0] = mx;
			this1[1] = my;
			_this.shader.mirror.dirty = true;
		}
		var _this1 = _this.shader;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(_this1._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this1._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this1._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this1._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this1.gl.enableVertexAttribArray(location);
						_this1.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this1._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!_this1._ready) {
				_this1.create();
			}
			_this1.gl.useProgram(_this1._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this1._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this1._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this1._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this1.gl.enableVertexAttribArray(location);
						_this1.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this1._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			_this1._active = true;
		}
		_this.gl.drawArrays(4,0,3);
		_this.shader.deactivate();
		tmp.update(outputTarget.texture,this.blurKernel,HxOverrides.now() / 1000);
		var velocityTarget = this.averageVelocity.get(this.gl,this.currentFrame.processedImage.width,this.currentFrame.processedImage.height,this.velocityParams);
		if(this.lastFrame.initialized) {
			var dt_s = this.currentFrame.timestamp - this.lastFrame.timestamp;
			velocityTarget.gl.bindFramebuffer(36160,velocityTarget.writeFrameBufferObject);
			this.gl.viewport(0,0,velocityTarget.width,velocityTarget.height);
			this.gl.bindBuffer(34962,this.screenTriangle);
			var _this = this.opticalFlowShader.currFrame;
			_this.dirty = true;
			_this.data = this.currentFrame.processedImage.native;
			var _this = this.opticalFlowShader.currSobelH;
			_this.dirty = true;
			_this.data = this.currentFrame.sobelH.native;
			var _this = this.opticalFlowShader.currSobelV;
			_this.dirty = true;
			_this.data = this.currentFrame.sobelV.native;
			var _this = this.opticalFlowShader.lastFrame;
			_this.dirty = true;
			_this.data = this.lastFrame.processedImage.native;
			var _this = this.opticalFlowShader.lastSobelH;
			_this.dirty = true;
			_this.data = this.lastFrame.sobelH.native;
			var _this = this.opticalFlowShader.lastSobelV;
			_this.dirty = true;
			_this.data = this.lastFrame.sobelV.native;
			var _this = this.opticalFlowShader.averageVeloicty;
			_this.dirty = true;
			_this.data = velocityTarget.readFromTexture.native;
			var _this = this.opticalFlowShader.scale;
			_this.dirty = true;
			_this.data = this.scale / dt_s;
			var _this = this.opticalFlowShader.temporalSmoothingAlpha;
			_this.dirty = true;
			_this.data = 2 / (this.temporalSmoothing + 1);
			var _this = this.opticalFlowShader;
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(_this._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!_this._ready) {
					_this.create();
				}
				_this.gl.useProgram(_this._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = _this._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = _this._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = _this._attributes[i];
						var location = att.location;
						if(location != -1) {
							_this.gl.enableVertexAttribArray(location);
							_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				_this._active = true;
			}
			this.gl.drawArrays(4,0,3);
			this.opticalFlowShader.deactivate();
			velocityTarget.tmpFBO = velocityTarget.writeFrameBufferObject;
			velocityTarget.writeFrameBufferObject = velocityTarget.readFrameBufferObject;
			velocityTarget.readFrameBufferObject = velocityTarget.tmpFBO;
			velocityTarget.tmpTex = velocityTarget.writeToTexture;
			velocityTarget.writeToTexture = velocityTarget.readFromTexture;
			velocityTarget.readFromTexture = velocityTarget.tmpTex;
		}
		var tmp = this.lastFrame;
		this.lastFrame = this.currentFrame;
		this.currentFrame = tmp;
	}
	,releaseGPUMemory: function() {
		this.currentFrame.releaseGPUMemory();
		this.lastFrame.releaseGPUMemory();
		this.averageVelocity.destroy();
	}
	,__class__: GPUOpticalFlow
};
var Frame = function(gl) {
	this.downsampleCount = 2;
	this.blur = null;
	this.gl = gl;
	this.downsample = new filter_DownsampleHalfChain(gl,this.downsampleCount);
	this.sobelHFilter = new filter_SobelH(gl);
	this.sobelVFilter = new filter_SobelV(gl);
};
Frame.__name__ = true;
Frame.prototype = {
	update: function(image,blurKernel,timestamp) {
		this.timestamp = timestamp;
		var downsampleEffectiveKernel = 1 << this.downsampleCount;
		var gaussKernel = blurKernel / downsampleEffectiveKernel;
		if(this.blur != null && this.blur.kernelX != gaussKernel) {
			this.blur.releaseGPUMemory();
			this.blur = null;
		}
		if(this.blur == null && gaussKernel > 1) {
			this.blur = new filter_Blur(this.gl,gaussKernel,gaussKernel);
		}
		var downsampled = this.downsample.apply(image);
		this.processedImage = this.blur != null ? this.blur.apply(downsampled) : downsampled;
		var _this = this.sobelHFilter;
		var input = this.processedImage;
		var textureParams = null;
		if(textureParams == null) {
			textureParams = input;
		}
		var outputTargetH = _this.outputIntermediate.get(_this.gl,input.width,input.height,textureParams);
		outputTargetH.gl.bindFramebuffer(36160,outputTargetH.frameBufferObject);
		_this.gl.viewport(0,0,outputTargetH.width,outputTargetH.height);
		_this.gl.bindBuffer(34962,_this.screenTriangle);
		var _this1 = _this.sobelShaderH.texture;
		_this1.dirty = true;
		_this1.data = input.native;
		var this1 = _this.sobelShaderH.invResolution.data;
		this1[0] = 1 / input.width;
		this1[1] = 1 / input.height;
		_this.sobelShaderH.invResolution.dirty = true;
		var _this1 = _this.sobelShaderH;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(_this1._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this1._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this1._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this1._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this1.gl.enableVertexAttribArray(location);
						_this1.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this1._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!_this1._ready) {
				_this1.create();
			}
			_this1.gl.useProgram(_this1._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this1._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this1._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this1._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this1.gl.enableVertexAttribArray(location);
						_this1.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this1._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			_this1._active = true;
		}
		_this.gl.drawArrays(4,0,3);
		_this.sobelShaderH.deactivate();
		this.sobelH = outputTargetH.texture;
		var _this = this.sobelVFilter;
		var input = this.processedImage;
		var textureParams = null;
		if(textureParams == null) {
			textureParams = input;
		}
		var outputTargetV = _this.outputIntermediate.get(_this.gl,input.width,input.height,textureParams);
		outputTargetV.gl.bindFramebuffer(36160,outputTargetV.frameBufferObject);
		_this.gl.viewport(0,0,outputTargetV.width,outputTargetV.height);
		_this.gl.bindBuffer(34962,_this.screenTriangle);
		var _this1 = _this.sobelShaderV.texture;
		_this1.dirty = true;
		_this1.data = input.native;
		var this1 = _this.sobelShaderV.invResolution.data;
		this1[0] = 1 / input.width;
		this1[1] = 1 / input.height;
		_this.sobelShaderV.invResolution.dirty = true;
		var _this1 = _this.sobelShaderV;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(_this1._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this1._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this1._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this1._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this1.gl.enableVertexAttribArray(location);
						_this1.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this1._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!_this1._ready) {
				_this1.create();
			}
			_this1.gl.useProgram(_this1._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this1._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this1._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this1._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this1.gl.enableVertexAttribArray(location);
						_this1.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this1._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			_this1._active = true;
		}
		_this.gl.drawArrays(4,0,3);
		_this.sobelShaderV.deactivate();
		this.sobelV = outputTargetV.texture;
		this.initialized = true;
	}
	,releaseGPUMemory: function() {
		this.sobelHFilter.releaseGPUMemory();
		this.sobelVFilter.releaseGPUMemory();
		this.downsample.releaseGPUMemory();
		if(this.blur != null) {
			this.blur.releaseGPUMemory();
		}
	}
	,__class__: Frame
};
var OpticalFlowGrayShader = function(gl) {
	shaderblox_ShaderBase.call(this,gl);
};
OpticalFlowGrayShader.__name__ = true;
OpticalFlowGrayShader.__super__ = shaderblox_ShaderBase;
OpticalFlowGrayShader.prototype = $extend(shaderblox_ShaderBase.prototype,{
	createProperties: function() {
		shaderblox_ShaderBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"currFrame",null,false);
		this.currFrame = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"currSobelH",null,false);
		this.currSobelH = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"currSobelV",null,false);
		this.currSobelV = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"lastFrame",null,false);
		this.lastFrame = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"lastSobelH",null,false);
		this.lastSobelH = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"lastSobelV",null,false);
		this.lastSobelV = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"averageVeloicty",null,false);
		this.averageVeloicty = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"scale",null);
		this.scale = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"temporalSmoothingAlpha",null);
		this.temporalSmoothingAlpha = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_attributes_FloatAttribute("vertexPosition",0,2);
		this.vertexPosition = instance;
		this._attributes.push(instance);
		this._aStride += 8;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nattribute vec2 vertexPosition;\nvarying vec2 texelCoord;\n\nvoid main() {\n\ttexelCoord = vertexPosition;\n\tgl_Position = vec4(vertexPosition*2.0 - vec2(1.0, 1.0), 0.0, 1.0 );\n}\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform sampler2D currFrame;  \n    uniform sampler2D currSobelH; \n    uniform sampler2D currSobelV; \n    uniform sampler2D lastFrame;  \n    uniform sampler2D lastSobelH; \n    uniform sampler2D lastSobelV; \n    uniform sampler2D averageVeloicty; \n    uniform float scale;\n    uniform float temporalSmoothingAlpha;\n    varying vec2 texelCoord;\n    void main() {\n        vec2 currentAverageVelocity = texture2D(averageVeloicty, texelCoord).xy;\n        \n        float i1 = texture2D(currFrame, texelCoord).r;\n        float i0 = texture2D(lastFrame, texelCoord).r;\n        float dI = i1 - i0;\n        float dx = texture2D(currSobelH, texelCoord).r + texture2D(lastSobelH, texelCoord).r;\n        float dy = texture2D(currSobelV, texelCoord).r + texture2D(lastSobelV, texelCoord).r;\n        float dd = sqrt(dx*dx + dy*dy + 1.0);\n        vec2 flow = -scale * dI * vec2(dx, dy) / dd;\n        \n        \n        \n        vec2 updatedAverageVelocity = temporalSmoothingAlpha * flow + (1.0 - temporalSmoothingAlpha) * currentAverageVelocity;\n        gl_FragColor = vec4(updatedAverageVelocity, 0., 1.);\n    }\n";
	}
	,__class__: OpticalFlowGrayShader
});
var PrepareFrame = function(gl) {
	this.outputIntermediate = new filter_IntermediateRenderTarget();
	this.gl = gl;
	this.screenTriangle = SharedGPUResources.getScreenTriangle(gl);
	this.shader = SharedGPUResources.getShaderWithKey(gl,"prepareFrame",function(_,_1) {
		return new PrepareFrameShader(gl);
	});
};
PrepareFrame.__name__ = true;
PrepareFrame.prototype = {
	__class__: PrepareFrame
};
var PrepareFrameShader = function(gl) {
	shaderblox_ShaderBase.call(this,gl);
};
PrepareFrameShader.__name__ = true;
PrepareFrameShader.__super__ = shaderblox_ShaderBase;
PrepareFrameShader.prototype = $extend(shaderblox_ShaderBase.prototype,{
	createProperties: function() {
		shaderblox_ShaderBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UVec2(this.gl,"mirror",null);
		this.mirror = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"texture",null,false);
		this.texture = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"gamma",null);
		this.gamma = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_attributes_FloatAttribute("vertexPosition",0,2);
		this.vertexPosition = instance;
		this._attributes.push(instance);
		this._aStride += 8;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nattribute vec2 vertexPosition;\n    varying vec2 texelCoord;\n    uniform vec2 mirror;\n    void main() {\n        \n        texelCoord = mix(vertexPosition, 1.0 - vertexPosition, mirror);\n        \n        gl_Position = vec4(vertexPosition * 2.0 - 1.0, 0.0, 1.0);\n    }\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform sampler2D texture;\n    uniform float gamma;\n    varying vec2 texelCoord;\n    float luminance(vec3 rgb) {\n        \n        const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n        return dot(rgb, W);\n    }\n    void main() {\n        vec3 sample = texture2D(texture, texelCoord).rgb;\n        vec3 linear = pow(sample, vec3(gamma));\n        float lum = luminance(linear);\n        gl_FragColor = vec4(vec3(lum), 1.);\n    }\n";
	}
	,__class__: PrepareFrameShader
});
var GPUParticles = function(gl,count) {
	if(count == null) {
		count = 524288;
	}
	this.gl = gl;
	gl.getExtension("OES_texture_float");
	this.screenTriangle = SharedGPUResources.getScreenTriangle(gl);
	this.inititalConditionsShader = new InitialConditions(gl);
	this.stepParticlesShader = new StepParticles(gl);
	var _this = this.stepParticlesShader.dragCoefficient;
	_this.dirty = true;
	_this.data = 1;
	this.stepParticlesShader.flowScale.data[0] = 1;
	this.stepParticlesShader.flowScale.data[1] = 1;
	this.setCount(count);
	var shader = this.inititalConditionsShader;
	var target = this.particleData;
	this.gl.viewport(0,0,target.width,target.height);
	this.gl.bindFramebuffer(36160,target.writeFrameBufferObject);
	this.gl.bindBuffer(34962,this.screenTriangle);
	var initUniforms = true;
	var initAttribs = true;
	if(initAttribs == null) {
		initAttribs = false;
	}
	if(initUniforms == null) {
		initUniforms = true;
	}
	if(shader._active) {
		if(initUniforms) {
			var _g = 0;
			var _g1 = shader._uniforms;
			while(_g < _g1.length) {
				var u = _g1[_g];
				++_g;
				if(u.dirty || u.alwaysDirty) {
					u.apply();
				}
			}
		}
		if(initAttribs) {
			var offset = 0;
			var _g = 0;
			var _g1 = shader._attributes.length;
			while(_g < _g1) {
				var i = _g++;
				var att = shader._attributes[i];
				var location = att.location;
				if(location != -1) {
					shader.gl.enableVertexAttribArray(location);
					shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
				}
				offset += att.byteSize;
			}
		}
	} else {
		if(!shader._ready) {
			shader.create();
		}
		shader.gl.useProgram(shader._prog);
		if(initUniforms) {
			var _g = 0;
			var _g1 = shader._uniforms;
			while(_g < _g1.length) {
				var u = _g1[_g];
				++_g;
				if(u.dirty || u.alwaysDirty) {
					u.apply();
				}
			}
		}
		if(initAttribs) {
			var offset = 0;
			var _g = 0;
			var _g1 = shader._attributes.length;
			while(_g < _g1) {
				var i = _g++;
				var att = shader._attributes[i];
				var location = att.location;
				if(location != -1) {
					shader.gl.enableVertexAttribArray(location);
					shader.gl.vertexAttribPointer(location,att.itemCount,att.type,false,shader._aStride,offset);
				}
				offset += att.byteSize;
			}
		}
		shader._active = true;
	}
	this.gl.drawArrays(4,0,3);
	shader.deactivate();
	target.tmpFBO = target.writeFrameBufferObject;
	target.writeFrameBufferObject = target.readFrameBufferObject;
	target.readFrameBufferObject = target.tmpFBO;
	target.tmpTex = target.writeToTexture;
	target.writeToTexture = target.readFromTexture;
	target.readFromTexture = target.tmpTex;
	this.printParameters();
};
GPUParticles.__name__ = true;
GPUParticles.prototype = {
	releaseGPUMemory: function() {
		if(this.particleData != null) {
			var _this = this.particleData;
			_this.gl.deleteFramebuffer(_this.writeFrameBufferObject);
			_this.gl.deleteFramebuffer(_this.readFrameBufferObject);
			_this.gl.deleteTexture(_this.writeToTexture.native);
			_this.gl.deleteTexture(_this.readFromTexture.native);
		}
		if(this.particleUVs != null) {
			this.gl.deleteBuffer(this.particleUVs);
		}
		if(this.inititalConditionsShader != null) {
			this.inititalConditionsShader.destroy();
		}
		if(this.stepParticlesShader != null) {
			this.stepParticlesShader.destroy();
		}
	}
	,setCount: function(newCount) {
		var dataWidth = Math.ceil(Math.sqrt(newCount));
		var dataHeight = dataWidth;
		var params = GPUCapabilities.get(this.gl).getWritableFloatColorBufferParameters(6408,5131,9728);
		if(params == null) {
			throw haxe_Exception.thrown("Particles require renderable floating point textures");
		}
		if(this.particleData != null) {
			this.particleData.resize(dataWidth,dataHeight);
		} else {
			this.particleData = new render_RenderTargetSwappable(this.gl,dataWidth,dataHeight,new TextureParams(params.format,params.internalFormat,params.dataType,9728,9728,33071,33071));
		}
		if(this.particleUVs != null) {
			this.gl.deleteBuffer(this.particleUVs);
		}
		this.particleUVs = this.gl.createBuffer();
		var arrayUVs = [];
		var _g = 0;
		var _g1 = dataWidth;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = 0;
			var _g3 = dataHeight;
			while(_g2 < _g3) {
				var j = _g2++;
				arrayUVs.push(i / dataWidth);
				arrayUVs.push(j / dataHeight);
			}
		}
		this.gl.bindBuffer(34962,this.particleUVs);
		this.gl.bufferData(34962,new Float32Array(arrayUVs),35044);
		this.gl.bindBuffer(34962,null);
		return this.count = newCount;
	}
	,printParameters: function() {
		var s = Console.logPrefix + ("" + Std.string("<b>GPUParticles Parameters</>\n\t" + ["dragCoefficient: <b>" + this.stepParticlesShader.dragCoefficient.data + "</b>","flowScaleX: <b>" + this.stepParticlesShader.flowScale.data[0] + "</b>","flowScaleY: <b>" + this.stepParticlesShader.flowScale.data[1] + "</b>","texture size: <b>" + this.particleData.width + "x" + this.particleData.height + "</b>"].join("\n\t")));
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
	}
	,__class__: GPUParticles
};
var PlaneTexture = function(gl) {
	shaderblox_ShaderBase.call(this,gl);
};
PlaneTexture.__name__ = true;
PlaneTexture.__super__ = shaderblox_ShaderBase;
PlaneTexture.prototype = $extend(shaderblox_ShaderBase.prototype,{
	createProperties: function() {
		shaderblox_ShaderBase.prototype.createProperties.call(this);
		var instance = new shaderblox_attributes_FloatAttribute("vertexPosition",0,2);
		this.vertexPosition = instance;
		this._attributes.push(instance);
		this._aStride += 8;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nattribute vec2 vertexPosition;\n\tvarying vec2 texelCoord;\n\tvoid main() {\n\t\ttexelCoord = vertexPosition;\n\t\tgl_Position = vec4(vertexPosition*2.0 - vec2(1.0, 1.0), 0.0, 1.0 );\n\t}\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nvarying vec2 texelCoord;\n";
	}
	,__class__: PlaneTexture
});
var InitialConditions = function(gl) {
	PlaneTexture.call(this,gl);
};
InitialConditions.__name__ = true;
InitialConditions.__super__ = PlaneTexture;
InitialConditions.prototype = $extend(PlaneTexture.prototype,{
	createProperties: function() {
		PlaneTexture.prototype.createProperties.call(this);
		this._aStride += 0;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nattribute vec2 vertexPosition;\n\tvarying vec2 texelCoord;\n\tvoid main() {\n\t\ttexelCoord = vertexPosition;\n\t\tgl_Position = vec4(vertexPosition*2.0 - vec2(1.0, 1.0), 0.0, 1.0 );\n\t}\n\n\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nvarying vec2 texelCoord;\n\nvoid main() {\n\t\tvec2 ip = vec2((texelCoord.x), (texelCoord.y)) * 2.0 - 1.0;\n\t\tvec2 iv = vec2(0,0);\n\t\tgl_FragColor = vec4(ip, iv);\n\t}\n";
	}
	,__class__: InitialConditions
});
var ParticleBase = function(gl) {
	PlaneTexture.call(this,gl);
};
ParticleBase.__name__ = true;
ParticleBase.__super__ = PlaneTexture;
ParticleBase.prototype = $extend(PlaneTexture.prototype,{
	createProperties: function() {
		PlaneTexture.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"dt",null);
		this.dt = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"particleData",null,false);
		this.particleData = instance;
		this._uniforms.push(instance);
		this._aStride += 0;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nattribute vec2 vertexPosition;\n\tvarying vec2 texelCoord;\n\tvoid main() {\n\t\ttexelCoord = vertexPosition;\n\t\tgl_Position = vec4(vertexPosition*2.0 - vec2(1.0, 1.0), 0.0, 1.0 );\n\t}\n\n\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nvarying vec2 texelCoord;\n\nuniform float dt;\n\tuniform sampler2D particleData;\n";
	}
	,__class__: ParticleBase
});
var StepParticles = function(gl) {
	ParticleBase.call(this,gl);
};
StepParticles.__name__ = true;
StepParticles.__super__ = ParticleBase;
StepParticles.prototype = $extend(ParticleBase.prototype,{
	createProperties: function() {
		ParticleBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UFloat(this.gl,"dragCoefficient",null);
		this.dragCoefficient = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UVec2(this.gl,"flowScale",null);
		this.flowScale = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"flowVelocityField",null,false);
		this.flowVelocityField = instance;
		this._uniforms.push(instance);
		this._aStride += 0;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nattribute vec2 vertexPosition;\n\tvarying vec2 texelCoord;\n\tvoid main() {\n\t\ttexelCoord = vertexPosition;\n\t\tgl_Position = vec4(vertexPosition*2.0 - vec2(1.0, 1.0), 0.0, 1.0 );\n\t}\n\n\n\n\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nvarying vec2 texelCoord;\n\nuniform float dt;\n\tuniform sampler2D particleData;\n\nuniform float dragCoefficient;\n\tuniform vec2 flowScale;\n\tuniform sampler2D flowVelocityField;\n\tvoid main() {\n\t\tvec2 p = texture2D(particleData, texelCoord).xy;\n\t\tvec2 v = texture2D(particleData, texelCoord).zw;\n\t\tvec2 vf = texture2D(flowVelocityField, (p+1.)*.5).xy * flowScale;\n\t\tv += (vf - v) * dragCoefficient;\n\t\tp+=dt*v;\n\t\tgl_FragColor = vec4(p, v);\n\t}\n";
	}
	,__class__: StepParticles
});
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.fold = function(it,f,first) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		first = f(x1,first);
	}
	return first;
};
Lambda.find = function(it,f) {
	var v = $getIterator(it);
	while(v.hasNext()) {
		var v1 = v.next();
		if(f(v1)) {
			return v1;
		}
	}
	return null;
};
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
var Settings = function() {
	this.powerOf2Fluid = true;
	this.simulationScale = 0.125;
	this.fluidScale = 1.0;
	this.fluidIterations = 40;
	this.opticalFlowGamma = 1.0;
	this.opticalFlowBlurKernel = 48;
	this.opticalFlowExponent = 1.4;
	this.opticalFlowScale = 2.5;
	this.opticalFlowTemporalSmoothing = 14;
	this.opticalFlowMirrorX = true;
	this.vignetteExponent = 0.27;
	this.vignetteMagnitude = 258;
	this.vignetteOpacity = 0.0;
	this.gamma = 2.1;
	this.dyeGradient = { "angle" : 90.0, "stops" : [{ "color" : [0.,0.,0.,1.], "p" : 0.00},{ "color" : [0.,0.,0.,1.], "p" : 0.25},{ "color" : [0.,0.,0.,1.], "p" : 0.50},{ "color" : [0.,0.,0.,1.], "p" : 0.75},{ "color" : [0.,0.,0.,1.], "p" : 1.00}]};
	this.velocityGradient = { "angle" : 90., "stops" : [{ "color" : [0.,0.,0.,1.], "p" : 0},{ "color" : [0.,0.,0.,1.], "p" : 0.25},{ "color" : [0.,0.,0.,1.], "p" : 0.5},{ "color" : [0.,0.,0.,1.], "p" : 0.75},{ "color" : [0.08999999999999997,0.021234374999999996,0.04599,1], "p" : 1}]};
	this.alphaGradient = { "angle" : 90., "stops" : [{ "color" : [0.12156862745098039,0,0.2196078431372549,1], "p" : 0},{ "color" : [0.43137254901960786,0.1607843137254902,0.7803921568627451,1], "p" : 0.25},{ "color" : [0,0.8431372549019608,0.9607843137254902,1], "p" : 0.5},{ "color" : [0.2549019607843137,0.9882352941176471,0.6352941176470588,1], "p" : 0.75},{ "color" : [0.9176470588235294,1,0.9803921568627451,1], "p" : 1}]};
	this.backgroundPalette = { "angle" : 90.0, "stops" : [{ "color" : [0.46468338451452085,0.09939764953547675,0.6248872090623581,1], "p" : 0},{ "color" : [1,0.15376990711712357,0.9096201096033503,1], "p" : 0.210099995136261},{ "color" : [0.15376990711712357,0.9280667188629871,1,1], "p" : 0.6428999900817871},{ "color" : [0.6729639661804218,0.9887256339845741,0.9981306646709802,1], "p" : 0.9327999949455261},{ "color" : [0.6729639661804218,0.9887256339845741,0.9981306646709802,1], "p" : 1}]};
	this.backgroundMultiplier = 0;
	this.periodicBoundary = true;
	this.dragSpeed = 2;
	this.dragCoefficient = 1.0;
	this.motionDecayFactor = 0.1;
	this.surfaceDecayFactor = 0.7;
	this.timestepMultiplier = 1;
	this.fluidPhysicsScale = 20;
	this.paused = false;
	this.version = 1;
};
Settings.__name__ = true;
Settings.prototype = {
	setChangeCallbacks: function(callbacks) {
		this.onChangeVersion = callbacks.onChangeVersion;
		this.onChangePaused = callbacks.onChangePaused;
		this.onChangeFluidPhysicsScale = callbacks.onChangeFluidPhysicsScale;
		this.onChangeTimestepMultiplier = callbacks.onChangeTimestepMultiplier;
		this.onChangeSurfaceDecayFactor = callbacks.onChangeSurfaceDecayFactor;
		this.onChangeMotionDecayFactor = callbacks.onChangeMotionDecayFactor;
		this.onChangeDragCoefficient = callbacks.onChangeDragCoefficient;
		this.onChangeDragSpeed = callbacks.onChangeDragSpeed;
		this.onChangePeriodicBoundary = callbacks.onChangePeriodicBoundary;
		this.onChangeBackgroundMultiplier = callbacks.onChangeBackgroundMultiplier;
		this.onChangeBackgroundPalette = callbacks.onChangeBackgroundPalette;
		this.onChangeAlphaGradient = callbacks.onChangeAlphaGradient;
		this.onChangeVelocityGradient = callbacks.onChangeVelocityGradient;
		this.onChangeDyeGradient = callbacks.onChangeDyeGradient;
		this.onChangeGamma = callbacks.onChangeGamma;
		this.onChangeVignetteOpacity = callbacks.onChangeVignetteOpacity;
		this.onChangeVignetteMagnitude = callbacks.onChangeVignetteMagnitude;
		this.onChangeVignetteExponent = callbacks.onChangeVignetteExponent;
		this.onChangeOpticalFlowMirrorX = callbacks.onChangeOpticalFlowMirrorX;
		this.onChangeOpticalFlowTemporalSmoothing = callbacks.onChangeOpticalFlowTemporalSmoothing;
		this.onChangeOpticalFlowScale = callbacks.onChangeOpticalFlowScale;
		this.onChangeOpticalFlowExponent = callbacks.onChangeOpticalFlowExponent;
		this.onChangeOpticalFlowBlurKernel = callbacks.onChangeOpticalFlowBlurKernel;
		this.onChangeOpticalFlowGamma = callbacks.onChangeOpticalFlowGamma;
		this.onChangeFluidIterations = callbacks.onChangeFluidIterations;
		this.onChangeFluidScale = callbacks.onChangeFluidScale;
		this.onChangeSimulationScale = callbacks.onChangeSimulationScale;
		this.onChangePowerOf2Fluid = callbacks.onChangePowerOf2Fluid;
	}
	,setFromDynamic: function(obj) {
		if(Object.prototype.hasOwnProperty.call(obj,"version")) {
			var newValue = Reflect.field(obj,"version");
			var oldValue = this.version;
			this.version = newValue;
			if(this.onChangeVersion != null && oldValue != newValue) {
				this.onChangeVersion(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("version",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"paused")) {
			var newValue = Reflect.field(obj,"paused");
			var oldValue = this.paused;
			this.paused = newValue;
			if(this.onChangePaused != null && oldValue != newValue) {
				this.onChangePaused(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("paused",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"fluidPhysicsScale")) {
			var newValue = Reflect.field(obj,"fluidPhysicsScale");
			var oldValue = this.fluidPhysicsScale;
			this.fluidPhysicsScale = newValue;
			if(this.onChangeFluidPhysicsScale != null && oldValue != newValue) {
				this.onChangeFluidPhysicsScale(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("fluidPhysicsScale",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"timestepMultiplier")) {
			var newValue = Reflect.field(obj,"timestepMultiplier");
			var oldValue = this.timestepMultiplier;
			this.timestepMultiplier = newValue;
			if(this.onChangeTimestepMultiplier != null && oldValue != newValue) {
				this.onChangeTimestepMultiplier(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("timestepMultiplier",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"surfaceDecayFactor")) {
			var newValue = Reflect.field(obj,"surfaceDecayFactor");
			var oldValue = this.surfaceDecayFactor;
			this.surfaceDecayFactor = newValue;
			if(this.onChangeSurfaceDecayFactor != null && oldValue != newValue) {
				this.onChangeSurfaceDecayFactor(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("surfaceDecayFactor",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"motionDecayFactor")) {
			var newValue = Reflect.field(obj,"motionDecayFactor");
			var oldValue = this.motionDecayFactor;
			this.motionDecayFactor = newValue;
			if(this.onChangeMotionDecayFactor != null && oldValue != newValue) {
				this.onChangeMotionDecayFactor(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("motionDecayFactor",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"dragCoefficient")) {
			var newValue = Reflect.field(obj,"dragCoefficient");
			var oldValue = this.dragCoefficient;
			this.dragCoefficient = newValue;
			if(this.onChangeDragCoefficient != null && oldValue != newValue) {
				this.onChangeDragCoefficient(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("dragCoefficient",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"dragSpeed")) {
			var newValue = Reflect.field(obj,"dragSpeed");
			var oldValue = this.dragSpeed;
			this.dragSpeed = newValue;
			if(this.onChangeDragSpeed != null && oldValue != newValue) {
				this.onChangeDragSpeed(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("dragSpeed",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"periodicBoundary")) {
			var newValue = Reflect.field(obj,"periodicBoundary");
			var oldValue = this.periodicBoundary;
			this.periodicBoundary = newValue;
			if(this.onChangePeriodicBoundary != null && oldValue != newValue) {
				this.onChangePeriodicBoundary(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("periodicBoundary",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"backgroundMultiplier")) {
			var newValue = Reflect.field(obj,"backgroundMultiplier");
			var oldValue = this.backgroundMultiplier;
			this.backgroundMultiplier = newValue;
			if(this.onChangeBackgroundMultiplier != null && oldValue != newValue) {
				this.onChangeBackgroundMultiplier(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("backgroundMultiplier",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"backgroundPalette")) {
			var newValue = Reflect.field(obj,"backgroundPalette");
			var oldValue = this.backgroundPalette;
			this.backgroundPalette = newValue;
			if(this.onChangeBackgroundPalette != null && oldValue != newValue) {
				this.onChangeBackgroundPalette(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("backgroundPalette",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"alphaGradient")) {
			var newValue = Reflect.field(obj,"alphaGradient");
			var oldValue = this.alphaGradient;
			this.alphaGradient = newValue;
			if(this.onChangeAlphaGradient != null && oldValue != newValue) {
				this.onChangeAlphaGradient(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("alphaGradient",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"velocityGradient")) {
			var newValue = Reflect.field(obj,"velocityGradient");
			var oldValue = this.velocityGradient;
			this.velocityGradient = newValue;
			if(this.onChangeVelocityGradient != null && oldValue != newValue) {
				this.onChangeVelocityGradient(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("velocityGradient",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"dyeGradient")) {
			var newValue = Reflect.field(obj,"dyeGradient");
			var oldValue = this.dyeGradient;
			this.dyeGradient = newValue;
			if(this.onChangeDyeGradient != null && oldValue != newValue) {
				this.onChangeDyeGradient(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("dyeGradient",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"gamma")) {
			var newValue = Reflect.field(obj,"gamma");
			var oldValue = this.gamma;
			this.gamma = newValue;
			if(this.onChangeGamma != null && oldValue != newValue) {
				this.onChangeGamma(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("gamma",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"vignetteOpacity")) {
			var newValue = Reflect.field(obj,"vignetteOpacity");
			var oldValue = this.vignetteOpacity;
			this.vignetteOpacity = newValue;
			if(this.onChangeVignetteOpacity != null && oldValue != newValue) {
				this.onChangeVignetteOpacity(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("vignetteOpacity",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"vignetteMagnitude")) {
			var newValue = Reflect.field(obj,"vignetteMagnitude");
			var oldValue = this.vignetteMagnitude;
			this.vignetteMagnitude = newValue;
			if(this.onChangeVignetteMagnitude != null && oldValue != newValue) {
				this.onChangeVignetteMagnitude(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("vignetteMagnitude",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"vignetteExponent")) {
			var newValue = Reflect.field(obj,"vignetteExponent");
			var oldValue = this.vignetteExponent;
			this.vignetteExponent = newValue;
			if(this.onChangeVignetteExponent != null && oldValue != newValue) {
				this.onChangeVignetteExponent(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("vignetteExponent",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"opticalFlowMirrorX")) {
			var newValue = Reflect.field(obj,"opticalFlowMirrorX");
			var oldValue = this.opticalFlowMirrorX;
			this.opticalFlowMirrorX = newValue;
			if(this.onChangeOpticalFlowMirrorX != null && oldValue != newValue) {
				this.onChangeOpticalFlowMirrorX(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("opticalFlowMirrorX",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"opticalFlowTemporalSmoothing")) {
			var newValue = Reflect.field(obj,"opticalFlowTemporalSmoothing");
			var oldValue = this.opticalFlowTemporalSmoothing;
			this.opticalFlowTemporalSmoothing = newValue;
			if(this.onChangeOpticalFlowTemporalSmoothing != null && oldValue != newValue) {
				this.onChangeOpticalFlowTemporalSmoothing(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("opticalFlowTemporalSmoothing",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"opticalFlowScale")) {
			var newValue = Reflect.field(obj,"opticalFlowScale");
			var oldValue = this.opticalFlowScale;
			this.opticalFlowScale = newValue;
			if(this.onChangeOpticalFlowScale != null && oldValue != newValue) {
				this.onChangeOpticalFlowScale(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("opticalFlowScale",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"opticalFlowExponent")) {
			var newValue = Reflect.field(obj,"opticalFlowExponent");
			var oldValue = this.opticalFlowExponent;
			this.opticalFlowExponent = newValue;
			if(this.onChangeOpticalFlowExponent != null && oldValue != newValue) {
				this.onChangeOpticalFlowExponent(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("opticalFlowExponent",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"opticalFlowBlurKernel")) {
			var newValue = Reflect.field(obj,"opticalFlowBlurKernel");
			var oldValue = this.opticalFlowBlurKernel;
			this.opticalFlowBlurKernel = newValue;
			if(this.onChangeOpticalFlowBlurKernel != null && oldValue != newValue) {
				this.onChangeOpticalFlowBlurKernel(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("opticalFlowBlurKernel",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"opticalFlowGamma")) {
			var newValue = Reflect.field(obj,"opticalFlowGamma");
			var oldValue = this.opticalFlowGamma;
			this.opticalFlowGamma = newValue;
			if(this.onChangeOpticalFlowGamma != null && oldValue != newValue) {
				this.onChangeOpticalFlowGamma(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("opticalFlowGamma",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"fluidIterations")) {
			var newValue = Reflect.field(obj,"fluidIterations");
			var oldValue = this.fluidIterations;
			this.fluidIterations = newValue;
			if(this.onChangeFluidIterations != null && oldValue != newValue) {
				this.onChangeFluidIterations(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("fluidIterations",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"fluidScale")) {
			var newValue = Reflect.field(obj,"fluidScale");
			var oldValue = this.fluidScale;
			this.fluidScale = newValue;
			if(this.onChangeFluidScale != null && oldValue != newValue) {
				this.onChangeFluidScale(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("fluidScale",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"simulationScale")) {
			var newValue = Reflect.field(obj,"simulationScale");
			var oldValue = this.simulationScale;
			this.simulationScale = newValue;
			if(this.onChangeSimulationScale != null && oldValue != newValue) {
				this.onChangeSimulationScale(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("simulationScale",newValue,oldValue);
				}
			}
		}
		if(Object.prototype.hasOwnProperty.call(obj,"powerOf2Fluid")) {
			var newValue = Reflect.field(obj,"powerOf2Fluid");
			var oldValue = this.powerOf2Fluid;
			this.powerOf2Fluid = newValue;
			if(this.onChangePowerOf2Fluid != null && oldValue != newValue) {
				this.onChangePowerOf2Fluid(newValue,oldValue);
				if(this.onAnyFieldChange != null) {
					this.onAnyFieldChange("powerOf2Fluid",newValue,oldValue);
				}
			}
		}
	}
	,__class__: Settings
};
var _$SharedGPUResources_Resources = function(gl,unitQuad,screenTriangle,resample,nullTexture,shaderMap) {
	this.shaderMap = new haxe_ds_StringMap();
	this.nullTexture = null;
	this.resample = null;
	this.screenTriangle = null;
	this.unitQuad = null;
	this.gl = null;
	if(gl != null) {
		this.gl = gl;
	}
	if(unitQuad != null) {
		this.unitQuad = unitQuad;
	}
	if(screenTriangle != null) {
		this.screenTriangle = screenTriangle;
	}
	if(resample != null) {
		this.resample = resample;
	}
	if(nullTexture != null) {
		this.nullTexture = nullTexture;
	}
	if(shaderMap != null) {
		this.shaderMap = shaderMap;
	}
};
_$SharedGPUResources_Resources.__name__ = true;
_$SharedGPUResources_Resources.prototype = {
	__class__: _$SharedGPUResources_Resources
};
var SharedGPUResources = function() { };
SharedGPUResources.__name__ = true;
SharedGPUResources.getScreenTriangle = function(gl) {
	var r = SharedGPUResources.resources;
	if(r.screenTriangle == null) {
		var verts = new Float32Array([0,0,2,0,0,2]);
		r.screenTriangle = gl.createBuffer();
		gl.bindBuffer(34962,r.screenTriangle);
		gl.bufferData(34962,verts,35044);
		gl.bindBuffer(34962,null);
	}
	return r.screenTriangle;
};
SharedGPUResources.getResampleShader = function(gl) {
	var r = SharedGPUResources.resources;
	if(r.resample == null) {
		r.resample = new shaders_Resample(gl);
	}
	return r.resample;
};
SharedGPUResources.getNullTexture = function(gl) {
	var r = SharedGPUResources.resources;
	if(r.nullTexture == null) {
		r.nullTexture = Texture.createTexture(gl,1,1,new TextureParams(null,null,null,null,null,null,null),new Uint8Array([0,0,0,0]),null,false);
	}
	return r.nullTexture;
};
SharedGPUResources.getShaderWithKey = function(gl,key,onMiss) {
	var shaderMap = SharedGPUResources.resources.shaderMap;
	var shader = shaderMap.h[key];
	if(shader == null) {
		shader = onMiss(gl,key);
		shaderMap.h[key] = shader;
	}
	return shader;
};
SharedGPUResources.releaseGPUMemory = function(gl) {
	var r = SharedGPUResources.resources;
	if(r.unitQuad != null) {
		gl.deleteBuffer(r.unitQuad);
		r.unitQuad = null;
	}
	if(r.screenTriangle != null) {
		gl.deleteBuffer(r.screenTriangle);
		r.screenTriangle = null;
	}
	if(r.resample != null) {
		r.resample.destroy();
		r.resample = null;
	}
	var h = r.shaderMap.h;
	var shader_h = h;
	var shader_keys = Object.keys(h);
	var shader_length = shader_keys.length;
	var shader_current = 0;
	while(shader_current < shader_length) {
		var shader = shader_h[shader_keys[shader_current++]];
		shader.destroy();
	}
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	while(true) {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var TextureParams = function(format,internalFormat,dataType,magFilter,minFilter,wrapS,wrapT) {
	this.wrapT = 33071;
	this.wrapS = 33071;
	this.minFilter = 9728;
	this.magFilter = 9728;
	this.dataType = 5121;
	this.internalFormat = null;
	this.format = 6408;
	if(format != null) {
		this.format = format;
	}
	if(internalFormat != null) {
		this.internalFormat = internalFormat;
	}
	if(dataType != null) {
		this.dataType = dataType;
	}
	if(magFilter != null) {
		this.magFilter = magFilter;
	}
	if(minFilter != null) {
		this.minFilter = minFilter;
	}
	if(wrapS != null) {
		this.wrapS = wrapS;
	}
	if(wrapT != null) {
		this.wrapT = wrapT;
	}
};
TextureParams.__name__ = true;
TextureParams.prototype = {
	match: function(other) {
		if(this.format != other.format) {
			return false;
		}
		if(this.internalFormat != other.internalFormat) {
			return false;
		}
		if(this.dataType != other.dataType) {
			return false;
		}
		if(this.magFilter != other.magFilter) {
			return false;
		}
		if(this.minFilter != other.minFilter) {
			return false;
		}
		if(this.wrapS != other.wrapS) {
			return false;
		}
		if(this.wrapT != other.wrapT) {
			return false;
		}
		return true;
	}
	,__class__: TextureParams
};
var Texture = function(gl,width,height,native,format,internalFormat,dataType,magFilter,minFilter,wrapS,wrapT) {
	TextureParams.call(this,format,internalFormat,dataType,magFilter,minFilter,wrapS,wrapT);
	this.gl = gl;
	this.width = width;
	this.height = height;
	this.native = native;
};
Texture.__name__ = true;
Texture.createTexture = function(gl,width,height,params,data,uploadParams,generateMipmaps) {
	if(generateMipmaps == null) {
		generateMipmaps = false;
	}
	if(params == null) {
		params = new TextureParams(null,null,null,null,null,null,null);
	}
	if(uploadParams == null) {
		uploadParams = new UploadParams(null,null);
	}
	if(data == null) {
		data = null;
	}
	var glTexture = gl.createTexture();
	gl.activeTexture(33984);
	gl.bindTexture(3553,glTexture);
	gl.texParameteri(3553,10241,params.minFilter);
	gl.texParameteri(3553,10240,params.magFilter);
	gl.texParameteri(3553,10242,params.wrapS);
	gl.texParameteri(3553,10243,params.wrapT);
	gl.pixelStorei(3317,uploadParams.unpackAlignment);
	gl.pixelStorei(37440,uploadParams.webGLFlipY);
	var internalFormat = params.internalFormat == null ? params.format : params.internalFormat;
	gl.texImage2D(3553,0,internalFormat,width,height,0,params.format,params.dataType,data);
	if(generateMipmaps) {
		gl.generateMipmap(3553);
	}
	gl.bindTexture(3553,null);
	return new Texture(gl,width,height,glTexture,params.format,params.internalFormat,params.dataType,params.magFilter,params.minFilter,params.wrapS,params.wrapT);
};
Texture.updateGLTextureParameters = function(gl,texture,params) {
	gl.activeTexture(33984);
	gl.bindTexture(3553,texture);
	if(params.magFilter != null) {
		gl.texParameteri(3553,10241,params.minFilter);
	}
	if(params.minFilter != null) {
		gl.texParameteri(3553,10240,params.magFilter);
	}
	if(params.wrapS != null) {
		gl.texParameteri(3553,10242,params.wrapS);
	}
	if(params.wrapT != null) {
		gl.texParameteri(3553,10243,params.wrapT);
	}
	gl.bindTexture(3553,null);
};
Texture.__super__ = TextureParams;
Texture.prototype = $extend(TextureParams.prototype,{
	__class__: Texture
});
var UploadParams = function(unpackAlignment,webGLFlipY) {
	this.webGLFlipY = true;
	this.unpackAlignment = 4;
	if(unpackAlignment != null) {
		this.unpackAlignment = unpackAlignment;
	}
	if(webGLFlipY != null) {
		this.webGLFlipY = webGLFlipY;
	}
};
UploadParams.__name__ = true;
UploadParams.prototype = {
	__class__: UploadParams
};
var VariableTextureParams = function(magFilter,minFilter,wrapS,wrapT) {
	this.wrapT = null;
	this.wrapS = null;
	this.minFilter = null;
	this.magFilter = null;
	if(magFilter != null) {
		this.magFilter = magFilter;
	}
	if(minFilter != null) {
		this.minFilter = minFilter;
	}
	if(wrapS != null) {
		this.wrapS = wrapS;
	}
	if(wrapT != null) {
		this.wrapT = wrapT;
	}
};
VariableTextureParams.__name__ = true;
VariableTextureParams.prototype = {
	__class__: VariableTextureParams
};
var WebUI = function() { };
WebUI.__name__ = true;
WebUI.initialize = function(fluid) {
	WebUI.fluid = fluid;
	var settings = fluid.settings;
	var u = new URL($global.location.href);
	fluid.renderParticlesEnabled = u.searchParams.has("particles");
	WebUI.gui = new dat.GUI({ autoPlace : true});
	settings.onAnyFieldChange = function(_,_1,_2) {
		WebUI.gui.updateDisplay();
	};
	WebUI.gui.add(settings,"fluidIterations",1,200).onChange(function(v) {
		settings.onChangeFluidIterations(v,v);
	}).name("Solver Iterations");
	WebUI.gui.add(settings,"fluidPhysicsScale",1.0,300).onChange(function(v) {
		settings.onChangeFluidPhysicsScale(v,v);
	}).name("Physics Scale");
	WebUI.gui.add(settings,"timestepMultiplier",0.05,2).onChange(function(v) {
		settings.onChangeTimestepMultiplier(v,v);
	}).name("Timestep");
	WebUI.gui.add(settings,"dragSpeed",0.0,6.0).onChange(function(v) {
		settings.onChangeDragSpeed(v,v);
	}).name("Drag Speed");
	WebUI.gui.add(settings,"surfaceDecayFactor",0.0,6.0).onChange(function(v) {
		settings.onChangeSurfaceDecayFactor(v,v);
	}).name("Color Decay");
	WebUI.gui.add(settings,"motionDecayFactor",0.0,6.0).onChange(function(v) {
		settings.onChangeMotionDecayFactor(v,v);
	}).name("Motion Decay");
	WebUI.gui.add(settings,"backgroundMultiplier",0.0,1.0).onChange(function(v) {
		settings.onChangeBackgroundMultiplier(v,v);
	}).name("Background");
	WebUI.gui.add(settings,"periodicBoundary").onChange(function(v) {
		settings.onChangePeriodicBoundary(v,v);
	}).name("Periodic");
	WebUI.gui.add(settings,"paused").onChange(function(v) {
		settings.onChangePaused(v,v);
	}).name("Pause");
	var addGradient = function(settingsField,name) {
		var changeCallbackName = "onChange" + settingsField.charAt(0).toUpperCase() + HxOverrides.substr(settingsField,1,null);
		var changeCallback = Reflect.field(settings,changeCallbackName);
		var gradientUIDisplay = WebUI.gui.add(settings,settingsField).name("" + name + " Palette");
		var gradientFolder = WebUI.gui.addFolder("" + name + " Colors");
		var onGradientComponentChange = function() {
			changeCallback(Reflect.field(settings,settingsField),Reflect.field(settings,settingsField));
			gradientUIDisplay.updateDisplay();
		};
		var arrayToRgba = function(color) {
			return "rgba(\n\t\t\t\t\t" + color[0] * 255 + ",\n\t\t\t\t\t" + color[1] * 255 + ",\n\t\t\t\t\t" + color[2] * 255 + ",\n\t\t\t\t\t" + color[3] + "\n\t\t\t\t)";
		};
		var rgbaToArray = function(rgba) {
			var _this_r = new RegExp("[^\\d,.]*","igm".split("u").join(""));
			var _this = rgba.replace(_this_r,"").split(",");
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = parseFloat(_this[i]);
			}
			var values = result;
			return [values[0] / 255,values[1] / 255,values[2] / 255,values[3]];
		};
		var stopControls = [];
		var updateStopControls = function() {
			var _g = 0;
			while(_g < stopControls.length) {
				var c = stopControls[_g];
				++_g;
				gradientFolder.remove(c);
			}
			stopControls = [];
			var gradient = Reflect.field(settings,settingsField);
			var _g = [];
			var _g1 = 0;
			var _g2 = gradient.stops;
			while(_g1 < _g2.length) {
				var stop = _g2[_g1];
				++_g1;
				_g.push(arrayToRgba(stop.color));
			}
			var stops = _g;
			var _g = 0;
			var _g1 = stops.length;
			while(_g < _g1) {
				var i = [_g++];
				var c = gradientFolder.addColor(stops,"" + i[0]).onChange((function(i) {
					return function(c) {
						gradient.stops[i[0]].color = rgbaToArray(c);
						settings[settingsField] = gradient;
						onGradientComponentChange();
					};
				})(i));
				stopControls.push(c);
				var c1 = gradientFolder.add(gradient.stops[i[0]],"p",0.,1.0).onChange((function() {
					return function(c) {
						settings[settingsField] = gradient;
						onGradientComponentChange();
					};
				})());
				stopControls.push(c1);
			}
		};
		gradientUIDisplay.onChange(function(v) {
			changeCallback(v,v);
		});
		gradientUIDisplay.onFinishChange(function(v) {
			updateStopControls();
		});
		updateStopControls();
	};
	addGradient("backgroundPalette","Background");
	addGradient("alphaGradient","Alpha");
	addGradient("velocityGradient","Velocity");
	addGradient("dyeGradient","Dye");
	var colorGradingFolder = WebUI.gui.addFolder("Color Grading");
	colorGradingFolder.open();
	colorGradingFolder.add(settings,"gamma",0,4).onChange(function(v) {
		settings.onChangeGamma(v,v);
	});
	colorGradingFolder.add(settings,"vignetteOpacity",0.0,1.0).onChange(function(v) {
		settings.onChangeVignetteOpacity(v,v);
	});
	colorGradingFolder.add(settings,"vignetteMagnitude",0,400).onChange(function(v) {
		settings.onChangeVignetteMagnitude(v,v);
	});
	colorGradingFolder.add(settings,"vignetteExponent",0.0,10).onChange(function(v) {
		settings.onChangeVignetteExponent(v,v);
	});
	var qualityFolder = WebUI.gui.addFolder("Quality");
	qualityFolder.open();
	qualityFolder.add(settings,"fluidScale",0.125,2).onChange(function(v) {
		settings.onChangeFluidScale(v,v);
	});
	qualityFolder.add(settings,"simulationScale",0.03125,1).onChange(function(v) {
		settings.onChangeSimulationScale(v,v);
	});
	qualityFolder.add(settings,"powerOf2Fluid").onChange(function(v) {
		settings.onChangePowerOf2Fluid(v,v);
	});
	if($global.navigator.platform.toLowerCase().indexOf("iphone") != -1) {
		WebUI.gui.close();
	}
	var opticalFlowFolder = WebUI.gui.addFolder("Optical Flow");
	opticalFlowFolder.open();
	opticalFlowFolder.add(settings,"opticalFlowTemporalSmoothing",1,40).onChange(function(v) {
		settings.onChangeOpticalFlowTemporalSmoothing(v,v);
	}).name("Temporal Smoothing");
	opticalFlowFolder.add(settings,"opticalFlowScale",0,10).onChange(function(v) {
		settings.onChangeOpticalFlowScale(v,v);
	}).name("Scale");
	opticalFlowFolder.add(settings,"opticalFlowExponent",0,10).onChange(function(v) {
		settings.onChangeOpticalFlowExponent(v,v);
	}).name("Exponent");
	opticalFlowFolder.add(settings,"opticalFlowBlurKernel",1,256).onChange(function(v) {
		settings.onChangeOpticalFlowBlurKernel(v,v);
	}).name("Blur Kernel");
	opticalFlowFolder.add(settings,"opticalFlowGamma",0.1,10).onChange(function(v) {
		settings.onChangeOpticalFlowGamma(v,v);
	}).name("Gamma");
	WebUI.gui.add(fluid,"showDebugTextures").name("Debug");
	var exportSettings = { exportQuality : false};
	WebUI.gui.add(exportSettings,"exportQuality").name("Export Quality Settings");
	var loadSettings = function(e) {
		var i = window.document.createElement("input");
		i.setAttribute("type","file");
		i.addEventListener("change",function(e) {
			var file = e.target.files[0];
			var reader = new FileReader();
			reader.readAsText(file,"UTF-8");
			reader.addEventListener("load",function(e) {
				var content = e.target.result;
				try {
					JSON.parse(content);
					fluid.updateSettings(content);
				} catch( _g ) {
					var _g1 = haxe_Exception.caught(_g).unwrap();
					if(typeof(_g1) == "string") {
						var err = _g1;
						window.alert(err);
					} else {
						throw _g;
					}
				}
			});
		});
		i.click();
	};
	WebUI.gui.add({ f : loadSettings},"f").name("Load Settings");
	var downloadSettings = function() {
		var a = window.document.createElement("a");
		var _this = fluid.settings;
		var settingsObj = { version : _this.version, paused : _this.paused, fluidPhysicsScale : _this.fluidPhysicsScale, timestepMultiplier : _this.timestepMultiplier, surfaceDecayFactor : _this.surfaceDecayFactor, motionDecayFactor : _this.motionDecayFactor, dragCoefficient : _this.dragCoefficient, dragSpeed : _this.dragSpeed, periodicBoundary : _this.periodicBoundary, backgroundMultiplier : _this.backgroundMultiplier, backgroundPalette : _this.backgroundPalette, alphaGradient : _this.alphaGradient, velocityGradient : _this.velocityGradient, dyeGradient : _this.dyeGradient, gamma : _this.gamma, vignetteOpacity : _this.vignetteOpacity, vignetteMagnitude : _this.vignetteMagnitude, vignetteExponent : _this.vignetteExponent, opticalFlowMirrorX : _this.opticalFlowMirrorX, opticalFlowTemporalSmoothing : _this.opticalFlowTemporalSmoothing, opticalFlowScale : _this.opticalFlowScale, opticalFlowExponent : _this.opticalFlowExponent, opticalFlowBlurKernel : _this.opticalFlowBlurKernel, opticalFlowGamma : _this.opticalFlowGamma, fluidIterations : _this.fluidIterations, fluidScale : _this.fluidScale, simulationScale : _this.simulationScale, powerOf2Fluid : _this.powerOf2Fluid};
		if(!exportSettings.exportQuality) {
			Reflect.deleteField(settingsObj,"fluidIterations");
			Reflect.deleteField(settingsObj,"fluidScale");
			Reflect.deleteField(settingsObj,"simulationScale");
			Reflect.deleteField(settingsObj,"powerOf2Fluid");
		}
		a.setAttribute("href","data:text/plain;charset=utf-8," + JSON.stringify(settingsObj,null,"\t"));
		a.setAttribute("download","fluid-settings.json");
		a.style.display = "none";
		window.document.body.appendChild(a);
		a.click();
		a.remove();
	};
	WebUI.gui.add({ f : downloadSettings},"f").name("Download Settings");
};
WebUI.reset = function() {
	if(WebUI.gui != null) {
		WebUI.gui.destroy();
		WebUI.initialize(WebUI.fluid);
	}
};
var filter_IFilter = function() { };
filter_IFilter.__name__ = true;
filter_IFilter.__isInterface__ = true;
var filter_Bloom = function(gl,blurKernelNormalized,downsampleSize) {
	if(downsampleSize == null) {
		downsampleSize = 128;
	}
	if(blurKernelNormalized == null) {
		blurKernelNormalized = 0.08;
	}
	this.gl = gl;
	this.blurKernelNormalized = blurKernelNormalized;
	this.downsampleSize = downsampleSize;
	this.screenTriangle = SharedGPUResources.getScreenTriangle(gl);
};
filter_Bloom.__name__ = true;
filter_Bloom.__interfaces__ = [filter_IFilter];
filter_Bloom.prototype = {
	releaseGPUMemory: function() {
		if(this.downsampleChain != null) {
			this.downsampleChain.releaseGPUMemory();
		}
		if(this.blur != null) {
			this.blur.releaseGPUMemory();
		}
	}
	,__class__: filter_Bloom
};
var filter_Blur = function(gl,kernelX,kernelY) {
	this.blurIntermediateXY = new filter_IntermediateRenderTarget();
	this.blurIntermediateX = new filter_IntermediateRenderTarget();
	this.gl = gl;
	this.kernelX = kernelX;
	this.kernelY = kernelY;
	this.blurShaderX = SharedGPUResources.getShaderWithKey(gl,"blurX(k" + kernelX + ")",function(gl,_) {
		return new filter_Blur1DShader(gl,new Float32Array([1,0]),kernelX);
	});
	this.blurShaderY = SharedGPUResources.getShaderWithKey(gl,"blurY(k" + kernelY + ")",function(gl,_) {
		return new filter_Blur1DShader(gl,new Float32Array([0,1]),kernelY);
	});
	this.screenTriangle = SharedGPUResources.getScreenTriangle(gl);
};
filter_Blur.__name__ = true;
filter_Blur.__interfaces__ = [filter_IFilter];
filter_Blur.prototype = {
	apply: function(input,_,textureParams) {
		if(textureParams == null) {
			textureParams = input;
		}
		var targetWidth = input.width;
		var targetHeight = input.height;
		var blurXTarget = this.blurIntermediateX.get(this.gl,targetWidth,targetHeight,textureParams);
		var blurXYTarget = this.blurIntermediateXY.get(this.gl,targetWidth,targetHeight,textureParams);
		this.gl.viewport(0,0,blurXTarget.width,blurXTarget.height);
		blurXTarget.gl.bindFramebuffer(36160,blurXTarget.frameBufferObject);
		this.gl.bindBuffer(34962,this.screenTriangle);
		var _this = this.blurShaderX.texture;
		_this.dirty = true;
		_this.data = input.native;
		this.blurShaderX.invResolution.data[0] = 1 / input.width;
		this.blurShaderX.invResolution.data[1] = 1 / input.height;
		this.blurShaderX.invResolution.dirty = true;
		var _this = this.blurShaderX;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(_this._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this.gl.enableVertexAttribArray(location);
						_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!_this._ready) {
				_this.create();
			}
			_this.gl.useProgram(_this._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this.gl.enableVertexAttribArray(location);
						_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			_this._active = true;
		}
		this.gl.drawArrays(4,0,3);
		this.blurShaderX.deactivate();
		blurXYTarget.gl.bindFramebuffer(36160,blurXYTarget.frameBufferObject);
		this.gl.bindBuffer(34962,this.screenTriangle);
		var _this = this.blurShaderY.texture;
		_this.dirty = true;
		_this.data = blurXTarget.texture.native;
		this.blurShaderY.invResolution.data[0] = 1 / input.width;
		this.blurShaderY.invResolution.data[1] = 1 / input.height;
		this.blurShaderY.invResolution.dirty = true;
		var _this = this.blurShaderY;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(_this._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this.gl.enableVertexAttribArray(location);
						_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!_this._ready) {
				_this.create();
			}
			_this.gl.useProgram(_this._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this.gl.enableVertexAttribArray(location);
						_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			_this._active = true;
		}
		this.gl.drawArrays(4,0,3);
		this.blurShaderY.deactivate();
		return blurXYTarget.texture;
	}
	,releaseGPUMemory: function() {
		if(this.blurIntermediateX != null) {
			this.blurIntermediateX.destroy();
		}
		if(this.blurIntermediateXY != null) {
			this.blurIntermediateXY.destroy();
		}
	}
	,__class__: filter_Blur
};
var filter_Blur1DShader = function(gl,direction,kernel) {
	this.gl = gl;
	this.kernel = kernel;
	this.direction = direction;
	this.shaderParts = this.generateShaderParts();
	shaderblox_ShaderBase.call(this,gl);
};
filter_Blur1DShader.__name__ = true;
filter_Blur1DShader.__super__ = shaderblox_ShaderBase;
filter_Blur1DShader.prototype = $extend(shaderblox_ShaderBase.prototype,{
	generateShaderParts: function() {
		var N = this.nearestBestKernel(this.kernel);
		var centerIndex = (N - 1) / 2;
		var offsets = [];
		var weights = [];
		var totalWeight = 0.0;
		var _g = 0;
		var _g1 = N;
		while(_g < _g1) {
			var i = _g++;
			var u = i / (N - 1);
			var w = this.gaussianWeight(u * 2.0 - 1);
			offsets[i] = i - centerIndex;
			weights[i] = w;
			totalWeight += w;
		}
		var _g = 0;
		var _g1 = weights.length;
		while(_g < _g1) {
			var i = _g++;
			weights[i] /= totalWeight;
		}
		var linearSamplingWeights = [];
		var linearSamplingOffsets = [];
		var linearSamplingMap = [];
		var i = 0;
		while(i <= centerIndex) {
			var j = Math.min(i + 1,Math.floor(centerIndex)) | 0;
			var singleCenterSample = i == j;
			if(singleCenterSample) {
				linearSamplingMap.push({ o : offsets[i], w : weights[i]});
			} else {
				var sharedCell = j == centerIndex;
				var weightLinear = weights[i] + weights[j] * (sharedCell ? .5 : 1.);
				var offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);
				if(offsetLinear == 0) {
					linearSamplingMap.push({ o : offsets[i], w : weights[i]});
					linearSamplingMap.push({ o : offsets[i + 1], w : weights[i + 1]});
				} else {
					linearSamplingMap.push({ o : offsetLinear, w : weightLinear});
					linearSamplingMap.push({ o : -offsetLinear, w : weightLinear});
				}
			}
			i += 2;
		}
		var _g = 0;
		var _g1 = linearSamplingMap.length;
		while(_g < _g1) {
			var i = _g++;
			linearSamplingOffsets[i] = linearSamplingMap[i].o;
			linearSamplingWeights[i] = linearSamplingMap[i].w;
		}
		offsets = linearSamplingOffsets;
		weights = linearSamplingWeights;
		var varyingCount = offsets.length;
		var _g = [];
		var _g1 = 0;
		var _g2 = varyingCount;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push("varying vec2 sampleCoord" + i + ";");
		}
		var varyingDeclarations = _g;
		var _g = [];
		var _g1 = 0;
		var _g2 = varyingCount;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push("sampleCoord" + i + " = texelCoord + vec2(" + this.glslFloat(offsets[i] * this.direction[0]) + ", " + this.glslFloat(offsets[i] * this.direction[1]) + ") * invResolution;");
		}
		var varyingValues = _g;
		var _g = [];
		var _g1 = 0;
		var _g2 = varyingCount;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push("blend += texture2D(texture, sampleCoord" + i + ") * " + this.glslFloat(weights[i]) + ";");
		}
		var textureSamples = _g;
		return { varyingDeclarations : varyingDeclarations, varyingValues : varyingValues, textureSamples : textureSamples};
	}
	,nearestBestKernel: function(idealKernel) {
		var v = Math.round(idealKernel);
		var k = v;
		if(k % 2 != 0 && Math.floor(k / 2) % 2 == 0 && k > 0) {
			return Math.max(k,3) | 0;
		}
		var k = v - 1;
		if(k % 2 != 0 && Math.floor(k / 2) % 2 == 0 && k > 0) {
			return Math.max(k,3) | 0;
		}
		var k = v + 1;
		if(k % 2 != 0 && Math.floor(k / 2) % 2 == 0 && k > 0) {
			return Math.max(k,3) | 0;
		}
		var k = v - 2;
		if(k % 2 != 0 && Math.floor(k / 2) % 2 == 0 && k > 0) {
			return Math.max(k,3) | 0;
		}
		var k = v + 2;
		if(k % 2 != 0 && Math.floor(k / 2) % 2 == 0 && k > 0) {
			return Math.max(k,3) | 0;
		}
		return Math.max(v,3) | 0;
	}
	,gaussianWeight: function(x) {
		var sigma = 0.333333333333333315;
		var denominator = Math.sqrt(2.0 * Math.PI) * sigma;
		var exponent = -(x * x / (2.0 * sigma * sigma));
		var weight = 1.0 / denominator * Math.exp(exponent);
		return weight;
	}
	,glslFloat: function(f) {
		var s = f == null ? "null" : "" + f;
		if(s.indexOf(".") == -1) {
			s += ".";
		}
		return s;
	}
	,createProperties: function() {
		shaderblox_ShaderBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UVec2(this.gl,"invResolution",null);
		this.invResolution = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"texture",null,false);
		this.texture = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_attributes_FloatAttribute("vertexPosition",0,2);
		this.vertexPosition = instance;
		this._attributes.push(instance);
		this._aStride += 8;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nattribute vec2 vertexPosition;\n    uniform vec2 invResolution;\n    \n" + this.shaderParts.varyingDeclarations.join("\n") + "\n    void main() {\n        vec2 texelCoord = vertexPosition;\n        \n" + this.shaderParts.varyingValues.join("\n") + "\n        vec2 clipSpace = 2.0*texelCoord - 1.0;\t\n        gl_Position = vec4(clipSpace, 0.0, 1.);\n    }\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform sampler2D texture;\n    \n" + this.shaderParts.varyingDeclarations.join("\n") + "\n    void main() {\n        vec4 blend = vec4(0.0);\n        \n" + this.shaderParts.textureSamples.join("\n") + ";\n        gl_FragColor = blend;\n    }\n";
	}
	,__class__: filter_Blur1DShader
});
var filter_DownsampleHalf = function(gl) {
	this.intermediate = new filter_IntermediateRenderTarget();
	this.gl = gl;
	this.resampleShader = SharedGPUResources.getResampleShader(gl);
	this.screenTriangle = SharedGPUResources.getScreenTriangle(gl);
};
filter_DownsampleHalf.__name__ = true;
filter_DownsampleHalf.__interfaces__ = [filter_IFilter];
filter_DownsampleHalf.prototype = {
	apply: function(input,_,textureParams) {
		if(textureParams == null) {
			textureParams = input;
		}
		var targetWidth = input.width * 0.5 | 0;
		var targetHeight = input.height * 0.5 | 0;
		var outputTarget = this.intermediate.get(this.gl,targetWidth,targetHeight,textureParams);
		outputTarget.gl.bindFramebuffer(36160,outputTarget.frameBufferObject);
		this.gl.viewport(0,0,outputTarget.width,outputTarget.height);
		this.gl.bindBuffer(34962,this.screenTriangle);
		var _this = this.resampleShader.texture;
		_this.dirty = true;
		_this.data = input.native;
		var _this = this.resampleShader;
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(_this._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this.gl.enableVertexAttribArray(location);
						_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!_this._ready) {
				_this.create();
			}
			_this.gl.useProgram(_this._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = _this._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = _this._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = _this._attributes[i];
					var location = att.location;
					if(location != -1) {
						_this.gl.enableVertexAttribArray(location);
						_this.gl.vertexAttribPointer(location,att.itemCount,att.type,false,_this._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			_this._active = true;
		}
		this.gl.drawArrays(4,0,3);
		this.resampleShader.deactivate();
		return outputTarget.texture;
	}
	,releaseGPUMemory: function() {
		if(this.intermediate != null) {
			this.intermediate.destroy();
		}
	}
	,__class__: filter_DownsampleHalf
};
var filter_DownsampleHalfChain = function(gl,count) {
	this.gl = gl;
	this.count = count;
	var _g = [];
	var _g1 = 0;
	var _g2 = count;
	while(_g1 < _g2) {
		var i = _g1++;
		_g.push(new filter_DownsampleHalf(gl));
	}
	this.downsampleFilters = _g;
};
filter_DownsampleHalfChain.__name__ = true;
filter_DownsampleHalfChain.prototype = {
	apply: function(input) {
		var current = input;
		var _g = 0;
		var _g1 = this.count;
		while(_g < _g1) {
			var i = _g++;
			current = this.downsampleFilters[i].apply(current);
		}
		return current;
	}
	,releaseGPUMemory: function() {
		var _g = 0;
		var _g1 = this.downsampleFilters;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			f.releaseGPUMemory();
		}
	}
	,__class__: filter_DownsampleHalfChain
};
var filter_IntermediateRenderTarget = function() {
};
filter_IntermediateRenderTarget.__name__ = true;
filter_IntermediateRenderTarget.prototype = {
	get: function(gl,targetWidth,targetHeight,targetParameters) {
		if(this._currentTarget != null) {
			if(targetWidth != this._currentTarget.width || targetHeight != this._currentTarget.height || !targetParameters.match(this._currentTarget.textureParameters)) {
				var _this = this._currentTarget;
				_this.gl.deleteFramebuffer(_this.frameBufferObject);
				_this.gl.deleteTexture(_this.texture.native);
				this._currentTarget = null;
			}
		}
		if(this._currentTarget == null) {
			this._currentTarget = new render_RenderTarget(gl,targetWidth,targetHeight,targetParameters);
		}
		return this._currentTarget;
	}
	,destroy: function() {
		if(this._currentTarget != null) {
			var _this = this._currentTarget;
			_this.gl.deleteFramebuffer(_this.frameBufferObject);
			_this.gl.deleteTexture(_this.texture.native);
		}
	}
	,__class__: filter_IntermediateRenderTarget
};
var filter_Swappable = function() {
};
filter_Swappable.__name__ = true;
filter_Swappable.prototype = {
	get: function(gl,targetWidth,targetHeight,targetParameters) {
		if(this._currentTarget != null) {
			if(targetWidth != this._currentTarget.width || targetHeight != this._currentTarget.height || !targetParameters.match(this._currentTarget.textureParameters)) {
				var _this = this._currentTarget;
				_this.gl.deleteFramebuffer(_this.writeFrameBufferObject);
				_this.gl.deleteFramebuffer(_this.readFrameBufferObject);
				_this.gl.deleteTexture(_this.writeToTexture.native);
				_this.gl.deleteTexture(_this.readFromTexture.native);
				this._currentTarget = null;
			}
		}
		if(this._currentTarget == null) {
			this._currentTarget = new render_RenderTargetSwappable(gl,targetWidth,targetHeight,targetParameters);
		}
		return this._currentTarget;
	}
	,destroy: function() {
		if(this._currentTarget != null) {
			var _this = this._currentTarget;
			_this.gl.deleteFramebuffer(_this.writeFrameBufferObject);
			_this.gl.deleteFramebuffer(_this.readFrameBufferObject);
			_this.gl.deleteTexture(_this.writeToTexture.native);
			_this.gl.deleteTexture(_this.readFromTexture.native);
		}
	}
	,__class__: filter_Swappable
};
var filter_SobelH = function(gl) {
	this.outputIntermediate = new filter_IntermediateRenderTarget();
	this.gl = gl;
	this.screenTriangle = SharedGPUResources.getScreenTriangle(gl);
	this.sobelShaderH = SharedGPUResources.getShaderWithKey(gl,"sobel(h)",function(gl,_) {
		return new filter_SobelShader(gl,0);
	});
};
filter_SobelH.__name__ = true;
filter_SobelH.__interfaces__ = [filter_IFilter];
filter_SobelH.prototype = {
	releaseGPUMemory: function() {
		if(this.outputIntermediate != null) {
			this.outputIntermediate.destroy();
		}
	}
	,__class__: filter_SobelH
};
var filter_SobelV = function(gl) {
	this.outputIntermediate = new filter_IntermediateRenderTarget();
	this.gl = gl;
	this.screenTriangle = SharedGPUResources.getScreenTriangle(gl);
	this.sobelShaderV = SharedGPUResources.getShaderWithKey(gl,"sobel(v)",function(gl,_) {
		return new filter_SobelShader(gl,1);
	});
};
filter_SobelV.__name__ = true;
filter_SobelV.__interfaces__ = [filter_IFilter];
filter_SobelV.prototype = {
	releaseGPUMemory: function() {
		if(this.outputIntermediate != null) {
			this.outputIntermediate.destroy();
		}
	}
	,__class__: filter_SobelV
};
var filter_SobelShader = function(gl,mode) {
	var tmp;
	switch(mode) {
	case 0:
		tmp = "\n                sampleCoord0 = texelCoord + vec2(-1, -1) * invResolution;\n                sampleCoord1 = texelCoord + vec2(-1,  0) * invResolution;\n                sampleCoord2 = texelCoord + vec2(-1, +1) * invResolution;\n                sampleCoord3 = texelCoord + vec2(+1, -1) * invResolution;\n                sampleCoord4 = texelCoord + vec2(+1,  0) * invResolution;\n                sampleCoord5 = texelCoord + vec2(+1, +1) * invResolution;\n            ";
		break;
	case 1:
		tmp = "\n                sampleCoord0 = texelCoord + vec2(-1, -1) * invResolution;\n                sampleCoord1 = texelCoord + vec2( 0, -1) * invResolution;\n                sampleCoord2 = texelCoord + vec2(+1, -1) * invResolution;\n                sampleCoord3 = texelCoord + vec2(-1, +1) * invResolution;\n                sampleCoord4 = texelCoord + vec2( 0, +1) * invResolution;\n                sampleCoord5 = texelCoord + vec2(+1, +1) * invResolution;\n            ";
		break;
	}
	this.sampleCoordinates = tmp;
	shaderblox_ShaderBase.call(this,gl);
};
filter_SobelShader.__name__ = true;
filter_SobelShader.__super__ = shaderblox_ShaderBase;
filter_SobelShader.prototype = $extend(shaderblox_ShaderBase.prototype,{
	createProperties: function() {
		shaderblox_ShaderBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UVec2(this.gl,"invResolution",null);
		this.invResolution = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"texture",null,false);
		this.texture = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_attributes_FloatAttribute("vertexPosition",0,2);
		this.vertexPosition = instance;
		this._attributes.push(instance);
		this._aStride += 8;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nattribute vec2 vertexPosition;\n    uniform vec2 invResolution;\n    varying vec2 sampleCoord0;\n    varying vec2 sampleCoord1;\n    varying vec2 sampleCoord2;\n    varying vec2 sampleCoord3;\n    varying vec2 sampleCoord4;\n    varying vec2 sampleCoord5;\n    void main() {\n        vec2 texelCoord = vertexPosition;\n        \n" + this.sampleCoordinates + "\n        vec2 clipSpace = 2.0*texelCoord - 1.0;\t\n        gl_Position = vec4(clipSpace, 0.0, 1.);\n    }\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform sampler2D texture;\n    varying vec2 sampleCoord0;\n    varying vec2 sampleCoord1;\n    varying vec2 sampleCoord2;\n    varying vec2 sampleCoord3;\n    varying vec2 sampleCoord4;\n    varying vec2 sampleCoord5;\n    void main() {\n        vec4 sobel = vec4(0);\n        \n        sobel += texture2D(texture, sampleCoord0) * -1.0;\n        sobel += texture2D(texture, sampleCoord1) * -2.0;\n        sobel += texture2D(texture, sampleCoord2) * -1.0;\n        sobel += texture2D(texture, sampleCoord3) *  1.0;\n        sobel += texture2D(texture, sampleCoord4) *  2.0;\n        sobel += texture2D(texture, sampleCoord5) *  1.0;\n        gl_FragColor = sobel;\n    }\n";
	}
	,__class__: filter_SobelShader
});
var gluon_webgl_GLContextDebug = function() { };
gluon_webgl_GLContextDebug.__name__ = true;
gluon_webgl_GLContextDebug.getConstantName = function(constant) {
	var mapped = gluon_webgl_GLContextDebug.constantNameMap.h[constant];
	if(mapped != null) {
		return mapped;
	} else {
		return "0x" + StringTools.hex(constant,4);
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
haxe_IMap.__isInterface__ = true;
haxe_IMap.prototype = {
	__class__: haxe_IMap
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	get: function(key) {
		return this.h[key];
	}
	,remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(key | 0);
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	get: function(key) {
		return this.h[key];
	}
	,keys: function() {
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.h);
	}
	,__class__: haxe_ds_StringMap
};
var haxe_ds__$StringMap_StringMapKeyIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = true;
haxe_ds__$StringMap_StringMapKeyIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.keys[this.current++];
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyIterator
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var math_POT = function() { };
math_POT.__name__ = true;
math_POT.floorPowerOf2 = function(v) {
	var i = Math.floor(v);
	i |= i >> 1;
	i |= i >> 2;
	i |= i >> 4;
	i |= i >> 8;
	i |= i >> 16;
	return i - (i >> 1);
};
math_POT.log2 = function(x) {
	return Math.log(x) * 1.4426950408889634;
};
var render_IRenderTarget = function() { };
render_IRenderTarget.__name__ = true;
render_IRenderTarget.__isInterface__ = true;
render_IRenderTarget.prototype = {
	__class__: render_IRenderTarget
};
var render_RenderTarget = function(gl,width,height,textureParameters,textureFactory) {
	this.gl = gl;
	this.width = width;
	this.height = height;
	this.textureParameters = textureParameters;
	this.textureFactory = textureFactory;
	this.frameBufferObject = gl.createFramebuffer();
	var newTexture = this.createEmptyTexture(width,height);
	this.gl.bindFramebuffer(36160,this.frameBufferObject);
	this.gl.framebufferTexture2D(36160,36064,3553,newTexture.native,0);
	if(this.texture != null) {
		var resampler = SharedGPUResources.getResampleShader(this.gl);
		var _this = resampler.texture;
		_this.dirty = true;
		_this.data = this.texture.native;
		this.gl.bindFramebuffer(36160,this.frameBufferObject);
		this.gl.viewport(0,0,width,height);
		this.gl.bindBuffer(34962,SharedGPUResources.getScreenTriangle(this.gl));
		var initUniforms = true;
		var initAttribs = true;
		if(initAttribs == null) {
			initAttribs = false;
		}
		if(initUniforms == null) {
			initUniforms = true;
		}
		if(resampler._active) {
			if(initUniforms) {
				var _g = 0;
				var _g1 = resampler._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = resampler._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = resampler._attributes[i];
					var location = att.location;
					if(location != -1) {
						resampler.gl.enableVertexAttribArray(location);
						resampler.gl.vertexAttribPointer(location,att.itemCount,att.type,false,resampler._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
		} else {
			if(!resampler._ready) {
				resampler.create();
			}
			resampler.gl.useProgram(resampler._prog);
			if(initUniforms) {
				var _g = 0;
				var _g1 = resampler._uniforms;
				while(_g < _g1.length) {
					var u = _g1[_g];
					++_g;
					if(u.dirty || u.alwaysDirty) {
						u.apply();
					}
				}
			}
			if(initAttribs) {
				var offset = 0;
				var _g = 0;
				var _g1 = resampler._attributes.length;
				while(_g < _g1) {
					var i = _g++;
					var att = resampler._attributes[i];
					var location = att.location;
					if(location != -1) {
						resampler.gl.enableVertexAttribArray(location);
						resampler.gl.vertexAttribPointer(location,att.itemCount,att.type,false,resampler._aStride,offset);
					}
					offset += att.byteSize;
				}
			}
			resampler._active = true;
		}
		this.gl.drawArrays(4,0,3);
		resampler.deactivate();
		this.gl.deleteTexture(this.texture.native);
	} else {
		this.gl.bindFramebuffer(36160,this.frameBufferObject);
		this.gl.viewport(0,0,this.width,this.height);
		this.gl.clearColor(0,0,0,1);
		this.gl.clear(16384);
	}
	this.width = width;
	this.height = height;
	this.texture = newTexture;
};
render_RenderTarget.__name__ = true;
render_RenderTarget.__interfaces__ = [render_IRenderTarget];
render_RenderTarget.prototype = {
	updateTextureParameters: function(params) {
		Texture.updateGLTextureParameters(this.gl,this.texture.native,params);
		if(params.magFilter != null) {
			this.textureParameters.magFilter = params.magFilter;
		}
		if(params.minFilter != null) {
			this.textureParameters.minFilter = params.minFilter;
		}
		if(params.wrapS != null) {
			this.textureParameters.wrapS = params.wrapS;
		}
		if(params.wrapT != null) {
			this.textureParameters.wrapT = params.wrapT;
		}
	}
	,activate: function() {
		this.gl.bindFramebuffer(36160,this.frameBufferObject);
	}
	,createEmptyTexture: function(width,height) {
		if(this.textureFactory != null) {
			return this.textureFactory(this.gl,width,height);
		}
		return Texture.createTexture(this.gl,width,height,this.textureParameters,null);
	}
	,__class__: render_RenderTarget
};
var render_RenderTargetSwappable = function(gl,width,height,textureParameters,textureFactory) {
	this.gl = gl;
	this.width = width;
	this.height = height;
	this.textureParameters = textureParameters;
	this.textureFactory = textureFactory;
	this.writeFrameBufferObject = gl.createFramebuffer();
	this.readFrameBufferObject = gl.createFramebuffer();
	this.resize(width,height);
};
render_RenderTargetSwappable.__name__ = true;
render_RenderTargetSwappable.__interfaces__ = [render_IRenderTarget];
render_RenderTargetSwappable.prototype = {
	resize: function(width,height) {
		var newWriteToTexture = this.createEmptyTexture(width,height);
		var newReadFromTexture = this.createEmptyTexture(width,height);
		this.gl.bindFramebuffer(36160,this.writeFrameBufferObject);
		this.gl.framebufferTexture2D(36160,36064,3553,newWriteToTexture.native,0);
		this.gl.bindFramebuffer(36160,this.readFrameBufferObject);
		this.gl.framebufferTexture2D(36160,36064,3553,newReadFromTexture.native,0);
		if(this.readFromTexture != null) {
			var resampler = SharedGPUResources.getResampleShader(this.gl);
			var _this = resampler.texture;
			_this.dirty = true;
			_this.data = this.readFromTexture.native;
			this.gl.bindFramebuffer(36160,this.readFrameBufferObject);
			this.gl.viewport(0,0,width,height);
			this.gl.bindBuffer(34962,SharedGPUResources.getScreenTriangle(this.gl));
			var initUniforms = true;
			var initAttribs = true;
			if(initAttribs == null) {
				initAttribs = false;
			}
			if(initUniforms == null) {
				initUniforms = true;
			}
			if(resampler._active) {
				if(initUniforms) {
					var _g = 0;
					var _g1 = resampler._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = resampler._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = resampler._attributes[i];
						var location = att.location;
						if(location != -1) {
							resampler.gl.enableVertexAttribArray(location);
							resampler.gl.vertexAttribPointer(location,att.itemCount,att.type,false,resampler._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
			} else {
				if(!resampler._ready) {
					resampler.create();
				}
				resampler.gl.useProgram(resampler._prog);
				if(initUniforms) {
					var _g = 0;
					var _g1 = resampler._uniforms;
					while(_g < _g1.length) {
						var u = _g1[_g];
						++_g;
						if(u.dirty || u.alwaysDirty) {
							u.apply();
						}
					}
				}
				if(initAttribs) {
					var offset = 0;
					var _g = 0;
					var _g1 = resampler._attributes.length;
					while(_g < _g1) {
						var i = _g++;
						var att = resampler._attributes[i];
						var location = att.location;
						if(location != -1) {
							resampler.gl.enableVertexAttribArray(location);
							resampler.gl.vertexAttribPointer(location,att.itemCount,att.type,false,resampler._aStride,offset);
						}
						offset += att.byteSize;
					}
				}
				resampler._active = true;
			}
			this.gl.drawArrays(4,0,3);
			resampler.deactivate();
			this.gl.deleteTexture(this.readFromTexture.native);
		} else {
			this.gl.bindFramebuffer(36160,this.readFrameBufferObject);
			this.gl.viewport(0,0,this.width,this.height);
			this.gl.clearColor(0,0,0,1);
			this.gl.clear(16384);
		}
		if(this.writeToTexture != null) {
			this.gl.deleteTexture(this.writeToTexture.native);
		} else {
			this.gl.bindFramebuffer(36160,this.writeFrameBufferObject);
			this.gl.viewport(0,0,this.width,this.height);
			this.gl.clearColor(0,0,0,1);
			this.gl.clear(16384);
		}
		this.width = width;
		this.height = height;
		this.writeToTexture = newWriteToTexture;
		this.readFromTexture = newReadFromTexture;
		return this;
	}
	,updateTextureParameters: function(params) {
		Texture.updateGLTextureParameters(this.gl,this.readFromTexture.native,params);
		Texture.updateGLTextureParameters(this.gl,this.writeToTexture.native,params);
		if(params.magFilter != null) {
			this.textureParameters.magFilter = params.magFilter;
		}
		if(params.minFilter != null) {
			this.textureParameters.minFilter = params.minFilter;
		}
		if(params.wrapS != null) {
			this.textureParameters.wrapS = params.wrapS;
		}
		if(params.wrapT != null) {
			this.textureParameters.wrapT = params.wrapT;
		}
	}
	,activate: function() {
		this.gl.bindFramebuffer(36160,this.writeFrameBufferObject);
	}
	,createEmptyTexture: function(width,height) {
		if(this.textureFactory != null) {
			return this.textureFactory(this.gl,width,height);
		}
		return Texture.createTexture(this.gl,width,height,this.textureParameters,null);
	}
	,__class__: render_RenderTargetSwappable
};
var shaderblox_attributes_Attribute = function() { };
shaderblox_attributes_Attribute.__name__ = true;
shaderblox_attributes_Attribute.prototype = {
	__class__: shaderblox_attributes_Attribute
};
var shaderblox_attributes_FloatAttribute = function(name,location,nFloats) {
	if(nFloats == null) {
		nFloats = 1;
	}
	this.name = name;
	this.location = location;
	this.byteSize = nFloats * 4;
	this.itemCount = nFloats;
	this.type = 5126;
};
shaderblox_attributes_FloatAttribute.__name__ = true;
shaderblox_attributes_FloatAttribute.__super__ = shaderblox_attributes_Attribute;
shaderblox_attributes_FloatAttribute.prototype = $extend(shaderblox_attributes_Attribute.prototype,{
	__class__: shaderblox_attributes_FloatAttribute
});
var shaderblox_glsl_GLSLTools = function() { };
shaderblox_glsl_GLSLTools.__name__ = true;
shaderblox_glsl_GLSLTools.injectConstValue = function(src,name,value) {
	var storageQualifier = "const";
	var types = shaderblox_glsl_GLSLTools.STORAGE_QUALIFIER_TYPES.h[storageQualifier];
	var reg = new EReg(storageQualifier + "\\s+((" + shaderblox_glsl_GLSLTools.PRECISION_QUALIFIERS.join("|") + ")\\s+)?(" + types.join("|") + ")\\s+([^;]+)","m");
	var src1 = shaderblox_glsl_GLSLTools.stripComments(src);
	var currStr = src1;
	while(reg.match(currStr)) {
		var declarationPos = reg.matchedPos();
		var rawDeclarationString = reg.matched(0);
		var exploded = shaderblox_glsl_GLSLTools.bracketExplode(rawDeclarationString,"()");
		var rootScopeStr = Lambda.fold(exploded.contents,function(n,rs) {
			return rs + (((n) instanceof shaderblox_glsl__$GLSLTools_StringNode) ? n.toString() : "");
		},"");
		var rConstName = new EReg("\\b(" + name + ")\\b\\s*=","m");
		var nameFound = rConstName.match(rootScopeStr);
		if(nameFound) {
			var namePos = rConstName.matchedPos();
			var initializerLength = 0;
			initializerLength = rConstName.matchedRight().indexOf(",");
			if(initializerLength == -1) {
				initializerLength = rConstName.matchedRight().length;
			}
			var initializerRangeInRootStr_start = namePos.pos + namePos.len;
			var initializerRangeInRootStr_end = namePos.pos + namePos.len + initializerLength;
			var absoluteOffset = src1.length - currStr.length + declarationPos.pos;
			var initializerRangeAbsolute_start = shaderblox_glsl_GLSLTools.compressedToExploded(exploded,initializerRangeInRootStr_start) + absoluteOffset;
			var initializerRangeAbsolute_end = shaderblox_glsl_GLSLTools.compressedToExploded(exploded,initializerRangeInRootStr_end) + absoluteOffset;
			var srcBefore = src1.substring(0,initializerRangeAbsolute_start);
			var srcAfter = src1.substring(initializerRangeAbsolute_end);
			return srcBefore + value + srcAfter;
		}
		currStr = reg.matchedRight();
	}
	return null;
};
shaderblox_glsl_GLSLTools.compressedToExploded = function(scope,compressedPosition) {
	var CC = compressedPosition;
	var stringTotal = 0;
	var nodeTotal = 0;
	var targetIndex = null;
	var _g = 0;
	var _g1 = scope.contents.length;
	while(_g < _g1) {
		var i = _g++;
		var n = scope.contents[i];
		var len = n.toString().length;
		if(((n) instanceof shaderblox_glsl__$GLSLTools_StringNode)) {
			if(stringTotal + len > CC) {
				targetIndex = i;
				break;
			}
			stringTotal += len;
		}
		nodeTotal += len;
	}
	return CC - stringTotal + nodeTotal;
};
shaderblox_glsl_GLSLTools.stripComments = function(src) {
	var _this_r = new RegExp("(/\\*([\\s\\S]*?)\\*/)|(//(.*)$)","igm".split("u").join(""));
	return src.replace(_this_r,"");
};
shaderblox_glsl_GLSLTools.bracketExplode = function(src,brackets) {
	if(brackets.length != 2) {
		return null;
	}
	var open = brackets.charAt(0);
	var close = brackets.charAt(1);
	var root = new shaderblox_glsl__$GLSLTools_ScopeNode();
	var scopeStack = [];
	var currentScope = root;
	var currentNode = null;
	var c;
	var level = 0;
	var _g = 0;
	var _g1 = src.length;
	while(_g < _g1) {
		var i = _g++;
		c = src.charAt(i);
		if(c == open) {
			++level;
			var newScope = new shaderblox_glsl__$GLSLTools_ScopeNode(brackets);
			currentScope.contents.push(newScope);
			scopeStack.push(currentScope);
			currentScope = newScope;
			currentNode = currentScope;
		} else if(c == close) {
			--level;
			currentScope = scopeStack.pop();
			currentNode = currentScope;
		} else {
			if(!((currentNode) instanceof shaderblox_glsl__$GLSLTools_StringNode)) {
				currentNode = new shaderblox_glsl__$GLSLTools_StringNode();
				currentScope.contents.push(currentNode);
			}
			(js_Boot.__cast(currentNode , shaderblox_glsl__$GLSLTools_StringNode)).contents += c;
		}
	}
	return root;
};
var shaderblox_glsl__$GLSLTools_INode = function() { };
shaderblox_glsl__$GLSLTools_INode.__name__ = true;
shaderblox_glsl__$GLSLTools_INode.__isInterface__ = true;
shaderblox_glsl__$GLSLTools_INode.prototype = {
	__class__: shaderblox_glsl__$GLSLTools_INode
};
var shaderblox_glsl__$GLSLTools_StringNode = function(str) {
	if(str == null) {
		str = "";
	}
	this.contents = str;
};
shaderblox_glsl__$GLSLTools_StringNode.__name__ = true;
shaderblox_glsl__$GLSLTools_StringNode.__interfaces__ = [shaderblox_glsl__$GLSLTools_INode];
shaderblox_glsl__$GLSLTools_StringNode.prototype = {
	toString: function() {
		return this.contents;
	}
	,__class__: shaderblox_glsl__$GLSLTools_StringNode
};
var shaderblox_glsl__$GLSLTools_ScopeNode = function(brackets) {
	this.closeBracket = "";
	this.openBracket = "";
	this.contents = [];
	if(brackets != null) {
		this.openBracket = brackets.charAt(0);
		this.closeBracket = brackets.charAt(1);
	}
};
shaderblox_glsl__$GLSLTools_ScopeNode.__name__ = true;
shaderblox_glsl__$GLSLTools_ScopeNode.__interfaces__ = [shaderblox_glsl__$GLSLTools_INode];
shaderblox_glsl__$GLSLTools_ScopeNode.prototype = {
	toString: function() {
		var str = this.openBracket;
		var _g = 0;
		var _g1 = this.contents;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			str += n.toString();
		}
		return str + this.closeBracket;
	}
	,__class__: shaderblox_glsl__$GLSLTools_ScopeNode
};
var shaderblox_uniforms_IAppliable = function() { };
shaderblox_uniforms_IAppliable.__name__ = true;
shaderblox_uniforms_IAppliable.__isInterface__ = true;
shaderblox_uniforms_IAppliable.prototype = {
	__class__: shaderblox_uniforms_IAppliable
};
var shaderblox_uniforms_UniformBase_$Bool = function(gl,name,index,data) {
	this.alwaysDirty = false;
	this.gl = gl;
	this.name = name;
	this.location = index;
	this.dirty = true;
	this.data = data;
};
shaderblox_uniforms_UniformBase_$Bool.__name__ = true;
shaderblox_uniforms_UniformBase_$Bool.prototype = {
	__class__: shaderblox_uniforms_UniformBase_$Bool
};
var shaderblox_uniforms_UBool = function(gl,name,index,f) {
	if(f == null) {
		f = false;
	}
	shaderblox_uniforms_UniformBase_$Bool.call(this,gl,name,index,f);
};
shaderblox_uniforms_UBool.__name__ = true;
shaderblox_uniforms_UBool.__interfaces__ = [shaderblox_uniforms_IAppliable];
shaderblox_uniforms_UBool.__super__ = shaderblox_uniforms_UniformBase_$Bool;
shaderblox_uniforms_UBool.prototype = $extend(shaderblox_uniforms_UniformBase_$Bool.prototype,{
	apply: function() {
		this.gl.uniform1i(this.location,this.data ? 1 : 0);
		this.dirty = false;
	}
	,__class__: shaderblox_uniforms_UBool
});
var shaderblox_uniforms_UniformBase_$Float = function(gl,name,index,data) {
	this.alwaysDirty = false;
	this.gl = gl;
	this.name = name;
	this.location = index;
	this.dirty = true;
	this.data = data;
};
shaderblox_uniforms_UniformBase_$Float.__name__ = true;
shaderblox_uniforms_UniformBase_$Float.prototype = {
	__class__: shaderblox_uniforms_UniformBase_$Float
};
var shaderblox_uniforms_UFloat = function(gl,name,index,f) {
	if(f == null) {
		f = 0.0;
	}
	shaderblox_uniforms_UniformBase_$Float.call(this,gl,name,index,f);
};
shaderblox_uniforms_UFloat.__name__ = true;
shaderblox_uniforms_UFloat.__interfaces__ = [shaderblox_uniforms_IAppliable];
shaderblox_uniforms_UFloat.__super__ = shaderblox_uniforms_UniformBase_$Float;
shaderblox_uniforms_UFloat.prototype = $extend(shaderblox_uniforms_UniformBase_$Float.prototype,{
	apply: function() {
		this.gl.uniform1f(this.location,this.data);
		this.dirty = false;
	}
	,__class__: shaderblox_uniforms_UFloat
});
var shaderblox_uniforms_UniformBase_$Int = function(gl,name,index,data) {
	this.alwaysDirty = false;
	this.gl = gl;
	this.name = name;
	this.location = index;
	this.dirty = true;
	this.data = data;
};
shaderblox_uniforms_UniformBase_$Int.__name__ = true;
shaderblox_uniforms_UniformBase_$Int.prototype = {
	__class__: shaderblox_uniforms_UniformBase_$Int
};
var shaderblox_uniforms_UInt = function(gl,name,index,f) {
	if(f == null) {
		f = 0;
	}
	shaderblox_uniforms_UniformBase_$Int.call(this,gl,name,index,f);
};
shaderblox_uniforms_UInt.__name__ = true;
shaderblox_uniforms_UInt.__interfaces__ = [shaderblox_uniforms_IAppliable];
shaderblox_uniforms_UInt.__super__ = shaderblox_uniforms_UniformBase_$Int;
shaderblox_uniforms_UInt.prototype = $extend(shaderblox_uniforms_UniformBase_$Int.prototype,{
	apply: function() {
		this.gl.uniform1i(this.location,this.data);
		this.dirty = false;
	}
	,__class__: shaderblox_uniforms_UInt
});
var shaderblox_uniforms_UniformBase_$gluon_$webgl_$GLTexture = function(gl,name,index,data) {
	this.alwaysDirty = false;
	this.gl = gl;
	this.name = name;
	this.location = index;
	this.dirty = true;
	this.data = data;
};
shaderblox_uniforms_UniformBase_$gluon_$webgl_$GLTexture.__name__ = true;
shaderblox_uniforms_UniformBase_$gluon_$webgl_$GLTexture.prototype = {
	__class__: shaderblox_uniforms_UniformBase_$gluon_$webgl_$GLTexture
};
var shaderblox_uniforms_UTexture = function(gl,name,index,cube) {
	if(cube == null) {
		cube = false;
	}
	this.gpuSideValue = -1;
	this.cube = cube;
	this.type = cube ? 34067 : 3553;
	shaderblox_uniforms_UniformBase_$gluon_$webgl_$GLTexture.call(this,gl,name,index,null);
};
shaderblox_uniforms_UTexture.__name__ = true;
shaderblox_uniforms_UTexture.__interfaces__ = [shaderblox_uniforms_IAppliable];
shaderblox_uniforms_UTexture.__super__ = shaderblox_uniforms_UniformBase_$gluon_$webgl_$GLTexture;
shaderblox_uniforms_UTexture.prototype = $extend(shaderblox_uniforms_UniformBase_$gluon_$webgl_$GLTexture.prototype,{
	apply: function() {
		if(this.data == null) {
			return;
		}
		var idx = 33984 + this.samplerIndex;
		if(shaderblox_uniforms_UTexture.lastActiveTexture != idx) {
			this.gl.activeTexture(idx);
			shaderblox_uniforms_UTexture.lastActiveTexture = idx;
		}
		this.gl.bindTexture(this.type,this.data);
		if(this.gpuSideValue != this.samplerIndex) {
			this.gl.uniform1i(this.location,this.samplerIndex);
			this.gpuSideValue = this.samplerIndex;
		}
	}
	,__class__: shaderblox_uniforms_UTexture
});
var shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec2 = function(gl,name,index,data) {
	this.alwaysDirty = false;
	this.gl = gl;
	this.name = name;
	this.location = index;
	this.dirty = true;
	this.data = data;
};
shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec2.__name__ = true;
shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec2.prototype = {
	__class__: shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec2
};
var shaderblox_uniforms_UVec2 = function(gl,name,index,x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var x1 = x;
	var y1 = y;
	if(y1 == null) {
		y1 = 0;
	}
	if(x1 == null) {
		x1 = 0;
	}
	var this1 = new Float32Array(2);
	this1[0] = x1;
	this1[1] = y1;
	shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec2.call(this,gl,name,index,this1);
};
shaderblox_uniforms_UVec2.__name__ = true;
shaderblox_uniforms_UVec2.__interfaces__ = [shaderblox_uniforms_IAppliable];
shaderblox_uniforms_UVec2.__super__ = shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec2;
shaderblox_uniforms_UVec2.prototype = $extend(shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec2.prototype,{
	apply: function() {
		this.gl.uniform2f(this.location,this.data[0],this.data[1]);
		this.dirty = false;
	}
	,__class__: shaderblox_uniforms_UVec2
});
var shaderblox_uniforms_UniformBase_$typedarray_$Float32Array = function(gl,name,index,data) {
	this.alwaysDirty = false;
	this.gl = gl;
	this.name = name;
	this.location = index;
	this.dirty = true;
	this.data = data;
};
shaderblox_uniforms_UniformBase_$typedarray_$Float32Array.__name__ = true;
shaderblox_uniforms_UniformBase_$typedarray_$Float32Array.prototype = {
	__class__: shaderblox_uniforms_UniformBase_$typedarray_$Float32Array
};
var shaderblox_uniforms_UVec2Array = function(gl,name,index,arraySize,a) {
	this.arraySize = arraySize;
	if(a == null) {
		this.buffer = new Float32Array(arraySize * 2);
	}
	shaderblox_uniforms_UniformBase_$typedarray_$Float32Array.call(this,gl,name,index,this.buffer);
};
shaderblox_uniforms_UVec2Array.__name__ = true;
shaderblox_uniforms_UVec2Array.__interfaces__ = [shaderblox_uniforms_IAppliable];
shaderblox_uniforms_UVec2Array.__super__ = shaderblox_uniforms_UniformBase_$typedarray_$Float32Array;
shaderblox_uniforms_UVec2Array.prototype = $extend(shaderblox_uniforms_UniformBase_$typedarray_$Float32Array.prototype,{
	apply: function() {
		this.gl.uniform2fv(this.location,this.data);
		this.dirty = false;
	}
	,__class__: shaderblox_uniforms_UVec2Array
});
var shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec3 = function(gl,name,index,data) {
	this.alwaysDirty = false;
	this.gl = gl;
	this.name = name;
	this.location = index;
	this.dirty = true;
	this.data = data;
};
shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec3.__name__ = true;
shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec3.prototype = {
	__class__: shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec3
};
var shaderblox_uniforms_UVec3 = function(gl,name,index,x,y,z) {
	if(z == null) {
		z = 0;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0;
	}
	if(y1 == null) {
		y1 = 0;
	}
	if(x1 == null) {
		x1 = 0;
	}
	var this1 = new Float32Array(3);
	this1[0] = x1;
	this1[1] = y1;
	this1[2] = z1;
	shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec3.call(this,gl,name,index,this1);
};
shaderblox_uniforms_UVec3.__name__ = true;
shaderblox_uniforms_UVec3.__interfaces__ = [shaderblox_uniforms_IAppliable];
shaderblox_uniforms_UVec3.__super__ = shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec3;
shaderblox_uniforms_UVec3.prototype = $extend(shaderblox_uniforms_UniformBase_$shaderblox_$uniforms_$Vec3.prototype,{
	apply: function() {
		this.gl.uniform3f(this.location,this.data[0],this.data[1],this.data[2]);
		this.dirty = false;
	}
	,__class__: shaderblox_uniforms_UVec3
});
var shaderblox_uniforms_UVec4Array = function(gl,name,index,arraySize,a) {
	this.arraySize = arraySize;
	if(a == null) {
		this.buffer = new Float32Array(arraySize * 4);
	}
	shaderblox_uniforms_UniformBase_$typedarray_$Float32Array.call(this,gl,name,index,this.buffer);
};
shaderblox_uniforms_UVec4Array.__name__ = true;
shaderblox_uniforms_UVec4Array.__interfaces__ = [shaderblox_uniforms_IAppliable];
shaderblox_uniforms_UVec4Array.__super__ = shaderblox_uniforms_UniformBase_$typedarray_$Float32Array;
shaderblox_uniforms_UVec4Array.prototype = $extend(shaderblox_uniforms_UniformBase_$typedarray_$Float32Array.prototype,{
	apply: function() {
		this.gl.uniform4fv(this.location,this.data);
		this.dirty = false;
	}
	,__class__: shaderblox_uniforms_UVec4Array
});
var shaders_Gradient = function() { };
shaders_Gradient.__name__ = true;
shaders_Gradient.vec3LinearGradient = function(stopCount) {
	var tmp = "vec3 linearGradient" + stopCount + "(vec4 g[" + stopCount + "], float x) {\n            return\n                ";
	var _g = [];
	var _g1 = 1;
	var _g2 = stopCount;
	while(_g1 < _g2) {
		var i = _g1++;
		var stepL = i - 1 == 0 ? "1.0" : "step(g[" + (i - 1) + "].w, x)";
		var stepR = i == stopCount - 1 ? "1.0" : "step(x, g[" + i + "].w)";
		var iw = i == stopCount - 1 ? "1.0" : "g[" + i + "].w";
		var regionMask = "" + stepL + " * " + stepR;
		var blend = "mix(g[" + (i - 1) + "].rgb, g[" + i + "].rgb, (x - g[" + (i - 1) + "].w) / (" + iw + " - g[" + (i - 1) + "].w))";
		_g.push("" + (i > 1 ? "+" : "") + " " + regionMask + " * " + blend);
	}
	return tmp + _g.join("\n") + "\n\n            ;\n        }\n        ";
};
var shaders_Resample = function(gl) {
	shaderblox_ShaderBase.call(this,gl);
};
shaders_Resample.__name__ = true;
shaders_Resample.__super__ = shaderblox_ShaderBase;
shaders_Resample.prototype = $extend(shaderblox_ShaderBase.prototype,{
	createProperties: function() {
		shaderblox_ShaderBase.prototype.createProperties.call(this);
		var instance = new shaderblox_uniforms_UTexture(this.gl,"texture",null,false);
		this.texture = instance;
		this._uniforms.push(instance);
		var instance = new shaderblox_attributes_FloatAttribute("vertexPosition",0,2);
		this.vertexPosition = instance;
		this._attributes.push(instance);
		this._aStride += 8;
	}
	,initSources: function() {
		this._vertSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nattribute vec2 vertexPosition;\n\tvarying vec2 texelCoord;\n\tvoid main(){\n\t\ttexelCoord = vertexPosition;\n\t\tgl_Position = vec4(vertexPosition*2.0 - 1.0, 0.0, 1.0 );\n\t}\n";
		this._fragSource = "\n#ifdef GL_ES\nprecision highp float;\nprecision highp sampler2D;\n#endif\n\nuniform sampler2D texture;\n\tvarying vec2 texelCoord;\n\tvoid main(){\n\t\tgl_FragColor = texture2D(texture, texelCoord);\n\t}\n";
	}
	,__class__: shaders_Resample
});
var ui_GradientTools = function() { };
ui_GradientTools.__name__ = true;
ui_GradientTools.gradientToArray = function(g,gamma) {
	var array = [];
	var _g = 0;
	var _g1 = g.stops.length;
	while(_g < _g1) {
		var i = _g++;
		var p = i * 4;
		var stop = g.stops[i];
		if(stop == null) {
			stop = g.stops[g.stops.length - 1];
		}
		array[p] = Math.pow(stop.color[0],gamma);
		array[p + 1] = Math.pow(stop.color[1],gamma);
		array[p + 2] = Math.pow(stop.color[2],gamma);
		array[p + 3] = stop.p;
	}
	return array;
};
var ui_LinearGradientController = function(object,property) {
	this.mutationUpdateMode = false;
	var _gthis = this;
	dat.controllers.Controller.call(this,object,property);
	this.display = window.document.createElement("div");
	this.display.style.display = "block";
	this.display.style.width = "100%";
	this.display.style.height = "19px";
	var tmp = ui_LinearGradientController.normalizeGradientObject(this.initialValue);
	this.display.style.backgroundImage = ui_LinearGradientController.generateLinearGradient(tmp);
	this.display.addEventListener("click",function() {
		var result = window.prompt("Paste CSS Gradient",_gthis.display.style.backgroundImage);
		var parsed = ui_LinearGradientController.parseLinearGradient(result);
		if(parsed == null) {
			window.alert(Std.string("Did not recognise gradint format \"" + result + "\". Should look like: linear-gradient(90deg, rgb(118, 25, 159) 0%, rgb(255, 39, 232) 100%)"));
		} else {
			if(parsed.stops.length > 5) {
				var v = "Only 5 color stops are supported at the moment (the gradient had " + parsed.stops.length + ")";
				window.alert(Std.string(v));
			}
			_gthis.setValue(parsed);
			_gthis.__onFinishChange();
		}
	});
	this.display.style.cursor = "pointer";
	this.domElement.appendChild(this.display);
	var styleObserver = new MutationObserver(function(_,_1) {
		_gthis.mutationUpdateMode = true;
		_gthis.setValue(ui_LinearGradientController.parseLinearGradient(_gthis.display.style.backgroundImage));
	});
	styleObserver.observe(this.display,{ attributes : true, attributeFilter : ["style"]});
};
ui_LinearGradientController.__name__ = true;
ui_LinearGradientController.scopePreservingSplit = function(str,by) {
	var scopePairs = ["()","[]","{}","<>"];
	var scopeState = [0,0,0,0];
	var parts = [];
	var buffer = "";
	var _g = 0;
	var _g1 = str.length;
	while(_g < _g1) {
		var i = _g++;
		var c = str.charAt(i);
		var _g2 = 0;
		var _g3 = scopePairs.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			var open = scopePairs[i1].charAt(0);
			var close = scopePairs[i1].charAt(1);
			if(c == open) {
				scopeState[i1]++;
				break;
			}
			if(c == close) {
				scopeState[i1]--;
				break;
			}
		}
		var withinScope = Lambda.find(scopeState,function(s) {
			return s > 0;
		}) != null;
		if(c == "," && !withinScope) {
			parts.push(buffer);
			buffer = "";
		} else {
			buffer += c;
		}
	}
	parts.push(buffer);
	return parts;
};
ui_LinearGradientController.parseLinearGradient = function(css) {
	css = StringTools.trim(css);
	var p = new EReg("linear-gradient\\(","igm");
	if(!p.match(css)) {
		return null;
	}
	var args = ui_LinearGradientController.scopePreservingSplit(p.matchedRight(),",");
	var angle = 0;
	var anglePattern = new EReg("([\\d.]+)(\\w+)","igm");
	var directionPattern = new EReg("to\\s+(\\w+)","igm");
	var percentPattern = new EReg("[\\d.]+\\s*%","igm");
	var colorstopArgs;
	if(anglePattern.match(args[0])) {
		var unit = anglePattern.matched(2).toLowerCase();
		var value = parseFloat(anglePattern.matched(1));
		switch(unit) {
		case "deg":
			angle = value;
			break;
		case "grad":
			angle = value / 400 * 360;
			break;
		case "rad":
			angle = value / Math.PI * 2 * 360;
			break;
		case "turn":
			angle = value * 360;
			break;
		default:
			angle = value;
		}
		colorstopArgs = args.slice(1);
	} else if(directionPattern.match(args[0])) {
		switch(directionPattern.matched(1).toLowerCase()) {
		case "bottom":
			angle = 180;
			break;
		case "left":
			angle = 270;
			break;
		case "right":
			angle = 90;
			break;
		case "top":
			angle = 0;
			break;
		default:
			angle = 0;
		}
		colorstopArgs = args.slice(1);
	} else {
		colorstopArgs = args;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = colorstopArgs.length;
	while(_g1 < _g2) {
		var i = _g1++;
		var s = colorstopArgs[i];
		var position = i / (colorstopArgs.length - 1);
		var colorString = s;
		if(percentPattern.match(s)) {
			var value = parseFloat(percentPattern.matched(0));
			if(isFinite(value)) {
				position = value / 100;
			}
			colorString = percentPattern.matchedLeft();
		}
		_g.push({ color : ui_LinearGradientController.parseCSSColor(StringTools.trim(colorString)), p : position});
	}
	var stops = _g;
	if(angle < 0) {
		angle = 360 + angle % 360;
	} else {
		angle %= 360;
	}
	return { angle : angle, stops : stops};
};
ui_LinearGradientController.normalizeGradientObject = function(obj) {
	var angle;
	var stops;
	if(obj.angle != null) {
		angle = obj.angle;
	} else {
		angle = 90;
	}
	if(obj.stops != null) {
		stops = obj.stops;
	} else {
		stops = obj;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = stops.length;
	while(_g1 < _g2) {
		var i = _g1++;
		var entry = stops[i];
		var defaultP = i / (stops.length - 1);
		if(Array.isArray(entry)) {
			_g.push({ p : defaultP, color : entry});
		} else if(entry.color != null) {
			_g.push({ p : entry.p != null ? entry.p : defaultP, color : Array.isArray(entry.color) ? entry.color : entry.color});
		} else {
			_g.push({ p : defaultP, color : ui_LinearGradientController.parseCSSColor(entry)});
		}
	}
	return { angle : angle, stops : _g};
};
ui_LinearGradientController.generateLinearGradient = function(gradient) {
	var _this = gradient.stops;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var stop = _this[i];
		var normalizedColor = stop.color;
		var alpha = normalizedColor[3] != null ? normalizedColor[3] : 1;
		result[i] = "" + ("rgba(" + Math.round(normalizedColor[0] * 255) + ", " + Math.round(normalizedColor[1] * 255) + ", " + Math.round(normalizedColor[2] * 255) + ", " + alpha + ")") + " " + stop.p * 100 + "%";
	}
	var stopArgs = result;
	return "linear-gradient(" + gradient.angle + "deg, " + stopArgs.join(", ") + ")";
};
ui_LinearGradientController.arrayToCSSColor = function(normalizedColor) {
	var alpha = normalizedColor[3] != null ? normalizedColor[3] : 1;
	return "rgba(" + Math.round(normalizedColor[0] * 255) + ", " + Math.round(normalizedColor[1] * 255) + ", " + Math.round(normalizedColor[2] * 255) + ", " + alpha + ")";
};
ui_LinearGradientController.parseCSSColor = function(color) {
	var ctx = ui_LinearGradientController.get1pxCtx();
	ctx.fillStyle = color;
	ctx.fillRect(0,0,1,1);
	var rgbaUInt8 = ctx.getImageData(0,0,1,1).data;
	return [rgbaUInt8[0] / 255,rgbaUInt8[1] / 255,rgbaUInt8[2] / 255,rgbaUInt8[3] / 255];
};
ui_LinearGradientController.get1pxCtx = function() {
	if(ui_LinearGradientController._1pxCtx == null) {
		var canvas = window.document.createElement("canvas");
		canvas.width = 1;
		canvas.height = 1;
		ui_LinearGradientController._1pxCtx = canvas.getContext("2d");
		ui_LinearGradientController._1pxCtx.globalCompositeOperation = "copy";
	}
	return ui_LinearGradientController._1pxCtx;
};
ui_LinearGradientController.isArray = function(o) {
	return Array.isArray(o);
};
ui_LinearGradientController.__super__ = dat.controllers.Controller;
ui_LinearGradientController.prototype = $extend(dat.controllers.Controller.prototype,{
	updateDisplay: function() {
		if(!this.mutationUpdateMode) {
			var current = this.getValue();
			var tmp = ui_LinearGradientController.normalizeGradientObject(current);
			this.display.style.backgroundImage = ui_LinearGradientController.generateLinearGradient(tmp);
		}
		this.mutationUpdateMode = false;
		return this;
	}
	,__class__: ui_LinearGradientController
});
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
var originalCreate = dat.ControllerFactory.create;
dat.ControllerFactory.create = function(object,property,_) {
	var p = object[property];
	if(Array.isArray(p) && (p[0].color != null || Array.isArray(p[0]))) {
		return new ui_LinearGradientController(object,property);
	}
	if(typeof(p) == "object" && p.stops != null) {
		return new ui_LinearGradientController(object,property);
	}
	return originalCreate.apply(this,arguments);
};
Console.formatMode = Console.determineConsoleFormatMode();
Console.logPrefix = "<b,gray>><//> ";
Console.errorPrefix = "<b,red>></b> ";
Console.successPrefix = "<b,light_green>><//> ";
Console.argSeparator = " ";
Console.formatTagPattern = new EReg("(\\\\)?<(/)?([^><{}\\s]*|{[^}<>]*})>","g");
FluidComponent.MAX_POINTERS = 10;
FluidComponent.gamma = 2.1;
GPUCapabilities.capsCache = [];
SharedGPUResources.resources = new _$SharedGPUResources_Resources(null,null,null,null,null,null);
gluon_webgl_GLContextDebug.constantNameMap = (function($this) {
	var $r;
	var _g = new haxe_ds_IntMap();
	_g.h[36193] = "HALF_FLOAT_OES";
	_g.h[0] = "NONE";
	_g.h[256] = "DEPTH_BUFFER_BIT";
	_g.h[1024] = "STENCIL_BUFFER_BIT";
	_g.h[16384] = "COLOR_BUFFER_BIT";
	_g.h[1] = "LINES";
	_g.h[2] = "LINE_LOOP";
	_g.h[3] = "LINE_STRIP";
	_g.h[4] = "TRIANGLES";
	_g.h[5] = "TRIANGLE_STRIP";
	_g.h[6] = "TRIANGLE_FAN";
	_g.h[768] = "SRC_COLOR";
	_g.h[769] = "ONE_MINUS_SRC_COLOR";
	_g.h[770] = "SRC_ALPHA";
	_g.h[771] = "ONE_MINUS_SRC_ALPHA";
	_g.h[772] = "DST_ALPHA";
	_g.h[773] = "ONE_MINUS_DST_ALPHA";
	_g.h[774] = "DST_COLOR";
	_g.h[775] = "ONE_MINUS_DST_COLOR";
	_g.h[776] = "SRC_ALPHA_SATURATE";
	_g.h[32774] = "FUNC_ADD";
	_g.h[32777] = "BLEND_EQUATION";
	_g.h[34877] = "BLEND_EQUATION_ALPHA";
	_g.h[32778] = "FUNC_SUBTRACT";
	_g.h[32779] = "FUNC_REVERSE_SUBTRACT";
	_g.h[32968] = "BLEND_DST_RGB";
	_g.h[32969] = "BLEND_SRC_RGB";
	_g.h[32970] = "BLEND_DST_ALPHA";
	_g.h[32971] = "BLEND_SRC_ALPHA";
	_g.h[32769] = "CONSTANT_COLOR";
	_g.h[32770] = "ONE_MINUS_CONSTANT_COLOR";
	_g.h[32771] = "CONSTANT_ALPHA";
	_g.h[32772] = "ONE_MINUS_CONSTANT_ALPHA";
	_g.h[32773] = "BLEND_COLOR";
	_g.h[34962] = "ARRAY_BUFFER";
	_g.h[34963] = "ELEMENT_ARRAY_BUFFER";
	_g.h[34964] = "ARRAY_BUFFER_BINDING";
	_g.h[34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
	_g.h[35040] = "STREAM_DRAW";
	_g.h[35044] = "STATIC_DRAW";
	_g.h[35048] = "DYNAMIC_DRAW";
	_g.h[34660] = "BUFFER_SIZE";
	_g.h[34661] = "BUFFER_USAGE";
	_g.h[34342] = "CURRENT_VERTEX_ATTRIB";
	_g.h[1028] = "FRONT";
	_g.h[1029] = "BACK";
	_g.h[1032] = "FRONT_AND_BACK";
	_g.h[3553] = "TEXTURE_2D";
	_g.h[2884] = "CULL_FACE";
	_g.h[3042] = "BLEND";
	_g.h[3024] = "DITHER";
	_g.h[2960] = "STENCIL_TEST";
	_g.h[2929] = "DEPTH_TEST";
	_g.h[3089] = "SCISSOR_TEST";
	_g.h[32823] = "POLYGON_OFFSET_FILL";
	_g.h[32926] = "SAMPLE_ALPHA_TO_COVERAGE";
	_g.h[32928] = "SAMPLE_COVERAGE";
	_g.h[1280] = "INVALID_ENUM";
	_g.h[1281] = "INVALID_VALUE";
	_g.h[1282] = "INVALID_OPERATION";
	_g.h[1285] = "OUT_OF_MEMORY";
	_g.h[2304] = "CW";
	_g.h[2305] = "CCW";
	_g.h[2849] = "LINE_WIDTH";
	_g.h[33901] = "ALIASED_POINT_SIZE_RANGE";
	_g.h[33902] = "ALIASED_LINE_WIDTH_RANGE";
	_g.h[2885] = "CULL_FACE_MODE";
	_g.h[2886] = "FRONT_FACE";
	_g.h[2928] = "DEPTH_RANGE";
	_g.h[2930] = "DEPTH_WRITEMASK";
	_g.h[2931] = "DEPTH_CLEAR_VALUE";
	_g.h[2932] = "DEPTH_FUNC";
	_g.h[2961] = "STENCIL_CLEAR_VALUE";
	_g.h[2962] = "STENCIL_FUNC";
	_g.h[2964] = "STENCIL_FAIL";
	_g.h[2965] = "STENCIL_PASS_DEPTH_FAIL";
	_g.h[2966] = "STENCIL_PASS_DEPTH_PASS";
	_g.h[2967] = "STENCIL_REF";
	_g.h[2963] = "STENCIL_VALUE_MASK";
	_g.h[2968] = "STENCIL_WRITEMASK";
	_g.h[34816] = "STENCIL_BACK_FUNC";
	_g.h[34817] = "STENCIL_BACK_FAIL";
	_g.h[34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
	_g.h[34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
	_g.h[36003] = "STENCIL_BACK_REF";
	_g.h[36004] = "STENCIL_BACK_VALUE_MASK";
	_g.h[36005] = "STENCIL_BACK_WRITEMASK";
	_g.h[2978] = "VIEWPORT";
	_g.h[3088] = "SCISSOR_BOX";
	_g.h[3106] = "COLOR_CLEAR_VALUE";
	_g.h[3107] = "COLOR_WRITEMASK";
	_g.h[3317] = "UNPACK_ALIGNMENT";
	_g.h[3333] = "PACK_ALIGNMENT";
	_g.h[3379] = "MAX_TEXTURE_SIZE";
	_g.h[3386] = "MAX_VIEWPORT_DIMS";
	_g.h[3408] = "SUBPIXEL_BITS";
	_g.h[3410] = "RED_BITS";
	_g.h[3411] = "GREEN_BITS";
	_g.h[3412] = "BLUE_BITS";
	_g.h[3413] = "ALPHA_BITS";
	_g.h[3414] = "DEPTH_BITS";
	_g.h[3415] = "STENCIL_BITS";
	_g.h[10752] = "POLYGON_OFFSET_UNITS";
	_g.h[32824] = "POLYGON_OFFSET_FACTOR";
	_g.h[32873] = "TEXTURE_BINDING_2D";
	_g.h[32936] = "SAMPLE_BUFFERS";
	_g.h[32937] = "SAMPLES";
	_g.h[32938] = "SAMPLE_COVERAGE_VALUE";
	_g.h[32939] = "SAMPLE_COVERAGE_INVERT";
	_g.h[34466] = "NUM_COMPRESSED_TEXTURE_FORMATS";
	_g.h[34467] = "COMPRESSED_TEXTURE_FORMATS";
	_g.h[4352] = "DONT_CARE";
	_g.h[4353] = "FASTEST";
	_g.h[4354] = "NICEST";
	_g.h[33170] = "GENERATE_MIPMAP_HINT";
	_g.h[5120] = "BYTE";
	_g.h[5121] = "UNSIGNED_BYTE";
	_g.h[5122] = "SHORT";
	_g.h[5123] = "UNSIGNED_SHORT";
	_g.h[5124] = "INT";
	_g.h[5125] = "UNSIGNED_INT";
	_g.h[5126] = "FLOAT";
	_g.h[5132] = "FIXED";
	_g.h[6402] = "DEPTH_COMPONENT";
	_g.h[6406] = "ALPHA";
	_g.h[6407] = "RGB";
	_g.h[6408] = "RGBA";
	_g.h[6409] = "LUMINANCE";
	_g.h[6410] = "LUMINANCE_ALPHA";
	_g.h[32819] = "UNSIGNED_SHORT_4_4_4_4";
	_g.h[32820] = "UNSIGNED_SHORT_5_5_5_1";
	_g.h[33635] = "UNSIGNED_SHORT_5_6_5";
	_g.h[35632] = "FRAGMENT_SHADER";
	_g.h[35633] = "VERTEX_SHADER";
	_g.h[34921] = "MAX_VERTEX_ATTRIBS";
	_g.h[36347] = "MAX_VERTEX_UNIFORM_VECTORS";
	_g.h[36348] = "MAX_VARYING_VECTORS";
	_g.h[35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
	_g.h[35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
	_g.h[34930] = "MAX_TEXTURE_IMAGE_UNITS";
	_g.h[36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
	_g.h[35663] = "SHADER_TYPE";
	_g.h[35712] = "DELETE_STATUS";
	_g.h[35714] = "LINK_STATUS";
	_g.h[35715] = "VALIDATE_STATUS";
	_g.h[35717] = "ATTACHED_SHADERS";
	_g.h[35718] = "ACTIVE_UNIFORMS";
	_g.h[35719] = "ACTIVE_UNIFORM_MAX_LENGTH";
	_g.h[35721] = "ACTIVE_ATTRIBUTES";
	_g.h[35722] = "ACTIVE_ATTRIBUTE_MAX_LENGTH";
	_g.h[35724] = "SHADING_LANGUAGE_VERSION";
	_g.h[35725] = "CURRENT_PROGRAM";
	_g.h[512] = "NEVER";
	_g.h[513] = "LESS";
	_g.h[514] = "EQUAL";
	_g.h[515] = "LEQUAL";
	_g.h[516] = "GREATER";
	_g.h[517] = "NOTEQUAL";
	_g.h[518] = "GEQUAL";
	_g.h[519] = "ALWAYS";
	_g.h[7680] = "KEEP";
	_g.h[7681] = "REPLACE";
	_g.h[7682] = "INCR";
	_g.h[7683] = "DECR";
	_g.h[5386] = "INVERT";
	_g.h[34055] = "INCR_WRAP";
	_g.h[34056] = "DECR_WRAP";
	_g.h[7936] = "VENDOR";
	_g.h[7937] = "RENDERER";
	_g.h[7938] = "VERSION";
	_g.h[7939] = "EXTENSIONS";
	_g.h[9728] = "NEAREST";
	_g.h[9729] = "LINEAR";
	_g.h[9984] = "NEAREST_MIPMAP_NEAREST";
	_g.h[9985] = "LINEAR_MIPMAP_NEAREST";
	_g.h[9986] = "NEAREST_MIPMAP_LINEAR";
	_g.h[9987] = "LINEAR_MIPMAP_LINEAR";
	_g.h[10240] = "TEXTURE_MAG_FILTER";
	_g.h[10241] = "TEXTURE_MIN_FILTER";
	_g.h[10242] = "TEXTURE_WRAP_S";
	_g.h[10243] = "TEXTURE_WRAP_T";
	_g.h[5890] = "TEXTURE";
	_g.h[34067] = "TEXTURE_CUBE_MAP";
	_g.h[34068] = "TEXTURE_BINDING_CUBE_MAP";
	_g.h[34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
	_g.h[34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
	_g.h[34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
	_g.h[34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
	_g.h[34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
	_g.h[34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
	_g.h[34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
	_g.h[33984] = "TEXTURE0";
	_g.h[33985] = "TEXTURE1";
	_g.h[33986] = "TEXTURE2";
	_g.h[33987] = "TEXTURE3";
	_g.h[33988] = "TEXTURE4";
	_g.h[33989] = "TEXTURE5";
	_g.h[33990] = "TEXTURE6";
	_g.h[33991] = "TEXTURE7";
	_g.h[33992] = "TEXTURE8";
	_g.h[33993] = "TEXTURE9";
	_g.h[33994] = "TEXTURE10";
	_g.h[33995] = "TEXTURE11";
	_g.h[33996] = "TEXTURE12";
	_g.h[33997] = "TEXTURE13";
	_g.h[33998] = "TEXTURE14";
	_g.h[33999] = "TEXTURE15";
	_g.h[34000] = "TEXTURE16";
	_g.h[34001] = "TEXTURE17";
	_g.h[34002] = "TEXTURE18";
	_g.h[34003] = "TEXTURE19";
	_g.h[34004] = "TEXTURE20";
	_g.h[34005] = "TEXTURE21";
	_g.h[34006] = "TEXTURE22";
	_g.h[34007] = "TEXTURE23";
	_g.h[34008] = "TEXTURE24";
	_g.h[34009] = "TEXTURE25";
	_g.h[34010] = "TEXTURE26";
	_g.h[34011] = "TEXTURE27";
	_g.h[34012] = "TEXTURE28";
	_g.h[34013] = "TEXTURE29";
	_g.h[34014] = "TEXTURE30";
	_g.h[34015] = "TEXTURE31";
	_g.h[34016] = "ACTIVE_TEXTURE";
	_g.h[10497] = "REPEAT";
	_g.h[33071] = "CLAMP_TO_EDGE";
	_g.h[33648] = "MIRRORED_REPEAT";
	_g.h[35664] = "FLOAT_VEC2";
	_g.h[35665] = "FLOAT_VEC3";
	_g.h[35666] = "FLOAT_VEC4";
	_g.h[35667] = "INT_VEC2";
	_g.h[35668] = "INT_VEC3";
	_g.h[35669] = "INT_VEC4";
	_g.h[35670] = "BOOL";
	_g.h[35671] = "BOOL_VEC2";
	_g.h[35672] = "BOOL_VEC3";
	_g.h[35673] = "BOOL_VEC4";
	_g.h[35674] = "FLOAT_MAT2";
	_g.h[35675] = "FLOAT_MAT3";
	_g.h[35676] = "FLOAT_MAT4";
	_g.h[35678] = "SAMPLER_2D";
	_g.h[35680] = "SAMPLER_CUBE";
	_g.h[34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
	_g.h[34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
	_g.h[34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
	_g.h[34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
	_g.h[34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
	_g.h[34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
	_g.h[34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
	_g.h[35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
	_g.h[35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
	_g.h[35713] = "COMPILE_STATUS";
	_g.h[35716] = "INFO_LOG_LENGTH";
	_g.h[35720] = "SHADER_SOURCE_LENGTH";
	_g.h[36346] = "SHADER_COMPILER";
	_g.h[36344] = "SHADER_BINARY_FORMATS";
	_g.h[36345] = "NUM_SHADER_BINARY_FORMATS";
	_g.h[36336] = "LOW_FLOAT";
	_g.h[36337] = "MEDIUM_FLOAT";
	_g.h[36338] = "HIGH_FLOAT";
	_g.h[36339] = "LOW_INT";
	_g.h[36340] = "MEDIUM_INT";
	_g.h[36341] = "HIGH_INT";
	_g.h[36160] = "FRAMEBUFFER";
	_g.h[36161] = "RENDERBUFFER";
	_g.h[32854] = "RGBA4";
	_g.h[32855] = "RGB5_A1";
	_g.h[36194] = "RGB565";
	_g.h[33189] = "DEPTH_COMPONENT16";
	_g.h[36168] = "STENCIL_INDEX8";
	_g.h[36162] = "RENDERBUFFER_WIDTH";
	_g.h[36163] = "RENDERBUFFER_HEIGHT";
	_g.h[36164] = "RENDERBUFFER_INTERNAL_FORMAT";
	_g.h[36176] = "RENDERBUFFER_RED_SIZE";
	_g.h[36177] = "RENDERBUFFER_GREEN_SIZE";
	_g.h[36178] = "RENDERBUFFER_BLUE_SIZE";
	_g.h[36179] = "RENDERBUFFER_ALPHA_SIZE";
	_g.h[36180] = "RENDERBUFFER_DEPTH_SIZE";
	_g.h[36181] = "RENDERBUFFER_STENCIL_SIZE";
	_g.h[36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
	_g.h[36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
	_g.h[36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
	_g.h[36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
	_g.h[36064] = "COLOR_ATTACHMENT0";
	_g.h[36096] = "DEPTH_ATTACHMENT";
	_g.h[36128] = "STENCIL_ATTACHMENT";
	_g.h[36053] = "FRAMEBUFFER_COMPLETE";
	_g.h[36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
	_g.h[36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
	_g.h[36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
	_g.h[36061] = "FRAMEBUFFER_UNSUPPORTED";
	_g.h[36006] = "FRAMEBUFFER_BINDING";
	_g.h[36007] = "RENDERBUFFER_BINDING";
	_g.h[34024] = "MAX_RENDERBUFFER_SIZE";
	_g.h[1286] = "INVALID_FRAMEBUFFER_OPERATION";
	_g.h[3074] = "READ_BUFFER";
	_g.h[3314] = "UNPACK_ROW_LENGTH";
	_g.h[3315] = "UNPACK_SKIP_ROWS";
	_g.h[3316] = "UNPACK_SKIP_PIXELS";
	_g.h[3330] = "PACK_ROW_LENGTH";
	_g.h[3331] = "PACK_SKIP_ROWS";
	_g.h[3332] = "PACK_SKIP_PIXELS";
	_g.h[6144] = "COLOR";
	_g.h[6145] = "DEPTH";
	_g.h[6146] = "STENCIL";
	_g.h[6403] = "RED";
	_g.h[32849] = "RGB8";
	_g.h[32856] = "RGBA8";
	_g.h[32857] = "RGB10_A2";
	_g.h[32874] = "TEXTURE_BINDING_3D";
	_g.h[32877] = "UNPACK_SKIP_IMAGES";
	_g.h[32878] = "UNPACK_IMAGE_HEIGHT";
	_g.h[32879] = "TEXTURE_3D";
	_g.h[32882] = "TEXTURE_WRAP_R";
	_g.h[32883] = "MAX_3D_TEXTURE_SIZE";
	_g.h[33640] = "UNSIGNED_INT_2_10_10_10_REV";
	_g.h[33000] = "MAX_ELEMENTS_VERTICES";
	_g.h[33001] = "MAX_ELEMENTS_INDICES";
	_g.h[33082] = "TEXTURE_MIN_LOD";
	_g.h[33083] = "TEXTURE_MAX_LOD";
	_g.h[33084] = "TEXTURE_BASE_LEVEL";
	_g.h[33085] = "TEXTURE_MAX_LEVEL";
	_g.h[32775] = "MIN";
	_g.h[32776] = "MAX";
	_g.h[33190] = "DEPTH_COMPONENT24";
	_g.h[34045] = "MAX_TEXTURE_LOD_BIAS";
	_g.h[34892] = "TEXTURE_COMPARE_MODE";
	_g.h[34893] = "TEXTURE_COMPARE_FUNC";
	_g.h[34917] = "CURRENT_QUERY";
	_g.h[34918] = "QUERY_RESULT";
	_g.h[34919] = "QUERY_RESULT_AVAILABLE";
	_g.h[35004] = "BUFFER_MAPPED";
	_g.h[35005] = "BUFFER_MAP_POINTER";
	_g.h[35041] = "STREAM_READ";
	_g.h[35042] = "STREAM_COPY";
	_g.h[35045] = "STATIC_READ";
	_g.h[35046] = "STATIC_COPY";
	_g.h[35049] = "DYNAMIC_READ";
	_g.h[35050] = "DYNAMIC_COPY";
	_g.h[34852] = "MAX_DRAW_BUFFERS";
	_g.h[34853] = "DRAW_BUFFER0";
	_g.h[34854] = "DRAW_BUFFER1";
	_g.h[34855] = "DRAW_BUFFER2";
	_g.h[34856] = "DRAW_BUFFER3";
	_g.h[34857] = "DRAW_BUFFER4";
	_g.h[34858] = "DRAW_BUFFER5";
	_g.h[34859] = "DRAW_BUFFER6";
	_g.h[34860] = "DRAW_BUFFER7";
	_g.h[34861] = "DRAW_BUFFER8";
	_g.h[34862] = "DRAW_BUFFER9";
	_g.h[34863] = "DRAW_BUFFER10";
	_g.h[34864] = "DRAW_BUFFER11";
	_g.h[34865] = "DRAW_BUFFER12";
	_g.h[34866] = "DRAW_BUFFER13";
	_g.h[34867] = "DRAW_BUFFER14";
	_g.h[34868] = "DRAW_BUFFER15";
	_g.h[35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
	_g.h[35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
	_g.h[35679] = "SAMPLER_3D";
	_g.h[35682] = "SAMPLER_2D_SHADOW";
	_g.h[35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
	_g.h[35051] = "PIXEL_PACK_BUFFER";
	_g.h[35052] = "PIXEL_UNPACK_BUFFER";
	_g.h[35053] = "PIXEL_PACK_BUFFER_BINDING";
	_g.h[35055] = "PIXEL_UNPACK_BUFFER_BINDING";
	_g.h[35685] = "FLOAT_MAT2x3";
	_g.h[35686] = "FLOAT_MAT2x4";
	_g.h[35687] = "FLOAT_MAT3x2";
	_g.h[35688] = "FLOAT_MAT3x4";
	_g.h[35689] = "FLOAT_MAT4x2";
	_g.h[35690] = "FLOAT_MAT4x3";
	_g.h[35904] = "SRGB";
	_g.h[35905] = "SRGB8";
	_g.h[35907] = "SRGB8_ALPHA8";
	_g.h[34894] = "COMPARE_REF_TO_TEXTURE";
	_g.h[33307] = "MAJOR_VERSION";
	_g.h[33308] = "MINOR_VERSION";
	_g.h[33309] = "NUM_EXTENSIONS";
	_g.h[34836] = "RGBA32F";
	_g.h[34837] = "RGB32F";
	_g.h[34842] = "RGBA16F";
	_g.h[34843] = "RGB16F";
	_g.h[35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
	_g.h[35071] = "MAX_ARRAY_TEXTURE_LAYERS";
	_g.h[35076] = "MIN_PROGRAM_TEXEL_OFFSET";
	_g.h[35077] = "MAX_PROGRAM_TEXEL_OFFSET";
	_g.h[35659] = "MAX_VARYING_COMPONENTS";
	_g.h[35866] = "TEXTURE_2D_ARRAY";
	_g.h[35869] = "TEXTURE_BINDING_2D_ARRAY";
	_g.h[35898] = "R11F_G11F_B10F";
	_g.h[35899] = "UNSIGNED_INT_10F_11F_11F_REV";
	_g.h[35901] = "RGB9_E5";
	_g.h[35902] = "UNSIGNED_INT_5_9_9_9_REV";
	_g.h[35958] = "TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH";
	_g.h[35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
	_g.h[35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
	_g.h[35971] = "TRANSFORM_FEEDBACK_VARYINGS";
	_g.h[35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
	_g.h[35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
	_g.h[35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
	_g.h[35977] = "RASTERIZER_DISCARD";
	_g.h[35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
	_g.h[35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
	_g.h[35980] = "INTERLEAVED_ATTRIBS";
	_g.h[35981] = "SEPARATE_ATTRIBS";
	_g.h[35982] = "TRANSFORM_FEEDBACK_BUFFER";
	_g.h[35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
	_g.h[36208] = "RGBA32UI";
	_g.h[36209] = "RGB32UI";
	_g.h[36214] = "RGBA16UI";
	_g.h[36215] = "RGB16UI";
	_g.h[36220] = "RGBA8UI";
	_g.h[36221] = "RGB8UI";
	_g.h[36226] = "RGBA32I";
	_g.h[36227] = "RGB32I";
	_g.h[36232] = "RGBA16I";
	_g.h[36233] = "RGB16I";
	_g.h[36238] = "RGBA8I";
	_g.h[36239] = "RGB8I";
	_g.h[36244] = "RED_INTEGER";
	_g.h[36248] = "RGB_INTEGER";
	_g.h[36249] = "RGBA_INTEGER";
	_g.h[36289] = "SAMPLER_2D_ARRAY";
	_g.h[36292] = "SAMPLER_2D_ARRAY_SHADOW";
	_g.h[36293] = "SAMPLER_CUBE_SHADOW";
	_g.h[36294] = "UNSIGNED_INT_VEC2";
	_g.h[36295] = "UNSIGNED_INT_VEC3";
	_g.h[36296] = "UNSIGNED_INT_VEC4";
	_g.h[36298] = "INT_SAMPLER_2D";
	_g.h[36299] = "INT_SAMPLER_3D";
	_g.h[36300] = "INT_SAMPLER_CUBE";
	_g.h[36303] = "INT_SAMPLER_2D_ARRAY";
	_g.h[36306] = "UNSIGNED_INT_SAMPLER_2D";
	_g.h[36307] = "UNSIGNED_INT_SAMPLER_3D";
	_g.h[36308] = "UNSIGNED_INT_SAMPLER_CUBE";
	_g.h[36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
	_g.h[37151] = "BUFFER_ACCESS_FLAGS";
	_g.h[37152] = "BUFFER_MAP_LENGTH";
	_g.h[37153] = "BUFFER_MAP_OFFSET";
	_g.h[36012] = "DEPTH_COMPONENT32F";
	_g.h[36013] = "DEPTH32F_STENCIL8";
	_g.h[36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
	_g.h[33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
	_g.h[33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
	_g.h[33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
	_g.h[33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
	_g.h[33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
	_g.h[33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
	_g.h[33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
	_g.h[33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
	_g.h[33304] = "FRAMEBUFFER_DEFAULT";
	_g.h[33305] = "FRAMEBUFFER_UNDEFINED";
	_g.h[33306] = "DEPTH_STENCIL_ATTACHMENT";
	_g.h[34041] = "DEPTH_STENCIL";
	_g.h[34042] = "UNSIGNED_INT_24_8";
	_g.h[35056] = "DEPTH24_STENCIL8";
	_g.h[35863] = "UNSIGNED_NORMALIZED";
	_g.h[36008] = "READ_FRAMEBUFFER";
	_g.h[36009] = "DRAW_FRAMEBUFFER";
	_g.h[36010] = "READ_FRAMEBUFFER_BINDING";
	_g.h[36011] = "RENDERBUFFER_SAMPLES";
	_g.h[36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
	_g.h[36063] = "MAX_COLOR_ATTACHMENTS";
	_g.h[36065] = "COLOR_ATTACHMENT1";
	_g.h[36066] = "COLOR_ATTACHMENT2";
	_g.h[36067] = "COLOR_ATTACHMENT3";
	_g.h[36068] = "COLOR_ATTACHMENT4";
	_g.h[36069] = "COLOR_ATTACHMENT5";
	_g.h[36070] = "COLOR_ATTACHMENT6";
	_g.h[36071] = "COLOR_ATTACHMENT7";
	_g.h[36072] = "COLOR_ATTACHMENT8";
	_g.h[36073] = "COLOR_ATTACHMENT9";
	_g.h[36074] = "COLOR_ATTACHMENT10";
	_g.h[36075] = "COLOR_ATTACHMENT11";
	_g.h[36076] = "COLOR_ATTACHMENT12";
	_g.h[36077] = "COLOR_ATTACHMENT13";
	_g.h[36078] = "COLOR_ATTACHMENT14";
	_g.h[36079] = "COLOR_ATTACHMENT15";
	_g.h[36080] = "COLOR_ATTACHMENT16";
	_g.h[36081] = "COLOR_ATTACHMENT17";
	_g.h[36082] = "COLOR_ATTACHMENT18";
	_g.h[36083] = "COLOR_ATTACHMENT19";
	_g.h[36084] = "COLOR_ATTACHMENT20";
	_g.h[36085] = "COLOR_ATTACHMENT21";
	_g.h[36086] = "COLOR_ATTACHMENT22";
	_g.h[36087] = "COLOR_ATTACHMENT23";
	_g.h[36088] = "COLOR_ATTACHMENT24";
	_g.h[36089] = "COLOR_ATTACHMENT25";
	_g.h[36090] = "COLOR_ATTACHMENT26";
	_g.h[36091] = "COLOR_ATTACHMENT27";
	_g.h[36092] = "COLOR_ATTACHMENT28";
	_g.h[36093] = "COLOR_ATTACHMENT29";
	_g.h[36094] = "COLOR_ATTACHMENT30";
	_g.h[36095] = "COLOR_ATTACHMENT31";
	_g.h[36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
	_g.h[36183] = "MAX_SAMPLES";
	_g.h[5131] = "HALF_FLOAT";
	_g.h[8] = "MAP_INVALIDATE_BUFFER_BIT";
	_g.h[16] = "MAP_FLUSH_EXPLICIT_BIT";
	_g.h[32] = "MAP_UNSYNCHRONIZED_BIT";
	_g.h[33319] = "RG";
	_g.h[33320] = "RG_INTEGER";
	_g.h[33321] = "R8";
	_g.h[33323] = "RG8";
	_g.h[33325] = "R16F";
	_g.h[33326] = "R32F";
	_g.h[33327] = "RG16F";
	_g.h[33328] = "RG32F";
	_g.h[33329] = "R8I";
	_g.h[33330] = "R8UI";
	_g.h[33331] = "R16I";
	_g.h[33332] = "R16UI";
	_g.h[33333] = "R32I";
	_g.h[33334] = "R32UI";
	_g.h[33335] = "RG8I";
	_g.h[33336] = "RG8UI";
	_g.h[33337] = "RG16I";
	_g.h[33338] = "RG16UI";
	_g.h[33339] = "RG32I";
	_g.h[33340] = "RG32UI";
	_g.h[34229] = "VERTEX_ARRAY_BINDING";
	_g.h[36756] = "R8_SNORM";
	_g.h[36757] = "RG8_SNORM";
	_g.h[36758] = "RGB8_SNORM";
	_g.h[36759] = "RGBA8_SNORM";
	_g.h[36764] = "SIGNED_NORMALIZED";
	_g.h[36201] = "PRIMITIVE_RESTART_FIXED_INDEX";
	_g.h[35345] = "UNIFORM_BUFFER";
	_g.h[35368] = "UNIFORM_BUFFER_BINDING";
	_g.h[35369] = "UNIFORM_BUFFER_START";
	_g.h[35370] = "UNIFORM_BUFFER_SIZE";
	_g.h[35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
	_g.h[35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
	_g.h[35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
	_g.h[35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
	_g.h[35376] = "MAX_UNIFORM_BLOCK_SIZE";
	_g.h[35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
	_g.h[35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
	_g.h[35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
	_g.h[35381] = "ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH";
	_g.h[35382] = "ACTIVE_UNIFORM_BLOCKS";
	_g.h[35383] = "UNIFORM_TYPE";
	_g.h[35384] = "UNIFORM_SIZE";
	_g.h[35385] = "UNIFORM_NAME_LENGTH";
	_g.h[35386] = "UNIFORM_BLOCK_INDEX";
	_g.h[35387] = "UNIFORM_OFFSET";
	_g.h[35388] = "UNIFORM_ARRAY_STRIDE";
	_g.h[35389] = "UNIFORM_MATRIX_STRIDE";
	_g.h[35390] = "UNIFORM_IS_ROW_MAJOR";
	_g.h[35391] = "UNIFORM_BLOCK_BINDING";
	_g.h[35392] = "UNIFORM_BLOCK_DATA_SIZE";
	_g.h[35393] = "UNIFORM_BLOCK_NAME_LENGTH";
	_g.h[35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
	_g.h[35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
	_g.h[35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
	_g.h[35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
	_g.h[37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
	_g.h[37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
	_g.h[37137] = "MAX_SERVER_WAIT_TIMEOUT";
	_g.h[37138] = "OBJECT_TYPE";
	_g.h[37139] = "SYNC_CONDITION";
	_g.h[37140] = "SYNC_STATUS";
	_g.h[37141] = "SYNC_FLAGS";
	_g.h[37142] = "SYNC_FENCE";
	_g.h[37143] = "SYNC_GPU_COMMANDS_COMPLETE";
	_g.h[37144] = "UNSIGNALED";
	_g.h[37145] = "SIGNALED";
	_g.h[37146] = "ALREADY_SIGNALED";
	_g.h[37147] = "TIMEOUT_EXPIRED";
	_g.h[37148] = "CONDITION_SATISFIED";
	_g.h[37149] = "WAIT_FAILED";
	_g.h[35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
	_g.h[35887] = "ANY_SAMPLES_PASSED";
	_g.h[36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
	_g.h[35097] = "SAMPLER_BINDING";
	_g.h[36975] = "RGB10_A2UI";
	_g.h[36418] = "TEXTURE_SWIZZLE_R";
	_g.h[36419] = "TEXTURE_SWIZZLE_G";
	_g.h[36420] = "TEXTURE_SWIZZLE_B";
	_g.h[36421] = "TEXTURE_SWIZZLE_A";
	_g.h[6404] = "GREEN";
	_g.h[6405] = "BLUE";
	_g.h[36255] = "INT_2_10_10_10_REV";
	_g.h[36386] = "TRANSFORM_FEEDBACK";
	_g.h[36387] = "TRANSFORM_FEEDBACK_PAUSED";
	_g.h[36388] = "TRANSFORM_FEEDBACK_ACTIVE";
	_g.h[36389] = "TRANSFORM_FEEDBACK_BINDING";
	_g.h[33367] = "PROGRAM_BINARY_RETRIEVABLE_HINT";
	_g.h[34625] = "PROGRAM_BINARY_LENGTH";
	_g.h[34814] = "NUM_PROGRAM_BINARY_FORMATS";
	_g.h[34815] = "PROGRAM_BINARY_FORMATS";
	_g.h[37488] = "COMPRESSED_R11_EAC";
	_g.h[37489] = "COMPRESSED_SIGNED_R11_EAC";
	_g.h[37490] = "COMPRESSED_RG11_EAC";
	_g.h[37491] = "COMPRESSED_SIGNED_RG11_EAC";
	_g.h[37492] = "COMPRESSED_RGB8_ETC2";
	_g.h[37493] = "COMPRESSED_SRGB8_ETC2";
	_g.h[37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
	_g.h[37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
	_g.h[37496] = "COMPRESSED_RGBA8_ETC2_EAC";
	_g.h[37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
	_g.h[37167] = "TEXTURE_IMMUTABLE_FORMAT";
	_g.h[36203] = "MAX_ELEMENT_INDEX";
	_g.h[37760] = "NUM_SAMPLE_COUNTS";
	_g.h[33503] = "TEXTURE_IMMUTABLE_LEVELS";
	$r = _g;
	return $r;
}(this));
shaderblox_glsl_GLSLTools.PRECISION_QUALIFIERS = ["lowp","mediump","highp"];
shaderblox_glsl_GLSLTools.STORAGE_QUALIFIER_TYPES = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["const"] = ["bool","int","float","vec2","vec3","vec4","bvec2","bvec3","bvec4","ivec2","ivec3","ivec4","mat2","mat3","mat4"];
	_g.h["attribute"] = ["float","vec2","vec3","vec4","mat2","mat3","mat4"];
	_g.h["uniform"] = ["bool","int","float","vec2","vec3","vec4","bvec2","bvec3","bvec4","ivec2","ivec3","ivec4","mat2","mat3","mat4","sampler2D","samplerCube"];
	_g.h["varying"] = ["float","vec2","vec3","vec4","mat2","mat3","mat4"];
	$r = _g;
	return $r;
}(this));
shaderblox_uniforms_UTexture.lastActiveTexture = -1;
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
