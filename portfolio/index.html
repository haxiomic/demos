<!DOCTYPE html>
<html>
<head>
	<title>Portfolio</title>
	<link rel="stylesheet" type="text/css" href="css/main.css">
	<meta charset="utf-8">
</head>
<body>
	<div class="main-header">
		<div class="container">
			<div class="header-nav">
				George Corney
			</div>
		</div>
	</div>

	<div class="main-content">
		<div class="container">

			<div class="item-group-header">Current Projects</div>

			<div class="item">
				<div class="details">
					<div class="row title-row">
						<div class="column ten">
							<h1 class="title">SuperSL</h1>
						</div>
						<div class="column two project-buttons">
							<h1><a href="https://github.com/haxiomic/haxe-glsl-parser"><span class="icon-github-circle-fill"></span></a></h1>
						</div>
					</div>
					<div class="tags">
						<ul>
							<li><span class="grey-tag">work in progress</span></li>
							<li>GLSL</li>
							<li>C</li>
							<li>Haxe</li>
							<li>LALR</li>
						</ul>
					</div>
					<div class="info">
						<p>SuperSL is an alternative shader programming language designed for the web. It's a superset of GLSL that aims to smooth out the process of writing shaders in browser environments. The key features of SuperSL are:</p>
						<ul>
							<li>Compile-time type casting and inference</li>
							<li>Automatic function prototype declarations</li>
							<li>New directive <span class="code code-inline">#include</span> for modular shaders</li>
							<li>Function type for function reference passing</li>
							<li>Functions within functions</li>
							<li>Default function arguments</li>
						</ul>

						<h4>Motivation</h4>
						<p>GLSL, the OpenGL shader programming language was introduced in 2004. The necessity for driver implementation simplicity and GPU hardware limitations constrained the language's features and born out of a time where most OpenGL programs were written in C or C++, GLSL was modeled after C.</p>

						<p>Fast-forward to 2013 and WebGL reaches its first stable release, using GLSL as the shader language. In the dynamically-typed Javascript environment of the browser, GLSL feels out of place with its strict typing and lack of flexibility which can make shader writing difficult for newcomers and add inertia to shader development. For example, the expression <span class="code code-inline">1.0 * 2</span> is forbidden in GLSL: 1.0 is a float whereas 2 is an int. Most languages will automatically cast the int to a float but GLSL doesn't, instead it reports a type-mismatch. Another issue is that GLSL can only see functions that have been defined above the current point of execution, to call a function below requires defining a function prototype somewhere above. In addition to its language weaknesses, driver implementations vary from machine to machine and without warning - GLSL can be valid and execute on one machine, but fail on another.</p>

						<h4>Details</h4>
						<p>SuperSL can be used to generate GLSL either at project compile time (like LESS or SASS) or at runtime. To make this possible with a single codebase SuperSL is written in <a href="http://haxe.org">haxe</a> and compiled to Javascript, C++ and Java (and potentially other platforms if the need arises).</p>
						<p>SuperSL uses a LALR parser based on the parser in <a href="http://www.hwaci.com/sw/lemon/">lemon parser generator</a></p>

						<h4>Project Status</h4>
						<p>The project is under heavy development at the moment. The core parser has been completed and work is underway on the validator and auto-typing system.</p>

						<h6>TL;DR</h6>
						<p>GLSL isn't ideal for browser based shader development, SuperSL is a superset of GLSL with additional language features to resolve some of GLSL shortcomings and make writing shaders for WebGL easier. In terms of features, SuperSL strikes a balance between GLSL's strictness and Javascript's flexibility without comprising on performance.</p>
					</div>
				</div>
				<div class="demo">
					<div class="caption">AST generation with the core parser</div>
					<img class="hplaceholder" src="images/placeholder-glsl-parser.jpg" data-iframe-src="http://haxiomic.github.io/haxe-glsl-parser/">
				</div>
			</div>

			<div class="item">
				<div class="details">
					<div class="row title-row">
						<div class="column all">
							<h1 class="title">WebGL Volume Renderer</h1>
						</div>
					</div>
					<div class="tags">
						<ul>
							<li><span class="grey-tag">work in progress</span></li>
							<li>WebGL</li>
							<li>GLSL</li>
							<li>Javascript</li>
							<li>haxe</li>
							<li>three.js</li>
						</ul>
					</div>
					<div class="info">
						<p>The Met Office's newly formed <a href="http://www.informaticslab.co.uk/">Informatics Lab</a> is developing a browser-based interactive weather data visualisation tool. The Met's supercomputers generate colossal 3D data fields that cover a volume of atmosphere above the UK. The Aim is to make this data accessible for anyone to view and study. My involvement in the collaboration is to help solve some of the many technical changes involved in rendering animated volumetric data with WebGL.</p>

						<h4>Technical Challenges</h4>
						<p>Achieving high performance with a ray-marched self-shadowing volume renderer is a significant challenge in itself, especially when targeting mobiles, but compounding that challenge is the requirement for the data to be animated and interactive. An easy technique to speed up rendering performance is to cache the lighting occlusion field for the volume in a texture, this would work well assuming our data and light source remain static, however the data will be changing rapidly as the weather fields are animated. To keep the animation smooth we could precompute the occlusion at startup, but this isn't ideal either - we're expecting about 360 frames of animation, if an occlusion pass takes 16ms per frame, then precomputing lighting costs 5.8 seconds at startup! The next option is to compute lighting on the server and bundle it with the weather data, but will the additional download time introduced be really less than the time computing it on the client?</p>

						<p>There's a requirement for the user to be able to fly through the data, this is tough - if the user is getting close to the data, the lighting occlusion resolution will have to be increased to create a convincing effect. Additionally, to reduce bandwidth the weather data is fairly coarse so we'll need to layer noise onto the cloud density field - necessitating client-side lighting computation.</p>

						<h4>Project Status</h4>
						<p>The Informatics Lab have developed a prototype volume renderer but the performance is far too poor for public release. My challenge as a contracted developer is to try and get it running at fast as possible before it goes live.</p>
					</div>
				</div>
				<style scoped>
				.demo.volume-render-demo iframe{
					height: 200%;
					top: -50%;
				}
				</style>
				<div class="demo volume-render-demo">
					<div class="caption">An early volume rendering experiment</div>
					<img class="hplaceholder" src="images/placeholder-volume-renderer.jpg" data-iframe-src="http://haxiomic.github.io/demos/volume-render">
				</div>
			</div>

			<div class="item-group-header">Past Projects</div>

			<div class="item">
				<div class="details">
					<div class="row title-row">
						<div class="column ten">
							<h1 class="title">WebGL Fluid</h1>
						</div>
						<div class="column two project-buttons">
							<h1><a href="https://github.com/haxiomic/GPU-Fluid-Experiments"><span class="icon-github-circle-fill"></span></a></h1>
						</div>
					</div>
					<div class="tags">
						<ul>
							<li>WebGL</li>
							<li>GLSL</li>
							<li>Haxe</li>
							<li>Javascript</li>
							<li>Fluid Dynamics</li>
						</ul>
					</div>
					<div class="info">
						<p>The aim of this project was to study using WebGL for high performance simulations and to investigate the performance factors involved.</p>

						<p>The simulation solves the Navier-Stokes equation for incompressible flow over a grid with the Jacobi method. Each simulation step is handled as follows:</p>

						<ul>
							<li>Self-advect the velocity field</li>
							<li>Handle user interaction with the velocity field</li>
							<li>Iteratively solve the pressure term of the Navier-Stokes equation to enforces incompressibility</li>
							<li>Handle user interaction with the dye field</li>
							<li>Advect dye field using velocity field</li>
							<li>Advance particles by simulating drag by the fluid</li>
						</ul>

						<p>Solving 2D partial differential equations over a grid is a fairly straight forward process in WebGL. Field values are stored in a texture and passed to the GPU, the solver iteration step renders the result to a new texture which is fed back as input in the next step. The old texture then becomes the target for rendering.</p>

						<p>Handling particles is less elegant, the particle properties are stored in a texture and a vertex buffer is used to store the texture coordinates of each particle's data. In a simulation step, the particle data is updated by a render-to-texture flip-flop (explained earlier). To render the particles, first a vertex shader uses the coordinate buffer to select particle data from the data texture and uses it to set the position of the rendered vertices, then a fragment shader then draws (and colors) the vertices using GL_Points mode.</p>

						<h4>Reception</h4>
						<p>Shortly after posting it front-paged reddit, from there it was picked up by popular content aggregators, including:</p>

						<div class="logo-group">
							<a href="http://www.fastcodesign.com/3038725/this-wonderful-web-toy-turns-your-browser-into-magic-liquid"><img src="images/logos/fast-company/logo-60.png"></a>

							<a href="http://thenextweb.com/creativity/2015/05/15/webgl-fluid-experiment-is-a-browser-based-lsd-trip/"><img src="images/logos/tnw/logo-60.png"></a>

							<a href="http://www.gizmodo.co.uk/2014/11/just-try-and-stop-playing-with-this-fluid-simulator/"><img src="images/logos/gizmodo/logo.png"></a>

							<a href="http://www.engadget.com/2015/05/15/GPU-physics-trippy-simulation/"><img src="images/logos/engadget/logo-60.png"></a>
						</div>

						<p>And since it was open source, it's even made its way into the <a href="http://mgd.com">landing page of Miller Genuine Draft</a>

						<p>To date it's been played with <b>1.8m</b> times by about <b>1.5m</b> users.</p>
					</div>
				</div>
				<div class="demo">
					<!-- <div class="caption"></div> -->
					<img class="hplaceholder placeholder" src="images/placeholder-webgl-fluid.jpg" data-url="http://haxiomic.github.io/GPU-Fluid-Experiments/html5/">
				</div>
			</div>

			<div class="item">
				<div class="details">
					<div class="row title-row">
						<div class="column all">
							<h1 class="title">Hive</h1>
						</div>
					</div>
					<div class="tags">
						<ul>
							<li>Objective-C</li>
							<li>Reverse Engineering</li>
							<li>UI &amp; UX</li>
							<li>Javascript</li>
							<li>Startup</li>
						</ul>
					</div>
					<div class="info">
						<p>Hive was a team collaboration app I worked on with friends during university. It was an experiment in developing the ideal collaboration tool, the philosophy was to make it feel as if there was almost no boundary between computers within a team - you'd be able to push content from your screen to a teammate's immediately and intuitively, in a similar manner to moving windows between multiple displays.</p>

						<p>'State-sharing' was one of the key technologies we experimented with, this exploited OS X's built in application state saving and restoring capability to transfer an application's state between computers. The result was that you could take any window on your machine and move it to another and it would appear in just the same state on the new machine.</p>

						<p>After winning <a href="http://blog.kairossociety.org/challenge-announcing-the-winners-of-the-kairos-cisco-challenge/">Cisco Open Collaboration Challenge</a> and 3 months of acceleration at <a href="http://www.dotforgeaccelerator.com/">dotforge</a> we chose to abandon the project. The primary cause being the reliance on hidden API's within OS X, this meant not only would we be barred from the app store, but that Apple had a significant advantage in developing similar technology - over the course of the acceleration apple released Yosemite with Handoff which behaved similarly to and was based on the same principles as state-sharing.</p>
					</div>
				</div>
				<style scoped>
				.demo.hive-demo .images{
					overflow: hidden;
				}
				.demo.hive-demo img{
					display: block;
				}
				</style>
				<div class="demo hive-demo">
					<div class="caption">Hive prototype UI designs</div>
					<!-- trick so that the shortest image defines the height of container -->
					<div class="images row-no-gutter no-collapse" style="position:relative;">
						<div class="column eight" style="position:absolute;margin-top: -10%;">
							<img src="images/projects/hive/side-window.png">
						</div>
						<div class="column four" style="float:right;margin-top: -5%;">
							<img src="images/projects/hive/hive-login.png">
						</div>
					</div>
				</div>
			</div>

			<div class="item">
				<div class="details">
					<div class="row title-row">
						<div class="column all">
							<h1 class="title">EventSpace</h1>
						</div>
					</div>
					<div class="tags">
						<ul>
							<li>UI &amp; UX</li>
							<li>Javascript</li>
							<li>Fontent Design</li>
							<li>Startup</li>
						</ul>
					</div>
					<div class="info">
						<p>I was asked to do some iPad and browser concept designs for an early stage startup in Sheffield called 'EventSpace'. EventSpace was an event companion managed by the organisers. Its aim was to allow easy communication between attendees and enable instant feedback to organisers.</p>
					</div>
				</div>
				<style scoped>
				.demo.eventspace-demo .images{
					overflow: hidden;
				}
				.demo.eventspace-demo img{
					display: block;
				}
				</style>
				<div class="demo eventspace-demo">
					<div class="images row-no-gutter no-collapse" style="position:relative;">
						<div class="column four">
							<img src="images/projects/eventspace/ipad-landscape-timeline.png">
						</div>
						<div class="column four">
							<img src="images/projects/eventspace/ipad-landscape-feedback.png">
						</div>
						<div class="column four" style="position:absolute;right:0;">
							<img src="images/projects/eventspace/Edit-Profile.png">
						</div>
					</div>
				</div>
			</div>

			<!--
			Medical App, UHL & backbone.js
			Think Happiness & Created in Bath
			Hive, Mac OS dev and UX 
			Swype
			Color Palette UI
			EventSpace
			Papers
			Explorations of Solar System Stability
			Pushing past the limits of light-based microscopy
			-->
		</div>
	</div>

	<!-- debug color palette -->
	<!--
	<script type="text/javascript" src="lib/js/color-palette-ui.js"></script>
	-->

	<!-- lazy haxe trace -->
	<script type="text/javascript">function trace(){console.log.apply(console, arguments);}</script>

	<!-- core dependencies -->
	<script type="text/javascript" src="lib/js/vendor/jquery-2.1.4.min.js"></script>

	<script type="text/javascript" src="js/extended-readmore.js"></script>
	<script type="text/javascript" src="js/hplaceholder.js"></script>
</body>
</html>